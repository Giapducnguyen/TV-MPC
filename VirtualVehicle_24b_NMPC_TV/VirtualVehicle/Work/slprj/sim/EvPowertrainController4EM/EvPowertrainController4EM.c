#include "EvPowertrainController4EM.h"
#include "rtwtypes.h"
#include "EvPowertrainController4EM_types.h"
#include "EvPowertrainController4EM_private.h"
#include <string.h>
#include "mwmathutil.h"
#include "rt_nrand_Upu32_Yd_f_pw_snf.h"
#include <emmintrin.h>
#include "minimum_OHNoIZs5.h"
#include "sumColumnB_PypaGfPh.h"
#include "checkVectorNonFinite_Mtnc75LS.h"
#include "checkVectorNonFinite_Fp2Tnt5U.h"
#include "fwdFinDiffInsideBnds_ackjW8wf.h"
#include "BFGSUpdate_LCEtP8Ng.h"
#include "computeGradLag_RU6nJ0OR.h"
#include "xgeqp3_QxlrhgAO.h"
#include "countsort_mFQteL5g.h"
#include "xgemv_pXms4vNT.h"
#include "xgemv_nX1Gae0k.h"
#include "xgemv_KU6NVrGg.h"
#include "xgemv_SHwV9wCf.h"
#include "xgemv_MHbFIwYa.h"
#include "xgemv_57x7PwZU.h"
#include "xnrm2_zbVenBlk.h"
#include "xgemv_e2rVE54U.h"
#include "xrotg_RoqvjOQy.h"
#include "xgeqrf_XRJGzhWP.h"
#include "xgemm_hPCPNDMQ.h"
#include "xgemm_A838MKtE.h"
#include "xgemv_o71yBVcy.h"
#include "xpotrf_3B98IbMt.h"
#include "xgemv_FKeSanhE.h"
#include "computeGradLag_pqhj2Pn4.h"
#include "EvPowertrainController4EM_capi.h"
#include "look1_binlcapw.h"
#include "plook_bincpa.h"
#include "intrp2d_la_pw.h"
#include "look1_pbinlcapw.h"
#include "div_nde_s32_floor.h"
#define elbvogf2ze (0.01)
static RegMdlInfo rtMdlInfo_EvPowertrainController4EM [ 70 ] = { {
"etgxjyp0hjh" , MDL_INFO_NAME_MDLREF_DWORK , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "oe2v3xtlsq" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "lymg0zmnsu" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "pqob4mhwh1" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "ep1gztsrtw" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "axpgzmd5rf" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "hrnjynfq0h" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "g4z2diq4bh" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "bk3r2brwhe" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "airhpqwvyd" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "bezcq2chz0" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "izuiovcupv" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "fuctzs4sww" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "d4m2qnxaxx" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "pugedykkrp" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "c3safteidr" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "pmaz4haa3k" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "eomqpqr0rk" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "cvnazlnugz" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "dx03fqh3vz" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "jtu2yp4mzt" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "o2dsc4aixv" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "cudgh3jl0o" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "EvPowertrainController4EM" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , 0 , ( NULL ) } , { "plyyj5wzgn" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "njz0210ca5h" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "n1mbwr340b" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "ghy3lg3t4k" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "cufix8_En1" , MDL_INFO_ID_CMPLX_DATA_TYPE
, 0 , - 1 , ( void * ) "ufix8_En1" } , { "ufix8_En1" , MDL_INFO_ID_DATA_TYPE
, 0 , - 1 , ( NULL ) } , { "cufix32_En8" , MDL_INFO_ID_CMPLX_DATA_TYPE , 0 ,
- 1 , ( void * ) "ufix32_En8" } , { "ufix32_En8" , MDL_INFO_ID_DATA_TYPE , 0
, - 1 , ( NULL ) } , {
"mr_EvPowertrainController4EM_GetSimStateDisallowedBlocks" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_extractBitFieldFromCellArrayWithOffset" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_cacheBitFieldToCellArrayWithOffset" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_restoreDataFromMxArrayWithOffset" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_cacheDataToMxArrayWithOffset" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_extractBitFieldFromMxArray" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_cacheBitFieldToMxArray" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_restoreDataFromMxArray" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_cacheDataAsMxArray" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_RegisterSimStateChecksum" ,
MDL_INFO_ID_MODEL_FCN_NAME , 0 , - 1 , ( void * ) "EvPowertrainController4EM"
} , { "mr_EvPowertrainController4EM_SetDWork" , MDL_INFO_ID_MODEL_FCN_NAME ,
0 , - 1 , ( void * ) "EvPowertrainController4EM" } , {
"mr_EvPowertrainController4EM_GetDWork" , MDL_INFO_ID_MODEL_FCN_NAME , 0 , -
1 , ( void * ) "EvPowertrainController4EM" } , { "iamwnmrrfd" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "c3tcu1vsoj" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "bhtu1h5bl5" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "drf2ph4ldh" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "ci1jcnwvc5" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "oytx5zapfu" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "kzv4ftj4e2" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "kmbpuy2anc" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "i4h2yyndkb" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "cuxlzjpzbn" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "n4zzvudoa0" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "ptup5lzvsv" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "k0wbmyv4jv" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "aoeufdu2eg" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "cpri2en1rb" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "beybg5myqr" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "mlbp3rbfnc" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "hwhqkz32ry" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "erg0nboo0r" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "d14ppd0cw1" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "p3anivedxd" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "nnul4dtq1q" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "nged4bnpig" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "ofxtwsq03r" ,
MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT , 0 , - 1 , ( void * )
"EvPowertrainController4EM" } , { "EvPowertrainController4EM.h" ,
MDL_INFO_MODEL_FILENAME , 0 , - 1 , ( NULL ) } , {
"EvPowertrainController4EM.c" , MDL_INFO_MODEL_FILENAME , 0 , - 1 , ( void *
) "EvPowertrainController4EM" } } ; njz0210ca5h njz0210ca5 = { 0.0005 ,
0.0005 , 0.01 , 0.3490658503988659 , 2.5 , 23341.0 , 23341.0 , 0.01 , 0.01 ,
1.0 , - 1.0 , 1.0 , - 1.0 , 1.0 , - 1.0 , 1.0 , - 1.0 , - 1.0 , - 1.0 , 100.0
, - 1.0 , 1.0 , - 1.0 , 1.0 , - 1.0 , 0.0 , 0.0 , - 1.5 , - 1.0 , 0.8 , 0.9 ,
1.0 , 0.8 , 0.9 , - 1.5 , - 1.0 , 0.8 , 0.9 , 1.0 , 0.8 , 0.9 , 0.0 , 0.0 ,
0.0 , 0.0 , 0.0 , 0.5 , 0.5 , 2.0 , 0.0 , 2.0 , 0.0 , 0.0 , 1.0 , { 0.0 ,
0.56281407035175879 , 1.1256281407035176 , 1.6884422110552764 ,
2.2512562814070352 , 2.8140703517587942 , 3.3768844221105527 ,
3.9396984924623117 , 4.50251256281407 , 5.0653266331658289 ,
5.6281407035175883 , 6.1909547738693469 , 6.7537688442211055 ,
7.316582914572864 , 7.8793969849246235 , 8.4422110552763812 ,
9.00502512562814 , 9.5678391959799 , 10.130653266331658 , 10.693467336683417
, 11.256281407035177 , 11.819095477386934 , 12.381909547738694 ,
12.944723618090451 , 13.507537688442211 , 14.07035175879397 ,
14.633165829145728 , 15.195979899497488 , 15.758793969849247 ,
16.321608040201006 , 16.884422110552762 , 17.447236180904522 ,
18.010050251256281 , 18.572864321608041 , 19.1356783919598 ,
19.698492462311556 , 20.261306532663315 , 20.824120603015075 ,
21.386934673366834 , 21.949748743718594 , 22.512562814070353 ,
23.075376884422109 , 23.638190954773869 , 24.201005025125628 ,
24.763819095477388 , 25.326633165829147 , 25.889447236180903 ,
26.452261306532662 , 27.015075376884422 , 27.577889447236181 ,
28.140703517587941 , 28.7035175879397 , 29.266331658291456 ,
29.829145728643216 , 30.391959798994975 , 30.954773869346734 ,
31.517587939698494 , 32.08040201005025 , 32.643216080402013 ,
33.206030150753769 , 33.768844221105525 , 34.331658291457288 ,
34.894472361809044 , 35.457286432160807 , 36.020100502512562 ,
36.582914572864318 , 37.145728643216081 , 37.708542713567837 ,
38.2713567839196 , 38.834170854271356 , 39.396984924623112 ,
39.959798994974875 , 40.522613065326631 , 41.085427135678394 ,
41.64824120603015 , 42.211055276381913 , 42.773869346733669 ,
43.336683417085425 , 43.899497487437188 , 44.462311557788944 ,
45.025125628140707 , 45.587939698492463 , 46.150753768844218 ,
46.713567839195981 , 47.276381909547737 , 47.8391959798995 ,
48.402010050251256 , 48.964824120603012 , 49.527638190954775 ,
50.090452261306531 , 50.653266331658294 , 51.21608040201005 ,
51.778894472361806 , 52.341708542713569 , 52.904522613065325 ,
53.467336683417088 , 54.030150753768844 , 54.5929648241206 ,
55.155778894472363 , 55.718592964824118 , 56.281407035175882 ,
56.844221105527637 , 57.4070351758794 , 57.969849246231156 ,
58.532663316582912 , 59.095477386934675 , 59.658291457286431 ,
60.221105527638194 , 60.78391959798995 , 61.346733668341706 ,
61.909547738693469 , 62.472361809045225 , 63.035175879396988 ,
63.597989949748744 , 64.1608040201005 , 64.723618090452263 ,
65.286432160804026 , 65.849246231155774 , 66.412060301507537 ,
66.9748743718593 , 67.537688442211049 , 68.100502512562812 ,
68.663316582914575 , 69.226130653266338 , 69.788944723618087 ,
70.35175879396985 , 70.914572864321613 , 71.477386934673362 ,
72.040201005025125 , 72.603015075376888 , 73.165829145728637 ,
73.7286432160804 , 74.291457286432163 , 74.854271356783926 ,
75.417085427135675 , 75.979899497487438 , 76.5427135678392 ,
77.105527638190949 , 77.668341708542712 , 78.231155778894475 ,
78.793969849246224 , 79.356783919597987 , 79.91959798994975 ,
80.482412060301513 , 81.045226130653262 , 81.608040201005025 ,
82.170854271356788 , 82.733668341708537 , 83.2964824120603 ,
83.859296482412063 , 84.422110552763826 , 84.984924623115575 ,
85.547738693467338 , 86.1105527638191 , 86.673366834170849 ,
87.236180904522612 , 87.798994974874375 , 88.361809045226124 ,
88.924623115577887 , 89.48743718592965 , 90.050251256281413 ,
90.613065326633162 , 91.175879396984925 , 91.738693467336688 ,
92.301507537688437 , 92.8643216080402 , 93.427135678391963 ,
93.989949748743712 , 94.552763819095475 , 95.115577889447238 ,
95.678391959799 , 96.241206030150749 , 96.804020100502512 ,
97.366834170854275 , 97.929648241206024 , 98.492462311557787 ,
99.05527638190955 , 99.618090452261313 , 100.18090452261306 ,
100.74371859296483 , 101.30653266331659 , 101.86934673366834 ,
102.4321608040201 , 102.99497487437186 , 103.55778894472361 ,
104.12060301507537 , 104.68341708542714 , 105.2462311557789 ,
105.80904522613065 , 106.37185929648241 , 106.93467336683418 ,
107.49748743718592 , 108.06030150753769 , 108.62311557788945 ,
109.1859296482412 , 109.74874371859296 , 110.31155778894473 ,
110.87437185929649 , 111.43718592964824 , 112.0 } , 2.0 , - 1.0 , 0.0 , 0.0 ,
1.0 , { 0.0 , 0.56281407035175879 , 1.1256281407035176 , 1.6884422110552764 ,
2.2512562814070352 , 2.8140703517587942 , 3.3768844221105527 ,
3.9396984924623117 , 4.50251256281407 , 5.0653266331658289 ,
5.6281407035175883 , 6.1909547738693469 , 6.7537688442211055 ,
7.316582914572864 , 7.8793969849246235 , 8.4422110552763812 ,
9.00502512562814 , 9.5678391959799 , 10.130653266331658 , 10.693467336683417
, 11.256281407035177 , 11.819095477386934 , 12.381909547738694 ,
12.944723618090451 , 13.507537688442211 , 14.07035175879397 ,
14.633165829145728 , 15.195979899497488 , 15.758793969849247 ,
16.321608040201006 , 16.884422110552762 , 17.447236180904522 ,
18.010050251256281 , 18.572864321608041 , 19.1356783919598 ,
19.698492462311556 , 20.261306532663315 , 20.824120603015075 ,
21.386934673366834 , 21.949748743718594 , 22.512562814070353 ,
23.075376884422109 , 23.638190954773869 , 24.201005025125628 ,
24.763819095477388 , 25.326633165829147 , 25.889447236180903 ,
26.452261306532662 , 27.015075376884422 , 27.577889447236181 ,
28.140703517587941 , 28.7035175879397 , 29.266331658291456 ,
29.829145728643216 , 30.391959798994975 , 30.954773869346734 ,
31.517587939698494 , 32.08040201005025 , 32.643216080402013 ,
33.206030150753769 , 33.768844221105525 , 34.331658291457288 ,
34.894472361809044 , 35.457286432160807 , 36.020100502512562 ,
36.582914572864318 , 37.145728643216081 , 37.708542713567837 ,
38.2713567839196 , 38.834170854271356 , 39.396984924623112 ,
39.959798994974875 , 40.522613065326631 , 41.085427135678394 ,
41.64824120603015 , 42.211055276381913 , 42.773869346733669 ,
43.336683417085425 , 43.899497487437188 , 44.462311557788944 ,
45.025125628140707 , 45.587939698492463 , 46.150753768844218 ,
46.713567839195981 , 47.276381909547737 , 47.8391959798995 ,
48.402010050251256 , 48.964824120603012 , 49.527638190954775 ,
50.090452261306531 , 50.653266331658294 , 51.21608040201005 ,
51.778894472361806 , 52.341708542713569 , 52.904522613065325 ,
53.467336683417088 , 54.030150753768844 , 54.5929648241206 ,
55.155778894472363 , 55.718592964824118 , 56.281407035175882 ,
56.844221105527637 , 57.4070351758794 , 57.969849246231156 ,
58.532663316582912 , 59.095477386934675 , 59.658291457286431 ,
60.221105527638194 , 60.78391959798995 , 61.346733668341706 ,
61.909547738693469 , 62.472361809045225 , 63.035175879396988 ,
63.597989949748744 , 64.1608040201005 , 64.723618090452263 ,
65.286432160804026 , 65.849246231155774 , 66.412060301507537 ,
66.9748743718593 , 67.537688442211049 , 68.100502512562812 ,
68.663316582914575 , 69.226130653266338 , 69.788944723618087 ,
70.35175879396985 , 70.914572864321613 , 71.477386934673362 ,
72.040201005025125 , 72.603015075376888 , 73.165829145728637 ,
73.7286432160804 , 74.291457286432163 , 74.854271356783926 ,
75.417085427135675 , 75.979899497487438 , 76.5427135678392 ,
77.105527638190949 , 77.668341708542712 , 78.231155778894475 ,
78.793969849246224 , 79.356783919597987 , 79.91959798994975 ,
80.482412060301513 , 81.045226130653262 , 81.608040201005025 ,
82.170854271356788 , 82.733668341708537 , 83.2964824120603 ,
83.859296482412063 , 84.422110552763826 , 84.984924623115575 ,
85.547738693467338 , 86.1105527638191 , 86.673366834170849 ,
87.236180904522612 , 87.798994974874375 , 88.361809045226124 ,
88.924623115577887 , 89.48743718592965 , 90.050251256281413 ,
90.613065326633162 , 91.175879396984925 , 91.738693467336688 ,
92.301507537688437 , 92.8643216080402 , 93.427135678391963 ,
93.989949748743712 , 94.552763819095475 , 95.115577889447238 ,
95.678391959799 , 96.241206030150749 , 96.804020100502512 ,
97.366834170854275 , 97.929648241206024 , 98.492462311557787 ,
99.05527638190955 , 99.618090452261313 , 100.18090452261306 ,
100.74371859296483 , 101.30653266331659 , 101.86934673366834 ,
102.4321608040201 , 102.99497487437186 , 103.55778894472361 ,
104.12060301507537 , 104.68341708542714 , 105.2462311557789 ,
105.80904522613065 , 106.37185929648241 , 106.93467336683418 ,
107.49748743718592 , 108.06030150753769 , 108.62311557788945 ,
109.1859296482412 , 109.74874371859296 , 110.31155778894473 ,
110.87437185929649 , 111.43718592964824 , 112.0 } , 2.0 , - 1.0 , 0.0 , 0.0 ,
1.0 , 0.0 , - 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 1.0 , 0.5 , 0.01 ,
- 1.0 , 1.0 , 0.0 , 2.0 , 1.0 , 0.0 , - 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 1.0 ,
0.5 , 0.01 , - 1.0 , 1.0 , 0.0 , 2.0 , INFINITY , 0.0001 , 0.001 , INFINITY ,
0.001 , 0.001 , 25.0 , 0.0 , - 0.1 , 0.1 , 0.0 , 0.0 , 0.0 , 0.001 , { 25.0 ,
25.0 , 100.0 } , { 0.0 , 0.8 , 1.0 } , 0.0 , - INFINITY , INFINITY , 0.0 ,
1.0 , 0.0 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.5 , 1.0 , 1.0 , 0.0 , 2.0 , 0.0 ,
2.0 , 0.0 , - 1.0 , - 1.0 , 0.0 , - 0.5 , 0.25 , 0.0 , { 0.0 , 0.0 , 0.0 ,
0.0 } , 0.5 , 0.5 , { 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
0.0 , 0.0 , 0.0 , 0.0 } , { 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
0.0 , 0.0 , 0.0 } , - 0.5 , 500.0 , - 500.0 , 0.0 , { 0.0 , 0.0 } , 0.0 , 0.0
, 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 1.0 , 1.0 , 2560000000U , { 13U , 10U } , {
13U , 10U } , 200U , 200U , 1U , 1U , 1U } ; static void e4ctbgzcfy ( ci1jcnwvc5
* obj ) ; static void kqfgedufzz ( const real_T xi_seq [ 26 ] , const real_T
x0 [ 2 ] , const real_T PrevEMTrqCmdFinals [ 4 ] , real_T EMFrntTrq , real_T
EMRearTrq , real_T r_ref , real_T J_vec [ 2 ] ) ; static void fs3qapxw1l ( const
real_T xk [ 2 ] , const real_T uk [ 2 ] , real_T EMFrntTrq , real_T Vx ,
real_T delta_Frnt , const real_T Acc [ 3 ] , real_T xk_dot [ 2 ] ) ; static
void evwyhhhxfb ( const real_T xk [ 2 ] , const real_T PrevEMTrqCmdFinals [ 4
] , real_T Vx , real_T delta_Frnt , real_T EMTrqMaxFrnt , real_T EMTrqMaxRear
, const real_T Acc [ 3 ] , real_T EMFrntTrq , real_T EMRearTrq , const real_T
xi_seq [ 26 ] , real_T varargout_1 [ 54 ] , real_T varargout_2 [ 20 ] ) ;
static void in0icnpfc3 ( const real_T
obj_next_next_next_next_next_next_next_b_value_workspace_xk [ 2 ] , const
real_T
obj_next_next_next_next_next_next_next_b_value_workspace_PrevEMTrqCmdFinals [
4 ] , real_T obj_next_next_next_next_next_next_next_b_value_workspace_Vx ,
real_T obj_next_next_next_next_next_next_next_b_value_workspace_delta_Frnt ,
real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxFrnt
, real_T
obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxRear , const
real_T obj_next_next_next_next_next_next_next_b_value_workspace_Acc [ 3 ] ,
real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMFrntTrq ,
real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMRearTrq ,
const n4zzvudoa0 *
obj_next_next_next_next_next_next_next_next_b_value_workspace , const real_T
x [ 26 ] , real_T Cineq_workspace [ 54 ] , real_T Ceq_workspace [ 20 ] ,
real_T * fval , int32_T * status ) ; static void e4ctbgzcfy3 ( const real_T
objfun_workspace_xk [ 2 ] , const real_T objfun_workspace_PrevEMTrqCmdFinals
[ 4 ] , real_T objfun_workspace_EMFrntTrq , real_T objfun_workspace_EMRearTrq
, real_T objfun_workspace_r_ref , const cuxlzjpzbn * nonlin_workspace , const
real_T lb [ 26 ] , const real_T ub [ 26 ] , aoeufdu2eg * obj ) ; static
boolean_T dk3cfa35ia ( const real_T obj_objfun_workspace_xk [ 2 ] , const
real_T obj_objfun_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T
obj_objfun_workspace_EMFrntTrq , real_T obj_objfun_workspace_EMRearTrq ,
real_T obj_objfun_workspace_r_ref , const real_T obj_nonlin_workspace_xk [ 2
] , const real_T obj_nonlin_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T
obj_nonlin_workspace_Vx , real_T obj_nonlin_workspace_delta_Frnt , real_T
obj_nonlin_workspace_EMTrqMaxFrnt , real_T obj_nonlin_workspace_EMTrqMaxRear
, const real_T obj_nonlin_workspace_Acc [ 3 ] , real_T
obj_nonlin_workspace_EMFrntTrq , real_T obj_nonlin_workspace_EMRearTrq ,
real_T * fplus , real_T cIneqPlus [ 54 ] , real_T cEqPlus [ 20 ] , int32_T
dim , real_T delta , real_T xk [ 26 ] ) ; static boolean_T bvp0ue5q2p ( aoeufdu2eg * obj , real_T fCurrent , const real_T cIneqCurrent [ 54 ] , const real_T cEqCurrent [ 20 ] , real_T xk [ 26 ] , real_T gradf [ 121 ] , real_T JacCineqTrans [ 6534 ] , real_T JacCeqTrans [ 2420 ] , const real_T lb [ 26 ] , const real_T ub [ 26 ] ) ; static void hqukg0j2js ( const real_T xk [ 26 ] , c3tcu1vsoj * WorkingSet , const real_T cIneq [ 54 ] , const real_T cEq [ 20 ] , int32_T mLB , const real_T lb [ 26 ] , int32_T mUB , const real_T ub [ 26 ] , int32_T mFixed ) ; static void jvmklsxrqg ( c3tcu1vsoj * obj ) ; static void i3lcleconb ( c3tcu1vsoj * obj , int32_T PROBLEM_TYPE ) ; static void ai0qsnj2tx ( c3tcu1vsoj * obj ) ; static void e4ctbgzcfy3j ( oytx5zapfu * obj ) ; static real_T iqfbbuti1d ( const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , const real_T x [ 26 ] , const real_T cIneq [ 54 ] , const real_T cEq [ 20 ] , const int32_T finiteLB [ 121 ] , int32_T mLB , const real_T lb [ 26 ] , const int32_T finiteUB [ 121 ] , int32_T mUB , const real_T ub [ 26 ] ) ; static void fw12bnjdbo ( real_T fscales_objective , int32_T nVar , const real_T gradLag [ 121 ] , boolean_T * gradOK , real_T * val ) ; static real_T efjv1gsbna ( real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T xCurrent [ 26 ] , const real_T cIneq [ 54 ] , const int32_T finiteLB [ 121 ] , int32_T mLB , const real_T lb [ 26 ] , const int32_T finiteUB [ 121 ] , int32_T mUB , const real_T ub [ 26 ] , const real_T lambda [ 221 ] , int32_T iL0 ) ; static void crspy0yej2 ( bhtu1h5bl5 * MeritFunction , real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , const c3tcu1vsoj * WorkingSet , ci1jcnwvc5 * TrialState , const real_T lb [ 26 ] , const real_T ub [ 26 ] , boolean_T * Flags_gradOK , boolean_T * Flags_fevalOK , boolean_T * Flags_done , boolean_T * Flags_stepAccepted , boolean_T * Flags_failedLineSearch , int32_T * Flags_stepType ) ; static void lmxrtyn3ij ( ci1jcnwvc5 * obj , int32_T nVar , const real_T JacCineqTrans [ 6534 ] , const real_T JacCeqTrans [ 2420 ] ) ; static void hqukg0j2jsd ( const real_T xk [ 26 ] , c3tcu1vsoj * WorkingSet , const real_T cIneq [ 54 ] , const real_T cEq [ 20 ] , int32_T mLB , const real_T lb [ 26 ] , int32_T mUB , const real_T ub [ 26 ] , int32_T mFixed ) ; static real_T bjypmi3wva ( c3tcu1vsoj * obj , const real_T x [ 121 ] ) ; static real_T kkqgbfnbrg ( c3tcu1vsoj * obj , const real_T x [ 121 ] ) ; static real_T p3kkfowucmzwk ( c3tcu1vsoj * obj , const real_T x [ 121 ] ) ; static void gnvee1hvpj ( iamwnmrrfd * obj , const real_T H [ 676 ] , const real_T f [ 121 ] , const real_T x [ 121 ] ) ; static real_T ha4rdqgm4g ( const iamwnmrrfd * obj , real_T workspace [ 26741 ] , const real_T f [ 121 ] , const real_T x [ 121 ] ) ; static void b453z2zntr ( oytx5zapfu * obj , const real_T A [ 26741 ] , int32_T mrows , int32_T ncols ) ; static void lf2exsz2ex ( oytx5zapfu * obj , const real_T vec [ 26741 ] , int32_T iv0 ) ; static void cilnv2vgqh ( oytx5zapfu * obj , int32_T idx ) ; static void d2y4tsvypc ( oytx5zapfu * obj , int32_T nrows ) ; static boolean_T k1a0kvuk51 ( const char_T a [ 7 ] ) ; static void nl2ovhgzvl ( kzv4ftj4e2 * obj , int32_T LD_offset , int32_T NColsRemain ) ; static void bgcgohintf ( kzv4ftj4e2 * obj , int32_T LD_offset , int32_T NColsRemain ) ; static void a554y4lhjz0 ( kzv4ftj4e2 * obj , const real_T A [ 676 ] , int32_T ndims , int32_T ldA ) ; static void a554y4lhjz ( kzv4ftj4e2 * obj , const real_T A [ 676 ] , int32_T ndims , int32_T ldA ) ; static void l5vh2m5twz ( const kzv4ftj4e2 * obj , real_T rhs [ 121 ] ) ; static void l5vh2m5twza ( const kzv4ftj4e2 * obj , real_T rhs [ 121 ] ) ; static void fhnd1v2j0m ( const real_T H [ 676 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , const oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , const iamwnmrrfd * objective , boolean_T alwaysPositiveDef ) ; static void diz55ngdn0 ( const real_T solution_xstar [ 121 ] , const real_T solution_searchDir [ 121 ] , real_T workspace [ 26741 ] , int32_T workingset_nVar , const real_T workingset_Aineq [ 6534 ] , const real_T workingset_bineq [ 54 ] , const real_T workingset_lb [ 121 ] , const real_T workingset_ub [ 121 ] , const int32_T workingset_indexLB [ 121 ] , const int32_T workingset_indexUB [ 121 ] , const int32_T workingset_sizes [ 5 ] , const int32_T workingset_isActiveIdx [ 6 ] , const boolean_T workingset_isActiveConstr [ 221 ] , const int32_T workingset_nWConstr [ 5 ] , boolean_T isPhaseOne , real_T * alpha , boolean_T * newBlocking , int32_T * constrType , int32_T * constrIdx ) ; static void gg30krxp5f ( real_T workspace [ 26741 ] , ci1jcnwvc5 * solution , const iamwnmrrfd * objective , const oytx5zapfu * qrmanager ) ; static void fw3u2letrf ( ci1jcnwvc5 * solution , const iamwnmrrfd * objective ) ; static void dywa1naf0c ( c3tcu1vsoj * obj , int32_T TYPE , int32_T idx_local ) ; static void p22oac0uqf ( c3tcu1vsoj * obj , int32_T idx_local ) ; static void ozc3jikxh0 ( c3tcu1vsoj * obj , int32_T idx_global ) ; static void ijxevqoovk ( oytx5zapfu * obj , const real_T A [ 26741 ] , int32_T mrows , int32_T ncols ) ; static int32_T iri1hxo114 ( const real_T qrmanager_QR [ 48841 ] , int32_T qrmanager_mrows , int32_T qrmanager_ncols ) ; static real_T p3kkfowucmz ( c3tcu1vsoj * obj , const real_T x [ 26741 ] ) ; static real_T p3kkfowucmzw ( c3tcu1vsoj * obj , const real_T x [ 26741 ] ) ; static boolean_T dsoxlnhlbq ( real_T workspace [ 26741 ] , real_T xCurrent [ 121 ] , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , d4m2qnxaxx * localB ) ; static void jzdsxapqec ( int32_T * activeSetChangeID , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , const iamwnmrrfd * objective , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , int32_T runTimeOptions_MaxIterations , const boolean_T * updateFval , d4m2qnxaxx * localB ) ; static void acuz0bhfbi ( const real_T H [ 676 ] , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , iamwnmrrfd * objective , const char_T options_SolverName [ 7 ] , int32_T runTimeOptions_MaxIterations , d4m2qnxaxx * localB ) ; static void hwriukhbq4 ( const real_T H [ 676 ] , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , iamwnmrrfd * objective , const char_T options_SolverName [ 7 ] , const i4h2yyndkb * runTimeOptions , d4m2qnxaxx * localB ) ; static void jzdsxapqeco ( int32_T * activeSetChangeID , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , const iamwnmrrfd * objective , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , int32_T runTimeOptions_MaxIterations , boolean_T * updateFval , d4m2qnxaxx * localB ) ; static void acuz0bhfbih ( const real_T H [ 676 ] , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , iamwnmrrfd * objective , const char_T options_SolverName [ 7 ] , int32_T runTimeOptions_MaxIterations , d4m2qnxaxx * localB ) ; static int32_T dd3g4xxgaf ( oytx5zapfu * qrmanager , const real_T beqf [ 221 ] , int32_T mConstr , int32_T nVar ) ; static void k2kcdu0qax ( int32_T depIdx [ 221 ] , int32_T mFixed , int32_T nDep , oytx5zapfu * qrmanager , int32_T mRows , int32_T nCols ) ; static int32_T o0tv2kc1z5 ( kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager ) ; static void ijvdhcksfr ( c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kmbpuy2anc * memspace , real_T tolfactor ) ; static void glmbbxgvqt ( ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , d4m2qnxaxx * localB ) ; static void o5obldhs3v ( boolean_T obj_hasLinear , int32_T obj_nvar , real_T workspace [ 26741 ] , const real_T H [ 676 ] , const real_T f [ 121 ] , const real_T x [ 121 ] ) ; static void ckrin4u0eh1 ( const real_T H [ 676 ] , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , iamwnmrrfd * objective , const i4h2yyndkb * options , const i4h2yyndkb * runTimeOptions , d4m2qnxaxx * localB ) ; static void dudfwmvulx ( c3tcu1vsoj * obj , int32_T idx_local ) ; static void myxjrkt4iq ( real_T lambda [ 221 ] , int32_T WorkingSet_nActiveConstr , const int32_T WorkingSet_sizes [ 5 ] , const int32_T WorkingSet_isActiveIdx [ 6 ] , const int32_T WorkingSet_Wid [ 221 ] , const int32_T WorkingSet_Wlocalidx [ 221 ] , real_T workspace [ 26741 ] ) ; static boolean_T l1cacwyidk ( const real_T Hessian [ 676 ] , const real_T grad [ 121 ] , ci1jcnwvc5 * TrialState , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , kzv4ftj4e2 * CholManager , iamwnmrrfd * QPObjective , const i4h2yyndkb * qpoptions , d4m2qnxaxx * localB ) ; static real_T p3kkfowucm ( const c3tcu1vsoj * obj , const real_T x [ 121 ] , d4m2qnxaxx * localB ) ; static void okx5oukmjm ( const real_T Hessian [ 676 ] , const real_T grad [ 121 ] , ci1jcnwvc5 * TrialState , bhtu1h5bl5 * MeritFunction , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , kzv4ftj4e2 * CholManager , iamwnmrrfd * QPObjective , const i4h2yyndkb * qpoptions , drf2ph4ldh * stepFlags , d4m2qnxaxx * localB ) ; static void g2ye2po1ca ( const real_T Hessian [ 676 ] , const real_T grad [ 121 ] , ci1jcnwvc5 * TrialState , bhtu1h5bl5 * MeritFunction , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , kzv4ftj4e2 * CholManager , iamwnmrrfd * QPObjective , i4h2yyndkb * qpoptions , d4m2qnxaxx * localB ) ; static void bkzwtwyp4q ( drf2ph4ldh * stepFlags , real_T Hessian [ 676 ] , const real_T lb [ 26 ] , const real_T ub [ 26 ] , ci1jcnwvc5 * TrialState , bhtu1h5bl5 * MeritFunction , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , kzv4ftj4e2 * CholManager , iamwnmrrfd * QPObjective , i4h2yyndkb * qpoptions , d4m2qnxaxx * localB ) ; static void fw12bnjdboi ( real_T fscales_objective , int32_T nVar , const real_T gradLag [ 26741 ] , boolean_T * gradOK , real_T * val ) ; static void crspy0yej2a ( drf2ph4ldh * Flags , kmbpuy2anc * memspace , bhtu1h5bl5 * MeritFunction , real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , c3tcu1vsoj * WorkingSet , ci1jcnwvc5 * TrialState , oytx5zapfu * QRManager , const real_T lb [ 26 ] , const real_T ub [ 26 ] ) ; static void im2vn5wy2c ( const real_T obj_next_next_next_next_next_next_next_b_value_workspace_xk [ 2 ] , const real_T obj_next_next_next_next_next_next_next_b_value_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T obj_next_next_next_next_next_next_next_b_value_workspace_Vx , real_T obj_next_next_next_next_next_next_next_b_value_workspace_delta_Frnt , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxFrnt , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxRear , const real_T obj_next_next_next_next_next_next_next_b_value_workspace_Acc [ 3 ] , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMFrntTrq , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMRearTrq , const n4zzvudoa0 * obj_next_next_next_next_next_next_next_next_b_value_workspace , const real_T x [ 26 ] , real_T Cineq_workspace [ 54 ] , real_T Ceq_workspace [ 20 ] , real_T scales_objective , const real_T scales_cineq_constraint [ 54 ] , const real_T scales_ceq_constraint [ 20 ] , real_T * fval , int32_T * status ) ; static real_T a1oi5z04nx ( real_T obj_penaltyParam , real_T fval , const real_T Cineq_workspace [ 54 ] , const real_T Ceq_workspace [ 20 ] , boolean_T evalWellDefined ) ; static void a43nr5o2hf ( boolean_T * evalWellDefined , int32_T WorkingSet_nVar , ci1jcnwvc5 * TrialState , real_T MeritFunction_penaltyParam , real_T MeritFunction_phi , real_T MeritFunction_phiPrimePlus , real_T MeritFunction_phiFullStep , const real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_xk [ 2 ] , const real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_Vx , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_delta_Frnt , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxFrnt , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxRear , const real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_Acc [ 3 ] , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMFrntTrq , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMRearTrq , const ptup5lzvsv * FcnEvaluator_next_next_next_next_next_next_next_next_b_value , boolean_T socTaken , real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , real_T * alpha , int32_T * exitflag ) ; static boolean_T dk3cfa35iak ( const real_T obj_objfun_workspace_xk [ 2 ] , const real_T obj_objfun_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T obj_objfun_workspace_EMFrntTrq , real_T obj_objfun_workspace_EMRearTrq , real_T obj_objfun_workspace_r_ref , const real_T obj_nonlin_workspace_xk [ 2 ] , const real_T obj_nonlin_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T obj_nonlin_workspace_Vx , real_T obj_nonlin_workspace_delta_Frnt , real_T obj_nonlin_workspace_EMTrqMaxFrnt , real_T obj_nonlin_workspace_EMTrqMaxRear , const real_T obj_nonlin_workspace_Acc [ 3 ] , real_T obj_nonlin_workspace_EMFrntTrq , real_T obj_nonlin_workspace_EMRearTrq , real_T * fplus , real_T cIneqPlus [ 54 ] , real_T cEqPlus [ 20 ] , int32_T dim , real_T delta , real_T xk [ 26 ] , real_T scales_objective , const real_T scales_cineq_constraint [ 54 ] , const real_T scales_ceq_constraint [ 20 ] ) ; static boolean_T bvp0ue5q2pa ( aoeufdu2eg * obj , real_T fCurrent , const real_T cIneqCurrent [ 54 ] , const real_T cEqCurrent [ 20 ] , real_T xk [ 26 ] , real_T gradf [ 121 ] , real_T JacCineqTrans [ 6534 ] , real_T JacCeqTrans [ 2420 ] , const real_T lb [ 26 ] , const real_T ub [ 26 ] , const ofxtwsq03r * scales ) ; static void ckrin4u0eh ( const real_T lb [ 26 ] , const real_T ub [ 26 ] , ci1jcnwvc5 * TrialState , bhtu1h5bl5 * MeritFunction , const nged4bnpig * FcnEvaluator , aoeufdu2eg * FiniteDifferences , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , iamwnmrrfd * QPObjective , real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , real_T Hessian [ 676 ] , kzv4ftj4e2 * CholManager , d4m2qnxaxx * localB ) ; static void e0ysvsme4f ( const real_T fun_workspace_xk [ 2 ] , const real_T fun_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T fun_workspace_EMFrntTrq , real_T fun_workspace_EMRearTrq , real_T fun_workspace_r_ref , real_T x0 [ 26 ] , const real_T lb [ 26 ] , const real_T ub [ 26 ] , const cuxlzjpzbn * nonlcon_workspace , real_T * fval , real_T * exitflag , real_T * output_iterations , real_T * output_funcCount , char_T output_algorithm [ 3 ] , real_T * output_constrviolation , real_T * output_stepsize , real_T * output_lssteplength , real_T * output_firstorderopt , d4m2qnxaxx * localB ) ; static void e4ctbgzcfy ( ci1jcnwvc5 * obj ) { int32_T i ; obj -> nVarMax = 121 ; obj -> mNonlinIneq = 54 ; obj -> mNonlinEq = 20 ; obj -> mIneq = 54 ; obj -> mEq = 20 ; obj -> iNonIneq0 = 1 ; obj -> iNonEq0 = 1 ; obj -> sqpFval = 0.0 ; obj -> sqpFval_old = 0.0 ; obj -> FunctionEvaluations = 0 ; obj -> sqpIterations = 0 ; obj -> sqpExitFlag = 0 ; for ( i = 0 ; i < 221 ; i ++ ) { obj -> lambdasqp [ i ] = 0.0 ; } obj -> steplength = 1.0 ; for ( i = 0 ; i < 121 ; i ++ ) { obj -> delta_x [ i ] = 0.0 ; } obj -> fstar = 0.0 ; obj -> firstorderopt = 0.0 ; for ( i = 0 ; i < 221 ; i ++ ) { obj -> lambda [ i ] = 0.0 ; } obj -> state = 0 ; obj -> maxConstr = 0.0 ; obj -> iterations = 0 ; } static void kqfgedufzz ( const real_T xi_seq [ 26 ] , const real_T x0 [ 2 ] , const real_T PrevEMTrqCmdFinals [ 4 ] , real_T EMFrntTrq , real_T EMRearTrq , real_T r_ref , real_T J_vec [ 2 ] ) { __m128d tmp ; __m128d tmp_p ; real_T xi_seq_c [ 6 ] ; real_T xi_seq_e [ 6 ] ; real_T xi_seq_f [ 6 ] ; real_T xi_seq_g [ 6 ] ; real_T xi_seq_i [ 6 ] ; real_T xi_seq_j [ 6 ] ; real_T xi_seq_m [ 6 ] ; real_T xi_seq_p [ 6 ] ; real_T TrqInc [ 4 ] ; real_T J_du ; real_T J_y ; real_T TrqInc_p ; int32_T TrqInc_tmp ; int32_T i ; int32_T k ; int8_T J_du_tmp [ 16 ] ; static const int8_T y [ 16 ] = { 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 } ; J_y = x0 [ 1 ] - r_ref ; J_y = J_y * J_y * 700.0 ; for ( k = 0 ; k < 9 ; k ++ ) { J_du = xi_seq [ ( k << 1 ) + 7 ] - r_ref ; J_y += J_du * J_du * 700.0 ; } for ( i = 0 ; i < 6 ; i ++ ) { xi_seq_p [ i ] = xi_seq [ i ] ; xi_seq_e [ i ] = xi_seq [ i ] ; xi_seq_i [ i ] = xi_seq [ i ] ; xi_seq_m [ i ] = xi_seq [ i ] ; } tmp = _mm_set_pd ( 1.0 , - 1.0 ) ; tmp_p = _mm_set1_pd ( 0.5 ) ; _mm_storeu_pd ( & TrqInc [ 0 ] , _mm_sub_pd ( _mm_mul_pd ( _mm_add_pd ( _mm_set1_pd ( EMFrntTrq ) , _mm_mul_pd ( _mm_set_pd ( xi_seq_e [ 0 ] , xi_seq_p [ 0 ] ) , tmp ) ) , tmp_p ) , _mm_loadu_pd ( & PrevEMTrqCmdFinals [ 0 ] ) ) ) ; _mm_storeu_pd ( & TrqInc [ 2 ] , _mm_sub_pd ( _mm_mul_pd ( _mm_add_pd ( _mm_set1_pd ( EMRearTrq ) , _mm_mul_pd ( _mm_set_pd ( xi_seq_m [ 1 ] , xi_seq_i [ 1 ] ) , tmp ) ) , tmp_p ) , _mm_loadu_pd ( & PrevEMTrqCmdFinals [ 2 ] ) ) ) ; for ( i = 0 ; i < 16 ; i ++ ) { J_du_tmp [ i ] = y [ i ] ; } J_du = 0.0 ; for ( i = 0 ; i < 4 ; i ++ ) { TrqInc_tmp = i << 2 ; J_du += ( ( ( ( real_T ) J_du_tmp [ TrqInc_tmp + 1 ] * TrqInc [ 1 ] + ( real_T ) J_du_tmp [ TrqInc_tmp ] * TrqInc [ 0 ] ) + ( real_T ) J_du_tmp [ TrqInc_tmp + 2 ] * TrqInc [ 2 ] ) + ( real_T ) J_du_tmp [ TrqInc_tmp + 3 ] * TrqInc [ 3 ] ) * TrqInc [ i ] ; } for ( i = 0 ; i < 6 ; i ++ ) { xi_seq_p [ i ] = xi_seq [ i ] ; xi_seq_e [ i ] = xi_seq [ i ] ; xi_seq_i [ i ] = xi_seq [ i ] ; xi_seq_m [ i ] = xi_seq [ i ] ; xi_seq_g [ i ] = xi_seq [ i ] ; xi_seq_j [ i ] = xi_seq [ i ] ; xi_seq_f [ i ] = xi_seq [ i ] ; xi_seq_c [ i ] = xi_seq [ i ] ; } for ( k = 0 ; k < 2 ; k ++ ) { i = ( k + 1 ) << 1 ; TrqInc_tmp = k << 1 ; _mm_storeu_pd ( & TrqInc [ 0 ] , _mm_sub_pd ( _mm_mul_pd ( _mm_add_pd ( _mm_set_pd ( xi_seq_e [ i ] , EMFrntTrq ) , _mm_mul_pd ( _mm_set_pd ( EMFrntTrq , xi_seq_p [ i ] ) , tmp ) ) , tmp_p ) , _mm_mul_pd ( _mm_add_pd ( _mm_set_pd ( xi_seq_j [ TrqInc_tmp ] , EMFrntTrq ) , _mm_mul_pd ( _mm_set_pd ( EMFrntTrq , xi_seq_g [ TrqInc_tmp ] ) , tmp ) ) , tmp_p ) ) ) ; _mm_storeu_pd ( & TrqInc [ 2 ] , _mm_sub_pd ( _mm_mul_pd ( _mm_add_pd ( _mm_set_pd ( xi_seq_m [ i + 1 ] , EMRearTrq ) , _mm_mul_pd ( _mm_set_pd ( EMRearTrq , xi_seq_i [ i + 1 ] ) , tmp ) ) , tmp_p ) , _mm_mul_pd ( _mm_add_pd ( _mm_set_pd ( xi_seq_c [ TrqInc_tmp + 1 ] , EMRearTrq ) , _mm_mul_pd ( _mm_set_pd ( EMRearTrq , xi_seq_f [ TrqInc_tmp + 1 ] ) , tmp ) ) , tmp_p ) ) ) ; TrqInc_p = 0.0 ; for ( i = 0 ; i < 4 ; i ++ ) { TrqInc_tmp = i << 2 ; TrqInc_p += ( ( ( ( real_T ) J_du_tmp [ TrqInc_tmp + 1 ] * TrqInc [ 1 ] + ( real_T ) J_du_tmp [ TrqInc_tmp ] * TrqInc [ 0 ] ) + ( real_T ) J_du_tmp [ TrqInc_tmp + 2 ] * TrqInc [ 2 ] ) + ( real_T ) J_du_tmp [ TrqInc_tmp + 3 ] * TrqInc [ 3 ] ) * TrqInc [ i ] ; } J_du += TrqInc_p ; } J_vec [ 0 ] = J_y ; J_vec [ 1 ] = J_du ; } static void fs3qapxw1l ( const real_T xk [ 2 ] , const real_T uk [ 2 ] , real_T EMFrntTrq , real_T Vx , real_T delta_Frnt , const real_T Acc [ 3 ] , real_T xk_dot [ 2 ] ) { __m128d tmp_e ; __m128d tmp_g ; __m128d tmp_i ; __m128d tmp_m ; __m128d tmp_p ; real_T tmp [ 2 ] ; real_T Fy_idx_0_tmp ; real_T Fy_idx_1 ; real_T Fz_FL ; real_T Fz_FR ; real_T Fz_RL ; real_T Fz_RR ; real_T a_RL_tmp ; real_T tmp_j ; real_T xk_dot_tmp ; tmp_p = _mm_set1_pd ( 1623.0 ) ; tmp_e = _mm_set1_pd ( 0.609 ) ; tmp_i = _mm_div_pd ( _mm_mul_pd ( _mm_mul_pd ( tmp_p , _mm_set1_pd ( Acc [ 0 ] ) ) , tmp_e ) , _mm_set1_pd ( 2.79 ) ) ; tmp_p = _mm_mul_pd ( _mm_mul_pd ( tmp_p , _mm_set1_pd ( - Acc [ 1 ] ) ) , tmp_e ) ; tmp_e = _mm_set1_pd ( 4.3942499999999995 ) ; tmp_m = _mm_set_pd ( 1.0 , - 1.0 ) ; tmp_g = _mm_set1_pd ( 0.5 ) ; _mm_storeu_pd ( & tmp [ 0 ] , _mm_mul_pd ( _mm_add_pd ( _mm_sub_pd ( _mm_set1_pd ( 9701.351612903225 ) , tmp_i ) , _mm_mul_pd ( _mm_div_pd ( _mm_mul_pd ( tmp_p , _mm_set1_pd ( 1.7 ) ) , tmp_e ) , tmp_m ) ) , tmp_g ) ) ; Fz_FL = tmp [ 0 ] ; Fz_FR = tmp [ 1 ] ; _mm_storeu_pd ( & tmp [ 0 ] , _mm_mul_pd ( _mm_add_pd ( _mm_add_pd ( tmp_i , _mm_set1_pd ( 6220.2783870967751 ) ) , _mm_mul_pd ( _mm_div_pd ( _mm_mul_pd ( tmp_p , _mm_set1_pd ( 1.09 ) ) , tmp_e ) , tmp_m ) ) , tmp_g ) ) ; Fz_RL = tmp [ 0 ] ; Fz_RR = tmp [ 1 ] ; Fy_idx_0_tmp = xk [ 1 ] * 1.09 + xk [ 0 ] ; xk_dot_tmp = xk [ 1 ] * 1.575 / 2.0 ; tmp_j = Vx - xk_dot_tmp ; xk_dot_tmp += Vx ; _mm_storeu_pd ( & tmp [ 0 ] , _mm_add_pd ( _mm_set_pd ( - muDoubleScalarAtan2 ( Fy_idx_0_tmp , xk_dot_tmp ) , - muDoubleScalarAtan2 ( Fy_idx_0_tmp , tmp_j ) ) , _mm_set1_pd ( delta_Frnt ) ) ) ; a_RL_tmp = xk [ 0 ] - xk [ 1 ] * 1.7 ; Fy_idx_0_tmp = 40000.0 / ( 0.72000000000000008 * Fz_FL ) * tmp [ 0 ] ; Fy_idx_0_tmp = muDoubleScalarSin ( muDoubleScalarAtan ( Fy_idx_0_tmp - ( Fy_idx_0_tmp - muDoubleScalarAtan ( Fy_idx_0_tmp ) ) * 1.2 ) * 1.1 ) * ( 0.72000000000000008 * Fz_FL ) ; Fz_FL = 40000.0 / ( 0.72000000000000008 * Fz_FR ) * tmp [ 1 ] ; Fy_idx_1 = muDoubleScalarSin ( muDoubleScalarAtan ( Fz_FL - ( Fz_FL - muDoubleScalarAtan ( Fz_FL ) ) * 1.2 ) * 1.1 ) * ( 0.72000000000000008 * Fz_FR ) ; Fz_FR = 40000.0 / ( 0.72000000000000008 * Fz_RL ) * - muDoubleScalarAtan2 ( a_RL_tmp , tmp_j ) ; Fz_RL = muDoubleScalarSin ( muDoubleScalarAtan ( Fz_FR - ( Fz_FR - muDoubleScalarAtan ( Fz_FR ) ) * 1.2 ) * 1.1 ) * ( 0.72000000000000008 * Fz_RL ) ; Fz_FR = 40000.0 / ( 0.72000000000000008 * Fz_RR ) * - muDoubleScalarAtan2 ( a_RL_tmp , xk_dot_tmp ) ; Fz_RR = muDoubleScalarSin ( muDoubleScalarAtan ( Fz_FR - ( Fz_FR - muDoubleScalarAtan ( Fz_FR ) ) * 1.2 ) * 1.1 ) * ( 0.72000000000000008 * Fz_RR ) ; Fz_FL = muDoubleScalarSin ( delta_Frnt ) ; Fz_FR = muDoubleScalarCos ( delta_Frnt ) ; xk_dot_tmp = EMFrntTrq * 4.018 / 0.309 * Fz_FL + ( Fy_idx_0_tmp + Fy_idx_1 ) * Fz_FR ; xk_dot [ 0 ] = ( ( xk_dot_tmp + Fz_RL ) + Fz_RR ) / 1623.0 - Vx * xk [ 1 ] ; xk_dot [ 1 ] = ( ( ( ( uk [ 0 ] * 4.018 / 0.309 * Fz_FR + ( Fy_idx_0_tmp - Fy_idx_1 ) * Fz_FL ) * 1.575 / 2.0 + xk_dot_tmp * 1.09 ) + uk [ 1 ] * 4.018 / 0.309 * 1.575 / 2.0 ) - ( Fz_RL + Fz_RR ) * 1.7 ) / 2066.0 ; } static void evwyhhhxfb ( const real_T xk [ 2 ] , const real_T PrevEMTrqCmdFinals [ 4 ] , real_T Vx , real_T delta_Frnt , real_T EMTrqMaxFrnt , real_T EMTrqMaxRear , const real_T Acc [ 3 ] , real_T EMFrntTrq , real_T EMRearTrq , const real_T xi_seq [ 26 ] , real_T varargout_1 [ 54 ] , real_T varargout_2 [ 20 ] ) { __m128d tmp_e ; __m128d tmp_i ; __m128d tmp_m ; __m128d tmp_p ; real_T c_ineq_EMTrqIncMax [ 24 ] ; real_T c_ineq_EMTrqsMax [ 24 ] ; real_T x_seq [ 20 ] ; real_T xi_seq_e [ 20 ] ; real_T xi_seq_p [ 20 ] ; real_T EMTrqInc_seq [ 12 ] ; real_T EMTrqs_seq [ 12 ] ; real_T b_y1 [ 8 ] ; real_T u_seq [ 6 ] ; real_T k1 [ 2 ] ; real_T tmp [ 2 ] ; real_T xk_p [ 2 ] ; real_T EMTrqs_seq_e ; real_T EMTrqs_seq_p ; int32_T iy ; int32_T k1_tmp ; int32_T s ; for ( k1_tmp = 0 ; k1_tmp < 6 ; k1_tmp ++ ) { u_seq [ k1_tmp ] = xi_seq [ k1_tmp ] ; } memcpy ( & x_seq [ 0 ] , & xi_seq [ 6 ] , 20U * sizeof ( real_T ) ) ; tmp_p = _mm_set_pd ( 1.0 , - 1.0 ) ; tmp_e = _mm_set1_pd ( 0.5 ) ; tmp_i = _mm_set1_pd ( EMFrntTrq ) ; _mm_storeu_pd ( & EMTrqs_seq [ 0 ] , _mm_mul_pd ( _mm_add_pd ( tmp_i , _mm_mul_pd ( _mm_set1_pd ( u_seq [ 0 ] ) , tmp_p ) ) , tmp_e ) ) ; tmp_m = _mm_set1_pd ( EMRearTrq ) ; _mm_storeu_pd ( & EMTrqs_seq [ 2 ] , _mm_mul_pd ( _mm_add_pd ( tmp_m , _mm_mul_pd ( _mm_set1_pd ( u_seq [ 1 ] ) , tmp_p ) ) , tmp_e ) ) ; _mm_storeu_pd ( & EMTrqs_seq [ 4 ] , _mm_mul_pd ( _mm_add_pd ( tmp_i , _mm_mul_pd ( _mm_set1_pd ( u_seq [ 2 ] ) , tmp_p ) ) , tmp_e ) ) ; _mm_storeu_pd ( & EMTrqs_seq [ 6 ] , _mm_mul_pd ( _mm_add_pd ( tmp_m , _mm_mul_pd ( _mm_set1_pd ( u_seq [ 3 ] ) , tmp_p ) ) , tmp_e ) ) ; _mm_storeu_pd ( & EMTrqs_seq [ 8 ] , _mm_mul_pd ( _mm_add_pd ( tmp_i , _mm_mul_pd ( _mm_set1_pd ( u_seq [ 4 ] ) , tmp_p ) ) , tmp_e ) ) ; _mm_storeu_pd ( & EMTrqs_seq [ 10 ] , _mm_mul_pd ( _mm_add_pd ( tmp_m , _mm_mul_pd ( _mm_set1_pd ( u_seq [ 5 ] ) , tmp_p ) ) , tmp_e ) ) ; iy = 0 ; for ( s = 0 ; s < 4 ; s ++ ) { EMTrqs_seq_p = EMTrqs_seq [ s + 4 ] ; EMTrqs_seq_e = EMTrqs_seq [ s ] ; b_y1 [ iy ] = EMTrqs_seq_p - EMTrqs_seq_e ; b_y1 [ iy + 4 ] = EMTrqs_seq [ s + 8 ] - EMTrqs_seq_p ; iy ++ ; EMTrqInc_seq [ s ] = EMTrqs_seq_e - PrevEMTrqCmdFinals [ s ] ; } for ( k1_tmp = 0 ; k1_tmp < 2 ; k1_tmp ++ ) { s = k1_tmp << 2 ; iy = ( k1_tmp + 1 ) << 2 ; EMTrqInc_seq [ iy ] = b_y1 [ s ] ; EMTrqInc_seq [ iy + 1 ] = b_y1 [ s + 1 ] ; EMTrqInc_seq [ iy + 2 ] = b_y1 [ s + 2 ] ; EMTrqInc_seq [ iy + 3 ] = b_y1 [ s + 3 ] ; } fs3qapxw1l ( xk , & xi_seq [ 0 ] , EMFrntTrq , Vx , delta_Frnt , Acc , k1 ) ; memcpy ( & xi_seq_p [ 0 ] , & xi_seq [ 6 ] , 20U * sizeof ( real_T ) ) ; tmp_p = _mm_set1_pd ( 0.01 ) ; tmp_i = _mm_loadu_pd ( & xk [ 0 ] ) ; tmp_e = _mm_add_pd ( _mm_mul_pd ( tmp_p , _mm_loadu_pd ( & k1 [ 0 ] ) ) , tmp_i ) ; _mm_storeu_pd ( & xk_p [ 0 ] , tmp_e ) ; fs3qapxw1l ( xk_p , & xi_seq [ 0 ] , EMFrntTrq , Vx , delta_Frnt , Acc , tmp ) ; tmp_e = _mm_set1_pd ( 2.0 ) ; tmp_i = _mm_sub_pd ( _mm_loadu_pd ( & xi_seq_p [ 0 ] ) , _mm_add_pd ( _mm_div_pd ( _mm_mul_pd ( _mm_add_pd ( _mm_loadu_pd ( & k1 [ 0 ] ) , _mm_loadu_pd ( & tmp [ 0 ] ) ) , tmp_p ) , tmp_e ) , tmp_i ) ) ; _mm_storeu_pd ( & varargout_2 [ 0 ] , tmp_i ) ; for ( k1_tmp = 0 ; k1_tmp < 20 ; k1_tmp ++ ) { EMTrqs_seq_p = xi_seq [ k1_tmp + 6 ] ; xi_seq_p [ k1_tmp ] = EMTrqs_seq_p ; xi_seq_e [ k1_tmp ] = EMTrqs_seq_p ; } for ( iy = 0 ; iy < 2 ; iy ++ ) { s = iy << 1 ; k1_tmp = ( iy + 1 ) << 1 ; fs3qapxw1l ( & xi_seq [ s + 6 ] , & xi_seq [ k1_tmp ] , EMFrntTrq , Vx , delta_Frnt , Acc , k1 ) ; tmp_i = _mm_add_pd ( _mm_loadu_pd ( & x_seq [ s ] ) , _mm_mul_pd ( tmp_p , _mm_loadu_pd ( & k1 [ 0 ] ) ) ) ; _mm_storeu_pd ( & xk_p [ 0 ] , tmp_i ) ; fs3qapxw1l ( xk_p , & xi_seq [ k1_tmp ] , EMFrntTrq , Vx , delta_Frnt , Acc , tmp ) ; tmp_i = _mm_sub_pd ( _mm_loadu_pd ( & xi_seq_p [ k1_tmp ] ) , _mm_add_pd ( _mm_div_pd ( _mm_mul_pd ( _mm_add_pd ( _mm_loadu_pd ( & k1 [ 0 ] ) , _mm_loadu_pd ( & tmp [ 0 ] ) ) , tmp_p ) , tmp_e ) , _mm_loadu_pd ( & xi_seq_e [ s ] ) ) ) ; _mm_storeu_pd ( & varargout_2 [ k1_tmp ] , tmp_i ) ; } for ( k1_tmp = 0 ; k1_tmp < 20 ; k1_tmp ++ ) { EMTrqs_seq_p = xi_seq [ k1_tmp + 6 ] ; xi_seq_p [ k1_tmp ] = EMTrqs_seq_p ; xi_seq_e [ k1_tmp ] = EMTrqs_seq_p ; } for ( iy = 0 ; iy < 7 ; iy ++ ) { s = ( iy + 2 ) << 1 ; fs3qapxw1l ( & xi_seq [ s + 6 ] , & xi_seq [ 4 ] , EMFrntTrq , Vx , delta_Frnt , Acc , k1 ) ; tmp_e = _mm_add_pd ( _mm_loadu_pd ( & x_seq [ s ] ) , _mm_mul_pd ( tmp_p , _mm_loadu_pd ( & k1 [ 0 ] ) ) ) ; _mm_storeu_pd ( & xk_p [ 0 ] , tmp_e ) ; fs3qapxw1l ( xk_p , & xi_seq [ 4 ] , EMFrntTrq , Vx , delta_Frnt , Acc , tmp ) ; k1_tmp = ( iy + 3 ) << 1 ; varargout_2 [ k1_tmp ] = xi_seq_p [ k1_tmp ] - ( ( k1 [ 0 ] + tmp [ 0 ] ) * 0.01 / 2.0 + xi_seq_e [ s ] ) ; varargout_2 [ k1_tmp + 1 ] = xi_seq_p [ k1_tmp + 1 ] - ( ( k1 [ 1 ] + tmp [ 1 ] ) * 0.01 / 2.0 + xi_seq_e [ s + 1 ] ) ; } for ( iy = 0 ; iy < 24 ; iy ++ ) { c_ineq_EMTrqIncMax [ iy ] = ( rtNaN ) ; c_ineq_EMTrqsMax [ iy ] = ( rtNaN ) ; } for ( iy = 0 ; iy < 3 ; iy ++ ) { s = iy << 2 ; EMTrqs_seq_p = EMTrqInc_seq [ s ] ; k1_tmp = iy << 3 ; c_ineq_EMTrqIncMax [ k1_tmp ] = EMTrqs_seq_p - 5.0 ; c_ineq_EMTrqIncMax [ k1_tmp + 4 ] = - EMTrqs_seq_p - 5.0 ; EMTrqs_seq_p = EMTrqs_seq [ s ] ; c_ineq_EMTrqsMax [ k1_tmp ] = EMTrqs_seq_p - EMTrqMaxFrnt ; c_ineq_EMTrqsMax [ k1_tmp + 4 ] = - EMTrqs_seq_p - EMTrqMaxFrnt ; EMTrqs_seq_p = EMTrqInc_seq [ s + 1 ] ; c_ineq_EMTrqIncMax [ k1_tmp + 1 ] = EMTrqs_seq_p - 5.0 ; c_ineq_EMTrqIncMax [ k1_tmp + 5 ] = - EMTrqs_seq_p - 5.0 ; EMTrqs_seq_p = EMTrqs_seq [ s + 1 ] ; c_ineq_EMTrqsMax [ k1_tmp + 1 ] = EMTrqs_seq_p - EMTrqMaxFrnt ; c_ineq_EMTrqsMax [ k1_tmp + 5 ] = - EMTrqs_seq_p - EMTrqMaxFrnt ; EMTrqs_seq_p = EMTrqInc_seq [ s + 2 ] ; c_ineq_EMTrqIncMax [ k1_tmp + 2 ] = EMTrqs_seq_p - 5.0 ; c_ineq_EMTrqIncMax [ k1_tmp + 6 ] = - EMTrqs_seq_p - 5.0 ; EMTrqs_seq_p = EMTrqs_seq [ s + 2 ] ; c_ineq_EMTrqsMax [ k1_tmp + 2 ] = EMTrqs_seq_p - EMTrqMaxRear ; c_ineq_EMTrqsMax [ k1_tmp + 6 ] = - EMTrqs_seq_p - EMTrqMaxRear ; EMTrqs_seq_p = EMTrqInc_seq [ s + 3 ] ; c_ineq_EMTrqIncMax [ k1_tmp + 3 ] = EMTrqs_seq_p - 5.0 ; c_ineq_EMTrqIncMax [ k1_tmp + 7 ] = - EMTrqs_seq_p - 5.0 ; EMTrqs_seq_p = EMTrqs_seq [ s + 3 ] ; c_ineq_EMTrqsMax [ k1_tmp + 3 ] = EMTrqs_seq_p - EMTrqMaxRear ; c_ineq_EMTrqsMax [ k1_tmp + 7 ] = - EMTrqs_seq_p - EMTrqMaxRear ; k1_tmp = iy << 1 ; _mm_storeu_pd ( & u_seq [ k1_tmp ] , _mm_mul_pd ( _mm_set_pd ( - xi_seq [ k1_tmp + 1 ] , - xi_seq [ k1_tmp ] ) , _mm_set1_pd ( delta_Frnt ) ) ) ; } for ( k1_tmp = 0 ; k1_tmp < 24 ; k1_tmp ++ ) { varargout_1 [ k1_tmp ] = c_ineq_EMTrqIncMax [ k1_tmp ] ; varargout_1 [ k1_tmp + 24 ] = c_ineq_EMTrqsMax [ k1_tmp ] ; } for ( k1_tmp = 0 ; k1_tmp < 6 ; k1_tmp ++ ) { varargout_1 [ k1_tmp + 48 ] = u_seq [ k1_tmp ] ; } } static void in0icnpfc3 ( const real_T obj_next_next_next_next_next_next_next_b_value_workspace_xk [ 2 ] , const real_T obj_next_next_next_next_next_next_next_b_value_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T obj_next_next_next_next_next_next_next_b_value_workspace_Vx , real_T obj_next_next_next_next_next_next_next_b_value_workspace_delta_Frnt , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxFrnt , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxRear , const real_T obj_next_next_next_next_next_next_next_b_value_workspace_Acc [ 3 ] , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMFrntTrq , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMRearTrq , const n4zzvudoa0 * obj_next_next_next_next_next_next_next_next_b_value_workspace , const real_T x [ 26 ] , real_T Cineq_workspace [ 54 ] , real_T Ceq_workspace [ 20 ] , real_T * fval , int32_T * status ) { real_T b [ 54 ] ; real_T c [ 20 ] ; real_T tmp_p [ 2 ] ; boolean_T tmp ; kqfgedufzz ( x , obj_next_next_next_next_next_next_next_next_b_value_workspace -> xk , obj_next_next_next_next_next_next_next_next_b_value_workspace -> PrevEMTrqCmdFinals , obj_next_next_next_next_next_next_next_next_b_value_workspace -> EMFrntTrq , obj_next_next_next_next_next_next_next_next_b_value_workspace -> EMRearTrq , obj_next_next_next_next_next_next_next_next_b_value_workspace -> r_ref , tmp_p ) ; * fval = sumColumnB_PypaGfPh ( tmp_p ) ; tmp = muDoubleScalarIsNaN ( * fval ) ; if ( muDoubleScalarIsInf ( * fval ) || tmp ) { if ( tmp ) { * status = - 3 ; } else if ( * fval < 0.0 ) { * status = - 1 ; } else { * status = - 2 ; } } else { evwyhhhxfb ( obj_next_next_next_next_next_next_next_b_value_workspace_xk , obj_next_next_next_next_next_next_next_b_value_workspace_PrevEMTrqCmdFinals , obj_next_next_next_next_next_next_next_b_value_workspace_Vx , obj_next_next_next_next_next_next_next_b_value_workspace_delta_Frnt , obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxFrnt , obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxRear , obj_next_next_next_next_next_next_next_b_value_workspace_Acc , obj_next_next_next_next_next_next_next_b_value_workspace_EMFrntTrq , obj_next_next_next_next_next_next_next_b_value_workspace_EMRearTrq , x , b , c ) ; memcpy ( & Cineq_workspace [ 0 ] , & b [ 0 ] , 54U * sizeof ( real_T ) ) ; memcpy ( & Ceq_workspace [ 0 ] , & c [ 0 ] , 20U * sizeof ( real_T ) ) ; * status = checkVectorNonFinite_Mtnc75LS ( Cineq_workspace ) ; if ( * status == 1 ) { * status = checkVectorNonFinite_Fp2Tnt5U ( Ceq_workspace ) ; } } } static void e4ctbgzcfy3 ( const real_T objfun_workspace_xk [ 2 ] , const real_T objfun_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T objfun_workspace_EMFrntTrq , real_T objfun_workspace_EMRearTrq , real_T objfun_workspace_r_ref , const cuxlzjpzbn * nonlin_workspace , const real_T lb [ 26 ] , const real_T ub [ 26 ] , aoeufdu2eg * obj ) { int32_T idx ; boolean_T d ; obj -> objfun . workspace . xk [ 0 ] = objfun_workspace_xk [ 0 ] ; obj -> objfun . workspace . xk [ 1 ] = objfun_workspace_xk [ 1 ] ; obj -> objfun . workspace . PrevEMTrqCmdFinals [ 0 ] = objfun_workspace_PrevEMTrqCmdFinals [ 0 ] ; obj -> objfun . workspace . PrevEMTrqCmdFinals [ 1 ] = objfun_workspace_PrevEMTrqCmdFinals [ 1 ] ; obj -> objfun . workspace . PrevEMTrqCmdFinals [ 2 ] = objfun_workspace_PrevEMTrqCmdFinals [ 2 ] ; obj -> objfun . workspace . PrevEMTrqCmdFinals [ 3 ] = objfun_workspace_PrevEMTrqCmdFinals [ 3 ] ; obj -> objfun . workspace . EMFrntTrq = objfun_workspace_EMFrntTrq ; obj -> objfun . workspace . EMRearTrq = objfun_workspace_EMRearTrq ; obj -> objfun . workspace . r_ref = objfun_workspace_r_ref ; obj -> nonlin . workspace = * nonlin_workspace ; obj -> f_1 = 0.0 ; obj -> f_2 = 0.0 ; obj -> nVar = 26 ; obj -> mIneq = 54 ; obj -> mEq = 20 ; obj -> numEvals = 0 ; obj -> SpecifyObjectiveGradient = false ; obj -> SpecifyConstraintGradient = false ; obj -> isEmptyNonlcon = false ; obj -> FiniteDifferenceType = 0 ; d = false ; idx = 0 ; while ( ( ! d ) && ( idx + 1 <= 26 ) ) { obj -> hasLB [ idx ] = ( ( ! muDoubleScalarIsInf ( lb [ idx ] ) ) && ( ! muDoubleScalarIsNaN ( lb [ idx ] ) ) ) ; obj -> hasUB [ idx ] = ( ( ! muDoubleScalarIsInf ( ub [ idx ] ) ) && ( ! muDoubleScalarIsNaN ( ub [ idx ] ) ) ) ; if ( obj -> hasLB [ idx ] || obj -> hasUB [ idx ] ) { d = true ; } idx ++ ; } while ( idx + 1 <= 26 ) { obj -> hasLB [ idx ] = ( ( ! muDoubleScalarIsInf ( lb [ idx ] ) ) && ( ! muDoubleScalarIsNaN ( lb [ idx ] ) ) ) ; obj -> hasUB [ idx ] = ( ( ! muDoubleScalarIsInf ( ub [ idx ] ) ) && ( ! muDoubleScalarIsNaN ( ub [ idx ] ) ) ) ; idx ++ ; } obj -> hasBounds = d ; } static boolean_T dk3cfa35ia ( const real_T obj_objfun_workspace_xk [ 2 ] , const real_T obj_objfun_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T obj_objfun_workspace_EMFrntTrq , real_T obj_objfun_workspace_EMRearTrq , real_T obj_objfun_workspace_r_ref , const real_T obj_nonlin_workspace_xk [ 2 ] , const real_T obj_nonlin_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T obj_nonlin_workspace_Vx , real_T obj_nonlin_workspace_delta_Frnt , real_T obj_nonlin_workspace_EMTrqMaxFrnt , real_T obj_nonlin_workspace_EMTrqMaxRear , const real_T obj_nonlin_workspace_Acc [ 3 ] , real_T obj_nonlin_workspace_EMFrntTrq , real_T obj_nonlin_workspace_EMRearTrq , real_T * fplus , real_T cIneqPlus [ 54 ] , real_T cEqPlus [ 20 ] , int32_T dim , real_T delta , real_T xk [ 26 ] ) { real_T tmp [ 2 ] ; real_T temp_tmp ; int32_T idx ; boolean_T evalOK ; temp_tmp = xk [ dim - 1 ] ; xk [ dim - 1 ] = temp_tmp + delta ; kqfgedufzz ( xk , obj_objfun_workspace_xk , obj_objfun_workspace_PrevEMTrqCmdFinals , obj_objfun_workspace_EMFrntTrq , obj_objfun_workspace_EMRearTrq , obj_objfun_workspace_r_ref , tmp ) ; * fplus = sumColumnB_PypaGfPh ( tmp ) ; evalOK = ( ( ! muDoubleScalarIsInf ( * fplus ) ) && ( ! muDoubleScalarIsNaN ( * fplus ) ) ) ; if ( evalOK ) { evwyhhhxfb ( obj_nonlin_workspace_xk , obj_nonlin_workspace_PrevEMTrqCmdFinals , obj_nonlin_workspace_Vx , obj_nonlin_workspace_delta_Frnt , obj_nonlin_workspace_EMTrqMaxFrnt , obj_nonlin_workspace_EMTrqMaxRear , obj_nonlin_workspace_Acc , obj_nonlin_workspace_EMFrntTrq , obj_nonlin_workspace_EMRearTrq , xk , cIneqPlus , cEqPlus ) ; idx = 0 ; while ( evalOK && ( idx + 1 <= 54 ) ) { evalOK = ( ( ! muDoubleScalarIsInf ( cIneqPlus [ idx ] ) ) && ( ! muDoubleScalarIsNaN ( cIneqPlus [ idx ] ) ) ) ; idx ++ ; } if ( evalOK ) { idx = 0 ; while ( evalOK && ( idx + 1 <= 20 ) ) { evalOK = ( ( ! muDoubleScalarIsInf ( cEqPlus [ idx ] ) ) && ( ! muDoubleScalarIsNaN ( cEqPlus [ idx ] ) ) ) ; idx ++ ; } xk [ dim - 1 ] = temp_tmp ; } } return evalOK ; } static boolean_T bvp0ue5q2p ( aoeufdu2eg * obj , real_T fCurrent , const real_T cIneqCurrent [ 54 ] , const real_T cEqCurrent [ 20 ] , real_T xk [ 26 ] , real_T gradf [ 121 ] , real_T JacCineqTrans [ 6534 ] , real_T JacCeqTrans [ 2420 ] , const real_T lb [ 26 ] , const real_T ub [ 26 ] ) { real_T deltaX ; real_T tmp ; int32_T idx ; int32_T idx_row ; boolean_T evalOK ; boolean_T exitg1 ; boolean_T guard1 ; boolean_T modifiedStep ; evalOK = true ; obj -> numEvals = 0 ; idx = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( idx < 26 ) ) { modifiedStep = false ; deltaX = ( 1.0 - ( real_T ) ( xk [ idx ] < 0.0 ) * 2.0 ) * 1.4901161193847656E-8 * muDoubleScalarMax ( muDoubleScalarAbs ( xk [ idx ] ) , 1.0 ) ; if ( obj -> hasLB [ idx ] || obj -> hasUB [ idx ] ) { if ( obj -> hasLB [ idx ] && obj -> hasUB [ idx ] ) { modifiedStep = fwdFinDiffInsideBnds_ackjW8wf ( xk [ idx ] , lb [ idx ] , ub [ idx ] , & deltaX ) ; } else if ( obj -> hasUB [ idx ] ) { if ( ( xk [ idx ] <= ub [ idx ] ) && ( xk [ idx ] + deltaX > ub [ idx ] ) ) { deltaX = - deltaX ; modifiedStep = true ; } } else if ( ( xk [ idx ] >= lb [ idx ] ) && ( xk [ idx ] + deltaX < lb [ idx ] ) ) { deltaX = - deltaX ; modifiedStep = true ; } } evalOK = dk3cfa35ia ( obj -> objfun . workspace . xk , obj -> objfun . workspace . PrevEMTrqCmdFinals , obj -> objfun . workspace . EMFrntTrq , obj -> objfun . workspace . EMRearTrq , obj -> objfun . workspace . r_ref , obj -> nonlin . workspace . xk , obj -> nonlin . workspace . PrevEMTrqCmdFinals , obj -> nonlin . workspace . Vx , obj -> nonlin . workspace . delta_Frnt , obj -> nonlin . workspace . EMTrqMaxFrnt , obj -> nonlin . workspace . EMTrqMaxRear , obj -> nonlin . workspace . Acc , obj -> nonlin . workspace . EMFrntTrq , obj -> nonlin . workspace . EMRearTrq , & obj -> f_1 , obj -> cIneq_1 , obj -> cEq_1 , idx + 1 , deltaX , xk ) ; obj -> numEvals ++ ; guard1 = false ; if ( ! evalOK ) { if ( ! modifiedStep ) { deltaX = - deltaX ; if ( obj -> hasLB [ idx ] ) { tmp = xk [ idx ] + deltaX ; if ( ( tmp >= lb [ idx ] ) && obj -> hasUB [ idx ] && ( tmp <= ub [ idx ] ) ) { modifiedStep = true ; } } if ( ( ! obj -> hasBounds ) || modifiedStep ) { evalOK = dk3cfa35ia ( obj -> objfun . workspace . xk , obj -> objfun . workspace . PrevEMTrqCmdFinals , obj -> objfun . workspace . EMFrntTrq , obj -> objfun . workspace . EMRearTrq , obj -> objfun . workspace . r_ref , obj -> nonlin . workspace . xk , obj -> nonlin . workspace . PrevEMTrqCmdFinals , obj -> nonlin . workspace . Vx , obj -> nonlin . workspace . delta_Frnt , obj -> nonlin . workspace . EMTrqMaxFrnt , obj -> nonlin . workspace . EMTrqMaxRear , obj -> nonlin . workspace . Acc , obj -> nonlin . workspace . EMFrntTrq , obj -> nonlin . workspace . EMRearTrq , & obj -> f_1 , obj -> cIneq_1 , obj -> cEq_1 , idx + 1 , deltaX , xk ) ; obj -> numEvals ++ ; } } if ( ! evalOK ) { exitg1 = true ; } else { guard1 = true ; } } else { guard1 = true ; } if ( guard1 ) { gradf [ idx ] = ( obj -> f_1 - fCurrent ) / deltaX ; for ( idx_row = 0 ; idx_row < 54 ; idx_row ++ ) { JacCineqTrans [ idx + 121 * idx_row ] = ( obj -> cIneq_1 [ idx_row ] - cIneqCurrent [ idx_row ] ) / deltaX ; } for ( idx_row = 0 ; idx_row < 20 ; idx_row ++ ) { JacCeqTrans [ idx + 121 * idx_row ] = ( obj -> cEq_1 [ idx_row ] - cEqCurrent [ idx_row ] ) / deltaX ; } idx ++ ; } } return evalOK ; } static void hqukg0j2js ( const real_T xk [ 26 ] , c3tcu1vsoj * WorkingSet , const real_T cIneq [ 54 ] , const real_T cEq [ 20 ] , int32_T mLB , const real_T lb [ 26 ] , int32_T mUB , const real_T ub [ 26 ] , int32_T mFixed ) { real_T tmp [ 2 ] ; real_T WorkingSet_beq ; int32_T iEq0 ; int32_T idx ; int32_T iw0 ; iw0 = 121 * mFixed ; iEq0 = 0 ; for ( idx = 0 ; idx < 20 ; idx ++ ) { WorkingSet_beq = - cEq [ idx ] ; WorkingSet -> beq [ idx ] = WorkingSet_beq ; WorkingSet -> bwset [ mFixed + idx ] = WorkingSet_beq ; memcpy ( & WorkingSet -> ATwset [ iw0 ] , & WorkingSet -> Aeq [ iEq0 ] , 26U * sizeof ( real_T ) ) ; iw0 += 121 ; iEq0 += 121 ; } for ( idx = 0 ; idx <= 52 ; idx += 2 ) { _mm_storeu_pd ( & WorkingSet -> bineq [ idx ] , _mm_mul_pd ( _mm_loadu_pd ( & cIneq [ idx ] ) , _mm_set1_pd ( - 1.0 ) ) ) ; } iw0 = ( uint8_T ) mLB ; for ( idx = 0 ; idx < iw0 ; idx ++ ) { WorkingSet -> lb [ WorkingSet -> indexLB [ idx ] - 1 ] = - lb [ WorkingSet -> indexLB [ idx ] - 1 ] + xk [ WorkingSet -> indexLB [ idx ] - 1 ] ; } iw0 = ( uint8_T ) mUB ; for ( idx = 0 ; idx < iw0 ; idx ++ ) { WorkingSet -> ub [ WorkingSet -> indexUB [ idx ] - 1 ] = ub [ WorkingSet -> indexUB [ idx ] - 1 ] - xk [ WorkingSet -> indexUB [ idx ] - 1 ] ; } iw0 = ( uint8_T ) mFixed ; for ( idx = 0 ; idx < iw0 ; idx ++ ) { _mm_storeu_pd ( & tmp [ 0 ] , _mm_sub_pd ( _mm_set1_pd ( ub [ WorkingSet -> indexFixed [ idx ] - 1 ] ) , _mm_set1_pd ( xk [ WorkingSet -> indexFixed [ idx ] - 1 ] ) ) ) ; WorkingSet -> ub [ WorkingSet -> indexFixed [ idx ] - 1 ] = tmp [ 0 ] ; WorkingSet -> bwset [ idx ] = tmp [ 1 ] ; } } static void jvmklsxrqg ( c3tcu1vsoj * obj ) { int32_T c ; int32_T idx ; int32_T idxEq ; int32_T tmp ; idxEq = ( uint8_T ) obj -> sizes [ 0 ] ; for ( idx = 0 ; idx < idxEq ; idx ++ ) { obj -> ATwset [ ( obj -> nVar + 121 * idx ) - 1 ] = 0.0 ; } for ( idx = 0 ; idx < 20 ; idx ++ ) { idxEq = ( 121 * idx + obj -> nVar ) - 1 ; obj -> Aeq [ idxEq ] = 0.0 ; obj -> ATwset [ idxEq + 121 * ( obj -> isActiveIdx [ 1 ] - 1 ) ] = 0.0 ; } for ( idx = 0 ; idx < 54 ; idx ++ ) { obj -> Aineq [ ( obj -> nVar + 121 * idx ) - 1 ] = - 1.0 ; } obj -> indexLB [ obj -> sizes [ 3 ] - 1 ] = obj -> nVar ; obj -> lb [ obj -> nVar - 1 ] = 1.0E-5 ; idxEq = obj -> isActiveIdx [ 2 ] ; c = obj -> nActiveConstr ; for ( idx = idxEq ; idx <= c ; idx ++ ) { obj -> ATwset [ ( obj -> nVar + 121 * ( idx - 1 ) ) - 1 ] = - 1.0 ; } idxEq = obj -> isActiveIdx [ 4 ] - 1 ; if ( obj -> nWConstr [ 4 ] > 0 ) { c = obj -> sizesNormal [ 4 ] ; for ( idx = c ; idx >= 1 ; idx -- ) { tmp = idxEq + idx ; obj -> isActiveConstr [ tmp ] = obj -> isActiveConstr [ tmp - 1 ] ; } } else { obj -> isActiveConstr [ ( obj -> isActiveIdx [ 4 ] + obj -> sizesNormal [ 4 ] ) - 1 ] = false ; } obj -> isActiveConstr [ obj -> isActiveIdx [ 4 ] - 1 ] = false ; } static void i3lcleconb ( c3tcu1vsoj * obj , int32_T PROBLEM_TYPE ) { int32_T colOffsetATw ; int32_T colOffsetAeq ; int32_T d_idx_row ; int32_T idxStartIneq ; int32_T idxUpperExisting ; int32_T j ; int32_T j_tmp ; switch ( PROBLEM_TYPE ) { case 3 : obj -> nVar = 26 ; obj -> mConstr = obj -> mConstrOrig ; if ( obj -> nWConstr [ 4 ] > 0 ) { idxUpperExisting = obj -> isActiveIdx [ 4 ] - 1 ; idxStartIneq = ( uint8_T ) obj -> sizesNormal [ 4 ] ; for ( colOffsetATw = 0 ; colOffsetATw < idxStartIneq ; colOffsetATw ++ ) { j = idxUpperExisting + colOffsetATw ; obj -> isActiveConstr [ ( obj -> isActiveIdxNormal [ 4 ] + colOffsetATw ) - 1 ] = obj -> isActiveConstr [ j ] ; obj -> isActiveConstr [ j ] = false ; } } for ( j = 0 ; j < 5 ; j ++ ) { obj -> sizes [ j ] = obj -> sizesNormal [ j ] ; } for ( j = 0 ; j < 6 ; j ++ ) { obj -> isActiveIdx [ j ] = obj -> isActiveIdxNormal [ j ] ; } break ; case 1 : obj -> nVar = 27 ; obj -> mConstr = obj -> mConstrOrig + 1 ; for ( j = 0 ; j < 5 ; j ++ ) { obj -> sizes [ j ] = obj -> sizesPhaseOne [ j ] ; } jvmklsxrqg ( obj ) ; for ( j = 0 ; j < 6 ; j ++ ) { obj -> isActiveIdx [ j ] = obj -> isActiveIdxPhaseOne [ j ] ; } break ; case 2 : obj -> nVar = 120 ; obj -> mConstr = 220 ; for ( j = 0 ; j < 5 ; j ++ ) { obj -> sizes [ j ] = obj -> sizesRegularized [ j ] ; } if ( obj -> probType != 4 ) { colOffsetAeq = ( uint8_T ) obj -> sizes [ 0 ] ; for ( idxUpperExisting = 0 ; idxUpperExisting < colOffsetAeq ; idxUpperExisting ++ ) { colOffsetATw = 121 * idxUpperExisting ; for ( idxStartIneq = 0 ; idxStartIneq < 94 ; idxStartIneq ++ ) { obj -> ATwset [ ( idxStartIneq + colOffsetATw ) + 26 ] = 0.0 ; } } for ( colOffsetATw = 0 ; colOffsetATw < 54 ; colOffsetATw ++ ) { idxUpperExisting = 121 * colOffsetATw - 1 ; for ( idxStartIneq = 27 ; idxStartIneq <= colOffsetATw + 26 ; idxStartIneq ++ ) { obj -> Aineq [ idxStartIneq + idxUpperExisting ] = 0.0 ; } obj -> Aineq [ ( colOffsetATw + idxUpperExisting ) + 27 ] = - 1.0 ; for ( idxStartIneq = colOffsetATw + 28 ; idxStartIneq < 121 ; idxStartIneq ++ ) { obj -> Aineq [ idxStartIneq + idxUpperExisting ] = 0.0 ; } } for ( idxUpperExisting = 0 ; idxUpperExisting < 20 ; idxUpperExisting ++ ) { colOffsetAeq = 121 * idxUpperExisting - 1 ; colOffsetATw = ( obj -> isActiveIdx [ 1 ] - 1 ) * 121 + colOffsetAeq ; for ( d_idx_row = 0 ; d_idx_row < 54 ; d_idx_row ++ ) { obj -> Aeq [ ( d_idx_row + colOffsetAeq ) + 27 ] = 0.0 ; obj -> ATwset [ ( d_idx_row + colOffsetATw ) + 27 ] = 0.0 ; } for ( d_idx_row = 81 ; d_idx_row <= idxUpperExisting + 80 ; d_idx_row ++ ) { obj -> Aeq [ d_idx_row + colOffsetAeq ] = 0.0 ; obj -> ATwset [ d_idx_row + colOffsetATw ] = 0.0 ; } j = idxUpperExisting + colOffsetAeq ; obj -> Aeq [ j + 81 ] = - 1.0 ; idxStartIneq = idxUpperExisting + colOffsetATw ; obj -> ATwset [ idxStartIneq + 81 ] = - 1.0 ; for ( d_idx_row = idxUpperExisting + 82 ; d_idx_row < 101 ; d_idx_row ++ ) { obj -> Aeq [ d_idx_row + colOffsetAeq ] = 0.0 ; obj -> ATwset [ d_idx_row + colOffsetATw ] = 0.0 ; } for ( d_idx_row = 101 ; d_idx_row <= idxUpperExisting + 100 ; d_idx_row ++ ) { obj -> Aeq [ d_idx_row + colOffsetAeq ] = 0.0 ; obj -> ATwset [ d_idx_row + colOffsetATw ] = 0.0 ; } obj -> Aeq [ j + 101 ] = 1.0 ; obj -> ATwset [ idxStartIneq + 101 ] = 1.0 ; for ( d_idx_row = idxUpperExisting + 102 ; d_idx_row < 121 ; d_idx_row ++ ) { obj -> Aeq [ d_idx_row + colOffsetAeq ] = 0.0 ; obj -> ATwset [ d_idx_row + colOffsetATw ] = 0.0 ; } } idxUpperExisting = 26 ; idxStartIneq = obj -> sizesNormal [ 3 ] + 1 ; colOffsetAeq = obj -> sizesRegularized [ 3 ] ; for ( colOffsetATw = idxStartIneq ; colOffsetATw <= colOffsetAeq ; colOffsetATw ++ ) { idxUpperExisting ++ ; obj -> indexLB [ colOffsetATw - 1 ] = idxUpperExisting ; } if ( obj -> nWConstr [ 4 ] > 0 ) { idxUpperExisting = ( uint8_T ) obj -> sizesRegularized [ 4 ] ; for ( colOffsetATw = 0 ; colOffsetATw < idxUpperExisting ; colOffsetATw ++ ) { obj -> isActiveConstr [ obj -> isActiveIdxRegularized [ 4 ] + colOffsetATw ] = obj -> isActiveConstr [ ( obj -> isActiveIdx [ 4 ] + colOffsetATw ) - 1 ] ; } } idxUpperExisting = obj -> isActiveIdx [ 4 ] ; idxStartIneq = obj -> isActiveIdxRegularized [ 4 ] ; if ( idxUpperExisting <= idxStartIneq - 1 ) { memset ( & obj -> isActiveConstr [ idxUpperExisting + - 1 ] , 0 , ( uint32_T ) ( idxStartIneq - idxUpperExisting ) * sizeof ( boolean_T ) ) ; } for ( colOffsetATw = 0 ; colOffsetATw < 94 ; colOffsetATw ++ ) { obj -> lb [ colOffsetATw + 26 ] = 0.0 ; } idxStartIneq = obj -> isActiveIdx [ 2 ] ; colOffsetAeq = obj -> nActiveConstr ; for ( idxUpperExisting = idxStartIneq ; idxUpperExisting <= colOffsetAeq ; idxUpperExisting ++ ) { colOffsetATw = ( idxUpperExisting - 1 ) * 121 - 1 ; if ( obj -> Wid [ idxUpperExisting - 1 ] == 3 ) { j_tmp = obj -> Wlocalidx [ idxUpperExisting - 1 ] ; j = j_tmp + 25 ; for ( d_idx_row = 27 ; d_idx_row <= j ; d_idx_row ++ ) { obj -> ATwset [ d_idx_row + colOffsetATw ] = 0.0 ; } obj -> ATwset [ ( j_tmp + colOffsetATw ) + 26 ] = - 1.0 ; j = j_tmp + 27 ; for ( d_idx_row = j ; d_idx_row < 121 ; d_idx_row ++ ) { obj -> ATwset [ d_idx_row + colOffsetATw ] = 0.0 ; } } else { for ( d_idx_row = 0 ; d_idx_row < 94 ; d_idx_row ++ ) { obj -> ATwset [ ( d_idx_row + colOffsetATw ) + 27 ] = 0.0 ; } } } } for ( j = 0 ; j < 6 ; j ++ ) { obj -> isActiveIdx [ j ] = obj -> isActiveIdxRegularized [ j ] ; } break ; default : obj -> nVar = 121 ; obj -> mConstr = 221 ; for ( j = 0 ; j < 5 ; j ++ ) { obj -> sizes [ j ] = obj -> sizesRegPhaseOne [ j ] ; } jvmklsxrqg ( obj ) ; for ( j = 0 ; j < 6 ; j ++ ) { obj -> isActiveIdx [ j ] = obj -> isActiveIdxRegPhaseOne [ j ] ; } break ; } obj -> probType = PROBLEM_TYPE ; } static void ai0qsnj2tx ( c3tcu1vsoj * obj ) { int32_T colOffsetATw ; int32_T e ; int32_T iATw0 ; int32_T iAeq0 ; int32_T idx ; int32_T idxFillStart ; i3lcleconb ( obj , 3 ) ; idxFillStart = obj -> isActiveIdx [ 2 ] ; for ( idx = idxFillStart ; idx < 222 ; idx ++ ) { obj -> isActiveConstr [ idx - 1 ] = false ; } obj -> nWConstr [ 0 ] = obj -> sizes [ 0 ] ; obj -> nWConstr [ 1 ] = 20 ; obj -> nWConstr [ 2 ] = 0 ; obj -> nWConstr [ 3 ] = 0 ; obj -> nWConstr [ 4 ] = 0 ; obj -> nActiveConstr = obj -> nWConstr [ 0 ] + 20 ; idxFillStart = ( uint8_T ) obj -> sizes [ 0 ] ; for ( idx = 0 ; idx < idxFillStart ; idx ++ ) { obj -> Wid [ idx ] = 1 ; obj -> Wlocalidx [ idx ] = idx + 1 ; obj -> isActiveConstr [ idx ] = true ; colOffsetATw = 121 * idx ; iATw0 = obj -> indexFixed [ idx ] ; for ( iAeq0 = 0 ; iAeq0 <= iATw0 - 2 ; iAeq0 ++ ) { obj -> ATwset [ iAeq0 + colOffsetATw ] = 0.0 ; } obj -> ATwset [ ( obj -> indexFixed [ idx ] + colOffsetATw ) - 1 ] = 1.0 ; iATw0 = obj -> indexFixed [ idx ] + 1 ; e = obj -> nVar ; for ( iAeq0 = iATw0 ; iAeq0 <= e ; iAeq0 ++ ) { obj -> ATwset [ ( iAeq0 + colOffsetATw ) - 1 ] = 0.0 ; } obj -> bwset [ idx ] = obj -> ub [ obj -> indexFixed [ idx ] - 1 ] ; } for ( idx = 0 ; idx < 20 ; idx ++ ) { colOffsetATw = obj -> sizes [ 0 ] + idx ; obj -> Wid [ colOffsetATw ] = 2 ; obj -> Wlocalidx [ colOffsetATw ] = idx + 1 ; obj -> isActiveConstr [ colOffsetATw ] = true ; iAeq0 = 121 * idx ; iATw0 = 121 * colOffsetATw ; e = obj -> nVar ; for ( idxFillStart = 0 ; idxFillStart < e ; idxFillStart ++ ) { obj -> ATwset [ iATw0 + idxFillStart ] = obj -> Aeq [ iAeq0 + idxFillStart ] ; } obj -> bwset [ colOffsetATw ] = obj -> beq [ idx ] ; } } static void e4ctbgzcfy3j ( oytx5zapfu * obj ) { int32_T i ; obj -> ldq = 221 ; for ( i = 0 ; i < 48841 ; i ++ ) { obj -> Q [ i ] = 0.0 ; } memset ( & obj -> jpvt [ 0 ] , 0 , 221U * sizeof ( int32_T ) ) ; obj -> mrows = 0 ; obj -> ncols = 0 ; obj -> minRowCol = 0 ; obj -> usedPivoting = false ; } static real_T iqfbbuti1d ( const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , const real_T x [ 26 ] , const real_T cIneq [ 54 ] , const real_T cEq [ 20 ] , const int32_T finiteLB [ 121 ] , int32_T mLB , const real_T lb [ 26 ] , const int32_T finiteUB [ 121 ] , int32_T mUB , const real_T ub [ 26 ] ) { real_T feasError ; int32_T c_idx ; int32_T finiteLB_p ; int32_T idx ; feasError = 0.0 ; for ( idx = 0 ; idx < 20 ; idx ++ ) { feasError = muDoubleScalarMax ( feasError , muDoubleScalarAbs ( cEq [ idx ] / fscales_ceq_constraint [ idx ] ) ) ; } for ( idx = 0 ; idx < 54 ; idx ++ ) { feasError = muDoubleScalarMax ( feasError , cIneq [ idx ] / fscales_cineq_constraint [ idx ] ) ; } idx = ( uint8_T ) mLB ; for ( c_idx = 0 ; c_idx < idx ; c_idx ++ ) { finiteLB_p = finiteLB [ c_idx ] ; feasError = muDoubleScalarMax ( feasError , lb [ finiteLB_p - 1 ] - x [ finiteLB_p - 1 ] ) ; } idx = ( uint8_T ) mUB ; for ( c_idx = 0 ; c_idx < idx ; c_idx ++ ) { finiteLB_p = finiteUB [ c_idx ] ; feasError = muDoubleScalarMax ( feasError , x [ finiteLB_p - 1 ] - ub [ finiteLB_p - 1 ] ) ; } return feasError ; } static void fw12bnjdbo ( real_T fscales_objective , int32_T nVar , const real_T gradLag [ 121 ] , boolean_T * gradOK , real_T * val ) { int32_T exitg1 ; int32_T idx ; * gradOK = true ; * val = 0.0 ; idx = 0 ; do { exitg1 = 0 ; if ( idx <= ( uint8_T ) nVar - 1 ) { * gradOK = ( ( ! muDoubleScalarIsInf ( gradLag [ idx ] ) ) && ( ! muDoubleScalarIsNaN ( gradLag [ idx ] ) ) ) ; if ( ! * gradOK ) { exitg1 = 1 ; } else { * val = muDoubleScalarMax ( * val , muDoubleScalarAbs ( gradLag [ idx ] ) ) ; idx ++ ; } } else { * val /= fscales_objective ; exitg1 = 1 ; } } while ( exitg1 == 0 ) ; } static real_T efjv1gsbna ( real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T xCurrent [ 26 ] , const real_T cIneq [ 54 ] , const int32_T finiteLB [ 121 ] , int32_T mLB , const real_T lb [ 26 ] , const int32_T finiteUB [ 121 ] , int32_T mUB , const real_T ub [ 26 ] , const real_T lambda [ 221 ] , int32_T iL0 ) { real_T fscales_cineq_constraint_p ; real_T lbDelta ; real_T lbLambda ; real_T nlpComplError ; int32_T b ; int32_T b_idx ; int32_T finiteLB_p ; int32_T ubOffset ; nlpComplError = 0.0 ; for ( ubOffset = 0 ; ubOffset < 54 ; ubOffset ++ ) { lbDelta = cIneq [ ubOffset ] ; lbLambda = lambda [ ( iL0 + ubOffset ) - 1 ] ; fscales_cineq_constraint_p = fscales_cineq_constraint [ ubOffset ] ; nlpComplError = muDoubleScalarMax ( nlpComplError , muDoubleScalarMin ( muDoubleScalarAbs ( lbDelta * lbLambda / fscales_objective ) , muDoubleScalarMin ( muDoubleScalarAbs ( lbDelta ) / fscales_cineq_constraint_p , lbLambda / fscales_objective * fscales_cineq_constraint_p ) ) ) ; } ubOffset = ( iL0 + mLB ) + 53 ; b = ( uint8_T ) mLB ; for ( b_idx = 0 ; b_idx < b ; b_idx ++ ) { finiteLB_p = finiteLB [ b_idx ] ; lbDelta = xCurrent [ finiteLB_p - 1 ] - lb [ finiteLB_p - 1 ] ; lbLambda = lambda [ ( iL0 + b_idx ) + 53 ] ; nlpComplError = muDoubleScalarMax ( nlpComplError , muDoubleScalarMin ( muDoubleScalarAbs ( lbDelta * lbLambda / fscales_objective ) , muDoubleScalarMin ( muDoubleScalarAbs ( lbDelta ) , lbLambda / fscales_objective ) ) ) ; } b = ( uint8_T ) mUB ; for ( b_idx = 0 ; b_idx < b ; b_idx ++ ) { finiteLB_p = finiteUB [ b_idx ] ; lbDelta = ub [ finiteLB_p - 1 ] - xCurrent [ finiteLB_p - 1 ] ; lbLambda = lambda [ ubOffset + b_idx ] ; nlpComplError = muDoubleScalarMax ( nlpComplError , muDoubleScalarMin ( muDoubleScalarAbs ( lbDelta * lbLambda / fscales_objective ) , muDoubleScalarMin ( muDoubleScalarAbs ( lbDelta ) , lbLambda / fscales_objective ) ) ) ; } return nlpComplError ; } static void crspy0yej2 ( bhtu1h5bl5 * MeritFunction , real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , const c3tcu1vsoj * WorkingSet , ci1jcnwvc5 * TrialState , const real_T lb [ 26 ] , const real_T ub [ 26 ] , boolean_T * Flags_gradOK , boolean_T * Flags_fevalOK , boolean_T * Flags_done , boolean_T * Flags_stepAccepted , boolean_T * Flags_failedLineSearch , int32_T * Flags_stepType ) { real_T s ; real_T smax ; int32_T idx_max ; int32_T idx_max_tmp ; int32_T k ; int32_T nVar ; boolean_T isFeasible ; * Flags_fevalOK = true ; * Flags_stepAccepted = false ; * Flags_failedLineSearch = false ; * Flags_stepType = 1 ; nVar = WorkingSet -> nVar ; idx_max_tmp = ( uint16_T ) ( ( ( WorkingSet -> sizes [ 0 ] + WorkingSet -> sizes [ 3 ] ) + WorkingSet -> sizes [ 4 ] ) + 74 ) ; memcpy ( & TrialState -> lambdaStopTest [ 0 ] , & TrialState -> lambdasqp [ 0 ] , ( uint32_T ) idx_max_tmp * sizeof ( real_T ) ) ; computeGradLag_RU6nJ0OR ( TrialState -> gradLag , WorkingSet -> nVar , TrialState -> grad , WorkingSet -> Aineq , WorkingSet -> Aeq , WorkingSet -> indexFixed , WorkingSet -> sizes [ 0 ] , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , TrialState -> lambdaStopTest ) ; if ( WorkingSet -> nVar < 1 ) { idx_max = 0 ; } else { idx_max = 1 ; if ( WorkingSet -> nVar > 1 ) { smax = muDoubleScalarAbs ( TrialState -> grad [ 0 ] ) ; for ( k = 2 ; k <= nVar ; k ++ ) { s = muDoubleScalarAbs ( TrialState -> grad [ k - 1 ] ) ; if ( s > smax ) { idx_max = k ; smax = s ; } } } } smax = muDoubleScalarMax ( 1.0 , muDoubleScalarAbs ( TrialState -> grad [ idx_max - 1 ] ) / fscales_objective ) ; if ( muDoubleScalarIsInf ( smax ) ) { smax = 1.0 ; } MeritFunction -> nlpPrimalFeasError = iqfbbuti1d ( fscales_cineq_constraint , fscales_ceq_constraint , TrialState -> xstarsqp , TrialState -> cIneq , TrialState -> cEq , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , lb , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , ub ) ; MeritFunction -> feasRelativeFactor = muDoubleScalarMax ( 1.0 , MeritFunction -> nlpPrimalFeasError ) ; isFeasible = ( MeritFunction -> nlpPrimalFeasError <= 1.0E-6 * MeritFunction -> feasRelativeFactor ) ; fw12bnjdbo ( fscales_objective , WorkingSet -> nVar , TrialState -> gradLag , Flags_gradOK , & MeritFunction -> nlpDualFeasError ) ; if ( ! * Flags_gradOK ) { * Flags_done = true ; if ( isFeasible ) { TrialState -> sqpExitFlag = 2 ; } else { TrialState -> sqpExitFlag = - 2 ; } } else { MeritFunction -> nlpComplError = efjv1gsbna ( fscales_objective , fscales_cineq_constraint , TrialState -> xstarsqp , TrialState -> cIneq , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , lb , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , ub , TrialState -> lambdaStopTest , WorkingSet -> sizes [ 0 ] + 21 ) ; MeritFunction -> firstOrderOpt = muDoubleScalarMax ( MeritFunction -> nlpDualFeasError , MeritFunction -> nlpComplError ) ; memcpy ( & TrialState -> lambdaStopTestPrev [ 0 ] , & TrialState -> lambdaStopTest [ 0 ] , ( uint32_T ) idx_max_tmp * sizeof ( real_T ) ) ; if ( isFeasible && ( MeritFunction -> nlpDualFeasError <= 1.0E-6 * smax ) && ( MeritFunction -> nlpComplError <= 1.0E-6 * smax ) ) { * Flags_done = true ; TrialState -> sqpExitFlag = 1 ; } else { * Flags_done = false ; if ( isFeasible && ( TrialState -> sqpFval / fscales_objective < - 1.0E+20 ) ) { * Flags_done = true ; TrialState -> sqpExitFlag = - 3 ; } else if ( TrialState -> FunctionEvaluations >= 2600 ) { * Flags_done = true ; TrialState -> sqpExitFlag = 0 ; } } } } static void lmxrtyn3ij ( ci1jcnwvc5 * obj , int32_T nVar , const real_T JacCineqTrans [ 6534 ] , const real_T JacCeqTrans [ 2420 ] ) { int32_T b_tmp ; int32_T iCol ; int32_T iCol_old ; int32_T idx_col ; int32_T k ; iCol = 0 ; iCol_old = 0 ; b_tmp = ( uint8_T ) nVar ; for ( idx_col = 0 ; idx_col < 54 ; idx_col ++ ) { for ( k = 0 ; k < b_tmp ; k ++ ) { obj -> JacCineqTrans_old [ iCol_old + k ] = JacCineqTrans [ iCol + k ] ; } iCol_old = iCol + 121 ; iCol += 121 ; } iCol = 0 ; iCol_old = 0 ; for ( idx_col = 0 ; idx_col < 20 ; idx_col ++ ) { for ( k = 0 ; k < b_tmp ; k ++ ) { obj -> JacCeqTrans_old [ iCol_old + k ] = JacCeqTrans [ iCol + k ] ; } iCol_old = iCol + 121 ; iCol += 121 ; } } static void hqukg0j2jsd ( const real_T xk [ 26 ] , c3tcu1vsoj * WorkingSet , const real_T cIneq [ 54 ] , const real_T cEq [ 20 ] , int32_T mLB , const real_T lb [ 26 ] , int32_T mUB , const real_T ub [ 26 ] , int32_T mFixed ) { real_T tmp [ 2 ] ; real_T WorkingSet_beq ; int32_T f ; int32_T i ; int32_T iEq0 ; int32_T idx ; int32_T iw0 ; int32_T ix0 ; int32_T nVar ; nVar = WorkingSet -> nVar ; iw0 = 121 * mFixed ; iEq0 = 0 ; for ( idx = 0 ; idx < 20 ; idx ++ ) { WorkingSet_beq = - cEq [ idx ] ; WorkingSet -> beq [ idx ] = WorkingSet_beq ; WorkingSet -> bwset [ mFixed + idx ] = WorkingSet_beq ; for ( i = 0 ; i < nVar ; i ++ ) { WorkingSet -> ATwset [ iw0 + i ] = WorkingSet -> Aeq [ iEq0 + i ] ; } iw0 += 121 ; iEq0 += 121 ; } for ( idx = 0 ; idx <= 52 ; idx += 2 ) { _mm_storeu_pd ( & WorkingSet -> bineq [ idx ] , _mm_mul_pd ( _mm_loadu_pd ( & cIneq [ idx ] ) , _mm_set1_pd ( - 1.0 ) ) ) ; } i = ( uint8_T ) mLB ; for ( idx = 0 ; idx < i ; idx ++ ) { WorkingSet -> lb [ WorkingSet -> indexLB [ idx ] - 1 ] = - lb [ WorkingSet -> indexLB [ idx ] - 1 ] + xk [ WorkingSet -> indexLB [ idx ] - 1 ] ; } i = ( uint8_T ) mUB ; for ( idx = 0 ; idx < i ; idx ++ ) { WorkingSet -> ub [ WorkingSet -> indexUB [ idx ] - 1 ] = ub [ WorkingSet -> indexUB [ idx ] - 1 ] - xk [ WorkingSet -> indexUB [ idx ] - 1 ] ; } i = ( uint8_T ) mFixed ; for ( idx = 0 ; idx < i ; idx ++ ) { _mm_storeu_pd ( & tmp [ 0 ] , _mm_sub_pd ( _mm_set1_pd ( ub [ WorkingSet -> indexFixed [ idx ] - 1 ] ) , _mm_set1_pd ( xk [ WorkingSet -> indexFixed [ idx ] - 1 ] ) ) ) ; WorkingSet -> ub [ WorkingSet -> indexFixed [ idx ] - 1 ] = tmp [ 0 ] ; WorkingSet -> bwset [ idx ] = tmp [ 1 ] ; } if ( WorkingSet -> nActiveConstr > mFixed + 20 ) { iw0 = WorkingSet -> nActiveConstr ; for ( idx = mFixed + 21 ; idx <= iw0 ; idx ++ ) { switch ( WorkingSet -> Wid [ idx - 1 ] ) { case 4 : WorkingSet -> bwset [ idx - 1 ] = WorkingSet -> lb [ WorkingSet -> indexLB [ WorkingSet -> Wlocalidx [ idx - 1 ] - 1 ] - 1 ] ; break ; case 5 : WorkingSet -> bwset [ idx - 1 ] = WorkingSet -> ub [ WorkingSet -> indexUB [ WorkingSet -> Wlocalidx [ idx - 1 ] - 1 ] - 1 ] ; break ; default : i = WorkingSet -> Wlocalidx [ idx - 1 ] - 1 ; WorkingSet -> bwset [ idx - 1 ] = WorkingSet -> bineq [ i ] ; iEq0 = ( idx - 1 ) * 121 ; ix0 = i * 121 ; f = ( uint8_T ) nVar ; for ( i = 0 ; i < f ; i ++ ) { WorkingSet -> ATwset [ iEq0 + i ] = WorkingSet -> Aineq [ ix0 + i ] ; } break ; } } } } static real_T bjypmi3wva ( c3tcu1vsoj * obj , const real_T x [ 121 ] ) { real_T v ; int32_T k ; v = 0.0 ; memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> bineq [ 0 ] , 54U * sizeof ( real_T ) ) ; xgemv_MHbFIwYa ( obj -> nVar , obj -> Aineq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 54 ; k ++ ) { v = muDoubleScalarMax ( v , obj -> maxConstrWorkspace [ k ] ) ; } memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> beq [ 0 ] , 20U * sizeof ( real_T ) ) ; xgemv_57x7PwZU ( obj -> nVar , obj -> Aeq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 20 ; k ++ ) { v = muDoubleScalarMax ( v , muDoubleScalarAbs ( obj -> maxConstrWorkspace [ k ] ) ) ; } return v ; } static real_T kkqgbfnbrg ( c3tcu1vsoj * obj , const real_T x [ 121 ] ) { real_T obj_maxConstrWorkspace ; real_T v ; int32_T k ; v = 0.0 ; memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> bineq [ 0 ] , 54U * sizeof ( real_T ) ) ; xgemv_MHbFIwYa ( 26 , obj -> Aineq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 54 ; k ++ ) { obj_maxConstrWorkspace = obj -> maxConstrWorkspace [ k ] - x [ k + 26 ] ; obj -> maxConstrWorkspace [ k ] = obj_maxConstrWorkspace ; v = muDoubleScalarMax ( v , obj_maxConstrWorkspace ) ; } memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> beq [ 0 ] , 20U * sizeof ( real_T ) ) ; xgemv_57x7PwZU ( 26 , obj -> Aeq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 20 ; k ++ ) { obj_maxConstrWorkspace = ( obj -> maxConstrWorkspace [ k ] - x [ k + 80 ] ) + x [ k + 100 ] ; obj -> maxConstrWorkspace [ k ] = obj_maxConstrWorkspace ; v = muDoubleScalarMax ( v , muDoubleScalarAbs ( obj_maxConstrWorkspace ) ) ; } return v ; } static real_T p3kkfowucmzwk ( c3tcu1vsoj * obj , const real_T x [ 121 ] ) { real_T v ; int32_T b ; int32_T idx ; if ( obj -> probType == 2 ) { v = kkqgbfnbrg ( obj , x ) ; } else { v = bjypmi3wva ( obj , x ) ; } if ( obj -> sizes [ 3 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 3 ] ; for ( idx = 0 ; idx < b ; idx ++ ) { v = muDoubleScalarMax ( v , - x [ obj -> indexLB [ idx ] - 1 ] - obj -> lb [ obj -> indexLB [ idx ] - 1 ] ) ; } } if ( obj -> sizes [ 4 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 4 ] ; for ( idx = 0 ; idx < b ; idx ++ ) { v = muDoubleScalarMax ( v , x [ obj -> indexUB [ idx ] - 1 ] - obj -> ub [ obj -> indexUB [ idx ] - 1 ] ) ; } } if ( obj -> sizes [ 0 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 0 ] ; for ( idx = 0 ; idx < b ; idx ++ ) { v = muDoubleScalarMax ( v , muDoubleScalarAbs ( x [ obj -> indexFixed [ idx ] - 1 ] - obj -> ub [ obj -> indexFixed [ idx ] - 1 ] ) ) ; } } return v ; } static void gnvee1hvpj ( iamwnmrrfd * obj , const real_T H [ 676 ] , const real_T f [ 121 ] , const real_T x [ 121 ] ) { __m128d tmp ; int32_T i ; int32_T ixlast ; int32_T scalarLB ; int32_T scalarLB_tmp ; int32_T tmp_p ; int32_T vectorUB ; switch ( obj -> objtype ) { case 5 : ixlast = obj -> nvar ; for ( i = 0 ; i <= ixlast - 2 ; i ++ ) { obj -> grad [ i ] = 0.0 ; } obj -> grad [ obj -> nvar - 1 ] = obj -> gammaScalar ; break ; case 3 : xgemv_e2rVE54U ( obj -> nvar , obj -> nvar , H , obj -> nvar , x , obj -> Hx ) ; if ( obj -> nvar - 1 >= 0 ) { memcpy ( & obj -> grad [ 0 ] , & obj -> Hx [ 0 ] , ( uint32_T ) obj -> nvar * sizeof ( real_T ) ) ; } if ( obj -> hasLinear && ( obj -> nvar >= 1 ) ) { ixlast = obj -> nvar ; scalarLB = ( obj -> nvar / 2 ) << 1 ; vectorUB = scalarLB - 2 ; for ( i = 0 ; i <= vectorUB ; i += 2 ) { tmp = _mm_loadu_pd ( & obj -> grad [ i ] ) ; _mm_storeu_pd ( & obj -> grad [ i ] , _mm_add_pd ( tmp , _mm_loadu_pd ( & f [ i ] ) ) ) ; } for ( i = scalarLB ; i < ixlast ; i ++ ) { obj -> grad [ i ] += f [ i ] ; } } break ; case 4 : xgemv_e2rVE54U ( obj -> nvar , obj -> nvar , H , obj -> nvar , x , obj -> Hx ) ; ixlast = obj -> nvar + 1 ; scalarLB_tmp = ( ( 120 - obj -> nvar ) / 2 ) << 1 ; scalarLB = ( scalarLB_tmp + obj -> nvar ) + 1 ; vectorUB = scalarLB - 2 ; for ( i = ixlast ; i <= vectorUB ; i += 2 ) { _mm_storeu_pd ( & obj -> Hx [ i - 1 ] , _mm_mul_pd ( _mm_loadu_pd ( & x [ i - 1 ] ) , _mm_set1_pd ( obj -> beta ) ) ) ; } for ( i = scalarLB ; i < 121 ; i ++ ) { obj -> Hx [ i - 1 ] = x [ i - 1 ] * obj -> beta ; } memcpy ( & obj -> grad [ 0 ] , & obj -> Hx [ 0 ] , 120U * sizeof ( real_T ) ) ; if ( obj -> hasLinear && ( obj -> nvar >= 1 ) ) { ixlast = obj -> nvar ; scalarLB = ( obj -> nvar / 2 ) << 1 ; vectorUB = scalarLB - 2 ; for ( i = 0 ; i <= vectorUB ; i += 2 ) { tmp = _mm_loadu_pd ( & obj -> grad [ i ] ) ; _mm_storeu_pd ( & obj -> grad [ i ] , _mm_add_pd ( tmp , _mm_loadu_pd ( & f [ i ] ) ) ) ; } for ( i = scalarLB ; i < ixlast ; i ++ ) { obj -> grad [ i ] += f [ i ] ; } } if ( 120 - obj -> nvar >= 1 ) { ixlast = obj -> nvar ; scalarLB = 119 - obj -> nvar ; vectorUB = scalarLB_tmp - 2 ; for ( i = 0 ; i <= vectorUB ; i += 2 ) { tmp_p = ixlast + i ; tmp = _mm_loadu_pd ( & obj -> grad [ tmp_p ] ) ; _mm_storeu_pd ( & obj -> grad [ tmp_p ] , _mm_add_pd ( tmp , _mm_set1_pd ( obj -> rho ) ) ) ; } for ( i = scalarLB_tmp ; i <= scalarLB ; i ++ ) { tmp_p = ixlast + i ; obj -> grad [ tmp_p ] += obj -> rho ; } } break ; default : break ; } } static real_T ha4rdqgm4g ( const iamwnmrrfd * obj , real_T workspace [ 26741 ] , const real_T f [ 121 ] , const real_T x [ 121 ] ) { __m128d tmp ; real_T val ; real_T workspace_p ; int32_T ixlast ; int32_T k ; int32_T scalarLB ; int32_T vectorUB ; val = 0.0 ; switch ( obj -> objtype ) { case 5 : val = x [ obj -> nvar - 1 ] * obj -> gammaScalar ; break ; case 3 : if ( obj -> hasLinear ) { ixlast = obj -> nvar ; scalarLB = ( obj -> nvar / 2 ) << 1 ; vectorUB = scalarLB - 2 ; for ( k = 0 ; k <= vectorUB ; k += 2 ) { tmp = _mm_loadu_pd ( & obj -> Hx [ k ] ) ; _mm_storeu_pd ( & workspace [ k ] , _mm_add_pd ( _mm_mul_pd ( _mm_set1_pd ( 0.5 ) , tmp ) , _mm_loadu_pd ( & f [ k ] ) ) ) ; } for ( k = scalarLB ; k < ixlast ; k ++ ) { workspace [ k ] = 0.5 * obj -> Hx [ k ] + f [ k ] ; } if ( obj -> nvar >= 1 ) { ixlast = obj -> nvar ; for ( k = 0 ; k < ixlast ; k ++ ) { val += x [ k ] * workspace [ k ] ; } } } else { if ( obj -> nvar >= 1 ) { ixlast = obj -> nvar ; for ( k = 0 ; k < ixlast ; k ++ ) { val += x [ k ] * obj -> Hx [ k ] ; } } val *= 0.5 ; } break ; case 4 : if ( obj -> hasLinear ) { if ( obj -> nvar - 1 >= 0 ) { memcpy ( & workspace [ 0 ] , & f [ 0 ] , ( uint32_T ) obj -> nvar * sizeof ( real_T ) ) ; } ixlast = 120 - obj -> nvar ; for ( k = 0 ; k < ixlast ; k ++ ) { workspace [ obj -> nvar + k ] = obj -> rho ; } for ( k = 0 ; k < 120 ; k ++ ) { workspace_p = 0.5 * obj -> Hx [ k ] + workspace [ k ] ; workspace [ k ] = workspace_p ; val += x [ k ] * workspace_p ; } } else { for ( k = 0 ; k < 120 ; k ++ ) { val += x [ k ] * obj -> Hx [ k ] ; } val *= 0.5 ; ixlast = obj -> nvar + 1 ; for ( k = ixlast ; k < 121 ; k ++ ) { val += x [ k - 1 ] * obj -> rho ; } } break ; default : break ; } return val ; } static void b453z2zntr ( oytx5zapfu * obj , const real_T A [ 26741 ] , int32_T mrows , int32_T ncols ) { int32_T b ; int32_T idx ; int32_T ix0 ; int32_T iy0 ; int32_T k ; static const int32_T offsets [ 4 ] = { 0 , 1 , 2 , 3 } ; boolean_T guard1 ; idx = mrows * ncols ; guard1 = false ; if ( idx > 0 ) { for ( idx = 0 ; idx < ncols ; idx ++ ) { ix0 = 121 * idx ; iy0 = 221 * idx ; b = ( uint8_T ) mrows ; for ( k = 0 ; k < b ; k ++ ) { obj -> QR [ iy0 + k ] = A [ ix0 + k ] ; } } guard1 = true ; } else if ( idx == 0 ) { obj -> mrows = mrows ; obj -> ncols = ncols ; obj -> minRowCol = 0 ; } else { guard1 = true ; } if ( guard1 ) { obj -> usedPivoting = false ; obj -> mrows = mrows ; obj -> ncols = ncols ; k = ( ncols / 4 ) << 2 ; ix0 = k - 4 ; for ( idx = 0 ; idx <= ix0 ; idx += 4 ) { _mm_storeu_si128 ( ( __m128i * ) & obj -> jpvt [ idx ] , _mm_add_epi32 ( _mm_add_epi32 ( _mm_set1_epi32 ( idx ) , _mm_loadu_si128 ( ( const __m128i * ) & offsets [ 0 ] ) ) , _mm_set1_epi32 ( 1 ) ) ) ; } for ( idx = k ; idx < ncols ; idx ++ ) { obj -> jpvt [ idx ] = idx + 1 ; } obj -> minRowCol = muIntScalarMin_sint32 ( mrows , ncols ) ; xgeqrf_XRJGzhWP ( obj -> QR , mrows , ncols , obj -> tau ) ; } } static void lf2exsz2ex ( oytx5zapfu * obj , const real_T vec [ 26741 ] , int32_T iv0 ) { real_T b_c ; real_T s ; real_T temp ; real_T temp_tmp ; int32_T b_iy ; int32_T d ; int32_T e ; int32_T idxRotGCol ; int32_T iyend ; iyend = obj -> ncols + 1 ; obj -> minRowCol = muIntScalarMin_sint32 ( obj -> mrows , iyend ) ; b_iy = 221 * obj -> ncols ; if ( obj -> mrows != 0 ) { iyend = b_iy + obj -> mrows ; for ( idxRotGCol = b_iy + 1 ; idxRotGCol <= iyend ; idxRotGCol ++ ) { obj -> QR [ idxRotGCol - 1 ] = 0.0 ; } d = ( obj -> mrows - 1 ) * 221 + 1 ; for ( idxRotGCol = 1 ; idxRotGCol <= d ; idxRotGCol += 221 ) { b_c = 0.0 ; e = ( idxRotGCol + obj -> mrows ) - 1 ; for ( iyend = idxRotGCol ; iyend <= e ; iyend ++ ) { b_c += vec [ ( ( iv0 + iyend ) - idxRotGCol ) - 1 ] * obj -> Q [ iyend - 1 ] ; } iyend = div_nde_s32_floor ( idxRotGCol - 1 , 221 ) + b_iy ; obj -> QR [ iyend ] += b_c ; } } obj -> ncols ++ ; obj -> jpvt [ obj -> ncols - 1 ] = obj -> ncols ; for ( b_iy = obj -> mrows - 2 ; b_iy + 2 > obj -> ncols ; b_iy -- ) { e = ( obj -> ncols - 1 ) * 221 + b_iy ; temp = obj -> QR [ e + 1 ] ; xrotg_RoqvjOQy ( & obj -> QR [ e ] , & temp , & b_c , & s ) ; obj -> QR [ e + 1 ] = temp ; iyend = 221 * b_iy ; d = obj -> mrows ; if ( obj -> mrows >= 1 ) { for ( idxRotGCol = 0 ; idxRotGCol < d ; idxRotGCol ++ ) { e = iyend + idxRotGCol ; temp_tmp = obj -> Q [ e + 221 ] ; temp = temp_tmp * s + obj -> Q [ e ] * b_c ; obj -> Q [ e + 221 ] = temp_tmp * b_c - obj -> Q [ e ] * s ; obj -> Q [ e ] = temp ; } } } } static void cilnv2vgqh ( oytx5zapfu * obj , int32_T idx ) { real_T b_s ; real_T b_temp ; real_T b_temp_tmp_p ; real_T c_c ; int32_T QRk0 ; int32_T b_ix ; int32_T b_n ; int32_T b_temp_tmp ; int32_T i ; int32_T idxRotGCol ; int32_T idxRotGCol_tmp ; int32_T k ; if ( obj -> usedPivoting ) { i = 1 ; while ( ( i <= obj -> ncols ) && ( obj -> jpvt [ i - 1 ] != idx ) ) { i ++ ; } idx = i ; } if ( idx >= obj -> ncols ) { obj -> ncols -- ; } else { obj -> jpvt [ idx - 1 ] = obj -> jpvt [ obj -> ncols - 1 ] ; idxRotGCol = obj -> minRowCol ; for ( i = 0 ; i < idxRotGCol ; i ++ ) { obj -> QR [ i + 221 * ( idx - 1 ) ] = obj -> QR [ ( obj -> ncols - 1 ) * 221 + i ] ; } obj -> ncols -- ; obj -> minRowCol = muIntScalarMin_sint32 ( obj -> mrows , obj -> ncols ) ; if ( idx < obj -> mrows ) { idxRotGCol_tmp = obj -> mrows - 1 ; i = muIntScalarMin_sint32 ( idxRotGCol_tmp , obj -> ncols ) ; k = i ; idxRotGCol = ( idx - 1 ) * 221 ; while ( k >= idx ) { b_temp_tmp = k + idxRotGCol ; b_temp = obj -> QR [ b_temp_tmp ] ; xrotg_RoqvjOQy ( & obj -> QR [ b_temp_tmp - 1 ] , & b_temp , & c_c , & b_s ) ; obj -> QR [ b_temp_tmp ] = b_temp ; idxRotGCol_tmp = ( k - 1 ) * 221 ; obj -> QR [ k + idxRotGCol_tmp ] = 0.0 ; QRk0 = 221 * idx + k ; b_ix = obj -> ncols - idx ; if ( b_ix >= 1 ) { for ( b_n = 0 ; b_n < b_ix ; b_n ++ ) { b_temp_tmp = b_n * 221 + QRk0 ; b_temp_tmp_p = obj -> QR [ b_temp_tmp - 1 ] ; b_temp = b_temp_tmp_p * c_c + obj -> QR [ b_temp_tmp ] * b_s ; obj -> QR [ b_temp_tmp ] = obj -> QR [ b_temp_tmp ] * c_c - b_temp_tmp_p * b_s ; obj -> QR [ b_temp_tmp - 1 ] = b_temp ; } } b_ix = obj -> mrows ; if ( obj -> mrows >= 1 ) { for ( b_n = 0 ; b_n < b_ix ; b_n ++ ) { b_temp_tmp = idxRotGCol_tmp + b_n ; b_temp_tmp_p = obj -> Q [ b_temp_tmp + 221 ] ; b_temp = b_temp_tmp_p * b_s + obj -> Q [ b_temp_tmp ] * c_c ; obj -> Q [ b_temp_tmp + 221 ] = b_temp_tmp_p * c_c - obj -> Q [ b_temp_tmp ] * b_s ; obj -> Q [ b_temp_tmp ] = b_temp ; } } k -- ; } for ( k = idx + 1 ; k <= i ; k ++ ) { idxRotGCol_tmp = ( k - 1 ) * 221 ; b_temp_tmp = k + idxRotGCol_tmp ; b_temp = obj -> QR [ b_temp_tmp ] ; xrotg_RoqvjOQy ( & obj -> QR [ b_temp_tmp - 1 ] , & b_temp , & c_c , & b_s ) ; obj -> QR [ b_temp_tmp ] = b_temp ; QRk0 = k * 222 ; b_n = obj -> ncols - k ; if ( b_n >= 1 ) { for ( idxRotGCol = 0 ; idxRotGCol < b_n ; idxRotGCol ++ ) { b_temp_tmp = idxRotGCol * 221 + QRk0 ; b_temp = obj -> QR [ b_temp_tmp - 1 ] * c_c + obj -> QR [ b_temp_tmp ] * b_s ; obj -> QR [ b_temp_tmp ] = obj -> QR [ b_temp_tmp ] * c_c - obj -> QR [ b_temp_tmp - 1 ] * b_s ; obj -> QR [ b_temp_tmp - 1 ] = b_temp ; } } b_n = obj -> mrows ; if ( obj -> mrows >= 1 ) { for ( idxRotGCol = 0 ; idxRotGCol < b_n ; idxRotGCol ++ ) { b_temp_tmp = idxRotGCol_tmp + idxRotGCol ; b_temp = obj -> Q [ b_temp_tmp + 221 ] * b_s + obj -> Q [ b_temp_tmp ] * c_c ; obj -> Q [ b_temp_tmp + 221 ] = obj -> Q [ b_temp_tmp + 221 ] * c_c - obj -> Q [ b_temp_tmp ] * b_s ; obj -> Q [ b_temp_tmp ] = b_temp ; } } } } } } static void d2y4tsvypc ( oytx5zapfu * obj , int32_T nrows ) { __m128d tmp ; real_T work [ 221 ] ; real_T b_c ; int32_T c_ia ; int32_T coltop ; int32_T exitg1 ; int32_T f ; int32_T i ; int32_T iQR0 ; int32_T ia ; int32_T idx ; int32_T itau ; int32_T jy ; int32_T lastc ; boolean_T exitg2 ; lastc = obj -> minRowCol ; for ( idx = 0 ; idx < lastc ; idx ++ ) { iQR0 = 221 * idx + idx ; ia = obj -> mrows - idx ; if ( ia - 2 >= 0 ) { memcpy ( & obj -> Q [ iQR0 + 1 ] , & obj -> QR [ iQR0 + 1 ] , ( uint32_T ) ( ia - 1 ) * sizeof ( real_T ) ) ; } } idx = obj -> mrows ; if ( nrows >= 1 ) { for ( itau = lastc ; itau < nrows ; itau ++ ) { ia = itau * 221 ; for ( i = 0 ; i < idx ; i ++ ) { obj -> Q [ ia + i ] = 0.0 ; } obj -> Q [ ia + itau ] = 1.0 ; } itau = obj -> minRowCol - 1 ; for ( i = 0 ; i < 221 ; i ++ ) { work [ i ] = 0.0 ; } for ( i = obj -> minRowCol ; i >= 1 ; i -- ) { iQR0 = ( ( i - 1 ) * 221 + i ) - 1 ; if ( i < nrows ) { obj -> Q [ iQR0 ] = 1.0 ; ia = idx - i ; if ( obj -> tau [ itau ] != 0.0 ) { lastc = iQR0 + ia ; while ( ( ia + 1 > 0 ) && ( obj -> Q [ lastc ] == 0.0 ) ) { ia -- ; lastc -- ; } lastc = ( nrows - i ) - 1 ; exitg2 = false ; while ( ( ! exitg2 ) && ( lastc + 1 > 0 ) ) { coltop = ( lastc * 221 + iQR0 ) + 222 ; c_ia = coltop ; do { exitg1 = 0 ; if ( c_ia <= coltop + ia ) { if ( obj -> Q [ c_ia - 1 ] != 0.0 ) { exitg1 = 1 ; } else { c_ia ++ ; } } else { lastc -- ; exitg1 = 2 ; } } while ( exitg1 == 0 ) ; if ( exitg1 == 1 ) { exitg2 = true ; } } } else { ia = - 1 ; lastc = - 1 ; } if ( ia + 1 > 0 ) { if ( lastc + 1 != 0 ) { for ( coltop = 0 ; coltop <= lastc ; coltop ++ ) { work [ coltop ] = 0.0 ; } jy = ( 221 * lastc + iQR0 ) + 222 ; for ( coltop = iQR0 + 222 ; coltop <= jy ; coltop += 221 ) { b_c = 0.0 ; f = coltop + ia ; for ( c_ia = coltop ; c_ia <= f ; c_ia ++ ) { b_c += obj -> Q [ ( iQR0 + c_ia ) - coltop ] * obj -> Q [ c_ia - 1 ] ; } c_ia = div_nde_s32_floor ( ( coltop - iQR0 ) - 222 , 221 ) ; work [ c_ia ] += b_c ; } } if ( ! ( - obj -> tau [ itau ] == 0.0 ) ) { jy = iQR0 + 222 ; for ( coltop = 0 ; coltop <= lastc ; coltop ++ ) { b_c = work [ coltop ] ; if ( b_c != 0.0 ) { b_c *= - obj -> tau [ itau ] ; f = ia + jy ; for ( c_ia = jy ; c_ia <= f ; c_ia ++ ) { obj -> Q [ c_ia - 1 ] += obj -> Q [ ( iQR0 + c_ia ) - jy ] * b_c ; } } jy += 221 ; } } } } if ( i < idx ) { lastc = ( ( iQR0 + idx ) - i ) + 1 ; coltop = ( ( ( ( ( lastc - iQR0 ) - 1 ) / 2 ) << 1 ) + iQR0 ) + 2 ; c_ia = coltop - 2 ; for ( ia = iQR0 + 2 ; ia <= c_ia ; ia += 2 ) { tmp = _mm_loadu_pd ( & obj -> Q [ ia - 1 ] ) ; _mm_storeu_pd ( & obj -> Q [ ia - 1 ] , _mm_mul_pd ( tmp , _mm_set1_pd ( - obj -> tau [ itau ] ) ) ) ; } for ( ia = coltop ; ia <= lastc ; ia ++ ) { obj -> Q [ ia - 1 ] *= - obj -> tau [ itau ] ; } } obj -> Q [ iQR0 ] = 1.0 - obj -> tau [ itau ] ; lastc = ( uint8_T ) ( i - 1 ) ; for ( ia = 0 ; ia < lastc ; ia ++ ) { obj -> Q [ ( iQR0 - ia ) - 1 ] = 0.0 ; } itau -- ; } } } static boolean_T k1a0kvuk51 ( const char_T a [ 7 ] ) { int32_T ret ; static const char_T b_b [ 7 ] = { 'f' , 'm' , 'i' , 'n' , 'c' , 'o' , 'n' } ; ret = memcmp ( & a [ 0 ] , & b_b [ 0 ] , 7 ) ; return ret == 0 ; } static void nl2ovhgzvl ( kzv4ftj4e2 * obj , int32_T LD_offset , int32_T NColsRemain ) { __m128d tmp ; real_T alpha1 ; real_T temp ; real_T y ; int32_T LD_diagOffset ; int32_T b ; int32_T b_k ; int32_T ijA ; int32_T jA ; int32_T k ; int32_T scalarLB ; int32_T subMatrixDim ; int32_T vectorUB ; for ( k = 0 ; k < NColsRemain ; k ++ ) { LD_diagOffset = 222 * k + LD_offset ; alpha1 = - 1.0 / obj -> FMat [ LD_diagOffset - 1 ] ; subMatrixDim = ( NColsRemain - k ) - 2 ; for ( b_k = 0 ; b_k <= subMatrixDim ; b_k ++ ) { obj -> workspace_ = obj -> FMat [ LD_diagOffset + b_k ] ; } y = obj -> workspace_ ; if ( ! ( alpha1 == 0.0 ) ) { jA = LD_diagOffset + 222 ; for ( b_k = 0 ; b_k <= subMatrixDim ; b_k ++ ) { if ( y != 0.0 ) { temp = y * alpha1 ; b = subMatrixDim + jA ; scalarLB = ( ( ( ( b - jA ) + 1 ) / 2 ) << 1 ) + jA ; vectorUB = scalarLB - 2 ; for ( ijA = jA ; ijA <= vectorUB ; ijA += 2 ) { tmp = _mm_loadu_pd ( & obj -> FMat [ ijA - 1 ] ) ; _mm_storeu_pd ( & obj -> FMat [ ijA - 1 ] , _mm_add_pd ( tmp , _mm_set1_pd ( obj -> workspace_ * temp ) ) ) ; } for ( ijA = scalarLB ; ijA <= b ; ijA ++ ) { obj -> FMat [ ijA - 1 ] += obj -> workspace_ * temp ; } } jA += 221 ; } } alpha1 = 1.0 / obj -> FMat [ LD_diagOffset - 1 ] ; b_k = ( LD_diagOffset + subMatrixDim ) + 1 ; scalarLB = ( ( ( ( b_k - LD_diagOffset ) / 2 ) << 1 ) + LD_diagOffset ) + 1 ; vectorUB = scalarLB - 2 ; for ( subMatrixDim = LD_diagOffset + 1 ; subMatrixDim <= vectorUB ; subMatrixDim += 2 ) { tmp = _mm_loadu_pd ( & obj -> FMat [ subMatrixDim - 1 ] ) ; _mm_storeu_pd ( & obj -> FMat [ subMatrixDim - 1 ] , _mm_mul_pd ( tmp , _mm_set1_pd ( alpha1 ) ) ) ; } for ( subMatrixDim = scalarLB ; subMatrixDim <= b_k ; subMatrixDim ++ ) { obj -> FMat [ subMatrixDim - 1 ] *= alpha1 ; } } } static void bgcgohintf ( kzv4ftj4e2 * obj , int32_T LD_offset , int32_T NColsRemain ) { __m128d tmp ; real_T b_y ; real_T obj_workspace2_ ; int32_T FMat_offset ; int32_T LD_diagOffset ; int32_T b_idx ; int32_T br ; int32_T f ; int32_T idx ; int32_T ix ; int32_T k ; int32_T scalarLB ; int32_T subRows ; int32_T vectorUB ; for ( k = 0 ; k < 48 ; k ++ ) { subRows = ( NColsRemain - k ) - 1 ; LD_diagOffset = ( 222 * k + LD_offset ) - 1 ; for ( b_idx = 0 ; b_idx <= subRows ; b_idx ++ ) { obj -> workspace_ = obj -> FMat [ LD_diagOffset + b_idx ] ; } for ( b_idx = 0 ; b_idx < NColsRemain ; b_idx ++ ) { obj -> workspace2_ = obj -> workspace_ ; } b_y = obj -> workspace2_ ; if ( ( NColsRemain != 0 ) && ( k != 0 ) ) { ix = LD_offset + k ; FMat_offset = ( k - 1 ) * 221 + 1 ; for ( b_idx = 1 ; b_idx <= FMat_offset ; b_idx += 221 ) { br = b_idx + NColsRemain ; for ( idx = b_idx ; idx < br ; idx ++ ) { b_y += - obj -> FMat [ ix - 1 ] * obj -> workspace_ ; } ix += 221 ; } } obj -> workspace2_ = b_y ; for ( b_idx = 0 ; b_idx < NColsRemain ; b_idx ++ ) { obj -> workspace_ = b_y ; } for ( b_idx = 0 ; b_idx <= subRows ; b_idx ++ ) { obj -> FMat [ LD_diagOffset + b_idx ] = obj -> workspace_ ; } scalarLB = ( subRows / 2 ) << 1 ; vectorUB = scalarLB - 2 ; for ( b_idx = 0 ; b_idx <= vectorUB ; b_idx += 2 ) { ix = ( b_idx + LD_diagOffset ) + 1 ; tmp = _mm_loadu_pd ( & obj -> FMat [ ix ] ) ; _mm_storeu_pd ( & obj -> FMat [ ix ] , _mm_div_pd ( tmp , _mm_set1_pd ( obj -> FMat [ LD_diagOffset ] ) ) ) ; } for ( b_idx = scalarLB ; b_idx < subRows ; b_idx ++ ) { ix = ( b_idx + LD_diagOffset ) + 1 ; obj -> FMat [ ix ] /= obj -> FMat [ LD_diagOffset ] ; } } for ( k = 48 ; k <= NColsRemain - 1 ; k += 48 ) { b_idx = NColsRemain - k ; subRows = muIntScalarMin_sint32 ( 48 , b_idx ) ; scalarLB = k + subRows ; for ( LD_diagOffset = k ; LD_diagOffset < scalarLB ; LD_diagOffset ++ ) { idx = scalarLB - LD_diagOffset ; for ( ix = 0 ; ix < 48 ; ix ++ ) { obj_workspace2_ = obj -> FMat [ ( ( LD_offset + LD_diagOffset ) + ix * 221 ) - 1 ] ; } obj -> workspace2_ = obj_workspace2_ ; if ( idx != 0 ) { for ( ix = LD_diagOffset + 1 ; ix <= LD_diagOffset + 10388 ; ix += 221 ) { br = ix + idx ; for ( FMat_offset = ix ; FMat_offset < br ; FMat_offset ++ ) { } } } } if ( scalarLB < NColsRemain ) { LD_diagOffset = b_idx - subRows ; b_idx = ( ( LD_offset + subRows ) + 222 * k ) - 1 ; for ( idx = 0 ; idx < 48 ; idx ++ ) { FMat_offset = ( LD_offset + k ) + idx * 221 ; for ( ix = 0 ; ix < subRows ; ix ++ ) { obj -> workspace2_ = obj -> FMat [ ( FMat_offset + ix ) - 1 ] ; } } if ( ( LD_diagOffset != 0 ) && ( subRows != 0 ) ) { FMat_offset = ( subRows - 1 ) * 221 + b_idx ; br = 0 ; for ( subRows = b_idx ; subRows <= FMat_offset ; subRows += 221 ) { br ++ ; for ( idx = br ; idx <= br + 10387 ; idx += 221 ) { f = subRows + LD_diagOffset ; scalarLB = ( ( ( ( f - subRows ) / 2 ) << 1 ) + subRows ) + 1 ; vectorUB = scalarLB - 2 ; for ( ix = subRows + 1 ; ix <= vectorUB ; ix += 2 ) { tmp = _mm_loadu_pd ( & obj -> FMat [ ix - 1 ] ) ; _mm_storeu_pd ( & obj -> FMat [ ix - 1 ] , _mm_add_pd ( tmp , _mm_set1_pd ( - obj -> workspace2_ * obj -> workspace_ ) ) ) ; } for ( ix = scalarLB ; ix <= f ; ix ++ ) { obj -> FMat [ ix - 1 ] += - obj -> workspace2_ * obj -> workspace_ ; } } } } } } } static void a554y4lhjz0 ( kzv4ftj4e2 * obj , const real_T A [ 676 ] , int32_T ndims , int32_T ldA ) { real_T s ; real_T smax ; int32_T A_maxDiag_idx ; int32_T exitg2 ; int32_T ix ; int32_T iy0 ; int32_T k ; boolean_T exitg1 ; obj -> ndims = ndims ; for ( k = 0 ; k < ndims ; k ++ ) { ix = ldA * k ; iy0 = 221 * k ; for ( A_maxDiag_idx = 0 ; A_maxDiag_idx < ndims ; A_maxDiag_idx ++ ) { obj -> FMat [ iy0 + A_maxDiag_idx ] = A [ A_maxDiag_idx + ix ] ; } } if ( ndims < 1 ) { A_maxDiag_idx = - 1 ; } else { A_maxDiag_idx = 0 ; if ( ndims > 1 ) { smax = muDoubleScalarAbs ( obj -> FMat [ 0 ] ) ; for ( k = 2 ; k <= ndims ; k ++ ) { s = muDoubleScalarAbs ( obj -> FMat [ ( k - 1 ) * 222 ] ) ; if ( s > smax ) { A_maxDiag_idx = k - 1 ; smax = s ; } } } } obj -> regTol_ = muDoubleScalarMax ( muDoubleScalarAbs ( obj -> FMat [ 221 * A_maxDiag_idx + A_maxDiag_idx ] ) * 2.2204460492503131E-16 , 0.0 ) ; if ( ndims > 128 ) { k = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( k < ndims ) ) { A_maxDiag_idx = 222 * k + 1 ; ix = ndims - k ; if ( k + 48 <= ndims ) { bgcgohintf ( obj , A_maxDiag_idx , ix ) ; k += 48 ; } else { nl2ovhgzvl ( obj , A_maxDiag_idx , ix ) ; exitg1 = true ; } } } else { nl2ovhgzvl ( obj , 1 , ndims ) ; } if ( obj -> ConvexCheck ) { k = 0 ; do { exitg2 = 0 ; if ( k <= ndims - 1 ) { if ( obj -> FMat [ 221 * k + k ] <= 0.0 ) { obj -> info = - k - 1 ; exitg2 = 1 ; } else { k ++ ; } } else { obj -> ConvexCheck = false ; exitg2 = 1 ; } } while ( exitg2 == 0 ) ; } } static void a554y4lhjz ( kzv4ftj4e2 * obj , const real_T A [ 676 ] , int32_T ndims , int32_T ldA ) { int32_T b_k ; int32_T idx ; int32_T ix0 ; int32_T iy0 ; obj -> ndims = ndims ; for ( idx = 0 ; idx < ndims ; idx ++ ) { ix0 = ldA * idx ; iy0 = 221 * idx ; for ( b_k = 0 ; b_k < ndims ; b_k ++ ) { obj -> FMat [ iy0 + b_k ] = A [ b_k + ix0 ] ; } } obj -> info = xpotrf_3B98IbMt ( ndims , obj -> FMat ) ; } static void l5vh2m5twz ( const kzv4ftj4e2 * obj , real_T rhs [ 121 ] ) { real_T temp ; int32_T i ; int32_T ix ; int32_T j ; int32_T jA ; int32_T n_tmp ; n_tmp = obj -> ndims ; if ( obj -> ndims != 0 ) { for ( j = 0 ; j < n_tmp ; j ++ ) { jA = j * 221 ; temp = rhs [ j ] ; for ( i = 0 ; i < j ; i ++ ) { temp -= obj -> FMat [ jA + i ] * rhs [ i ] ; } rhs [ j ] = temp / obj -> FMat [ jA + j ] ; } for ( j = n_tmp ; j >= 1 ; j -- ) { jA = ( ( j - 1 ) * 221 + j ) - 2 ; rhs [ j - 1 ] /= obj -> FMat [ jA + 1 ] ; for ( i = 0 ; i <= j - 2 ; i ++ ) { ix = ( j - i ) - 2 ; rhs [ ix ] -= rhs [ j - 1 ] * obj -> FMat [ jA - i ] ; } } } } static void l5vh2m5twza ( const kzv4ftj4e2 * obj , real_T rhs [ 121 ] ) { real_T temp ; int32_T b_i ; int32_T b_j ; int32_T c ; int32_T ix ; int32_T jjA ; int32_T n_tmp ; n_tmp = obj -> ndims ; if ( obj -> ndims != 0 ) { for ( b_j = 0 ; b_j < n_tmp ; b_j ++ ) { jjA = b_j * 221 + b_j ; c = ( n_tmp - b_j ) - 2 ; for ( b_i = 0 ; b_i <= c ; b_i ++ ) { ix = ( b_i + b_j ) + 1 ; rhs [ ix ] -= obj -> FMat [ ( b_i + jjA ) + 1 ] * rhs [ b_j ] ; } } } for ( b_j = 0 ; b_j < n_tmp ; b_j ++ ) { rhs [ b_j ] /= obj -> FMat [ 221 * b_j + b_j ] ; } if ( obj -> ndims != 0 ) { for ( b_j = n_tmp ; b_j >= 1 ; b_j -- ) { jjA = ( b_j - 1 ) * 221 ; temp = rhs [ b_j - 1 ] ; for ( b_i = n_tmp ; b_i >= b_j + 1 ; b_i -- ) { temp -= obj -> FMat [ ( jjA + b_i ) - 1 ] * rhs [ b_i - 1 ] ; } rhs [ b_j - 1 ] = temp ; } } } static void fhnd1v2j0m ( const real_T H [ 676 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , const oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , const iamwnmrrfd * objective , boolean_T alwaysPositiveDef ) { __m128d tmp ; real_T s ; real_T smax ; int32_T b_nullStart ; int32_T c_ix ; int32_T exitg2 ; int32_T mNull ; int32_T nVar ; int32_T nVars ; int32_T nullStart ; int32_T nullStartIdx ; int32_T vectorUB ; boolean_T exitg1 ; nVar = qrmanager -> mrows - 1 ; mNull = qrmanager -> mrows - qrmanager -> ncols ; if ( mNull <= 0 ) { for ( mNull = 0 ; mNull <= nVar ; mNull ++ ) { solution -> searchDir [ mNull ] = 0.0 ; } } else { nullStart = ( qrmanager -> mrows / 2 ) << 1 ; vectorUB = nullStart - 2 ; for ( nullStartIdx = 0 ; nullStartIdx <= vectorUB ; nullStartIdx += 2 ) { tmp = _mm_loadu_pd ( & objective -> grad [ nullStartIdx ] ) ; _mm_storeu_pd ( & solution -> searchDir [ nullStartIdx ] , _mm_mul_pd ( tmp , _mm_set1_pd ( - 1.0 ) ) ) ; } for ( nullStartIdx = nullStart ; nullStartIdx <= nVar ; nullStartIdx ++ ) { solution -> searchDir [ nullStartIdx ] = - objective -> grad [ nullStartIdx ] ; } if ( qrmanager -> ncols <= 0 ) { switch ( objective -> objtype ) { case 5 : break ; case 3 : if ( alwaysPositiveDef ) { a554y4lhjz ( cholmanager , H , qrmanager -> mrows , qrmanager -> mrows ) ; } else { a554y4lhjz0 ( cholmanager , H , qrmanager -> mrows , qrmanager -> mrows ) ; } if ( cholmanager -> info != 0 ) { solution -> state = - 6 ; } else if ( alwaysPositiveDef ) { l5vh2m5twz ( cholmanager , solution -> searchDir ) ; } else { l5vh2m5twza ( cholmanager , solution -> searchDir ) ; } break ; case 4 : if ( alwaysPositiveDef ) { a554y4lhjz ( cholmanager , H , objective -> nvar , objective -> nvar ) ; if ( cholmanager -> info != 0 ) { solution -> state = - 6 ; } else { l5vh2m5twz ( cholmanager , solution -> searchDir ) ; smax = 1.0 / objective -> beta ; nullStartIdx = objective -> nvar + 1 ; nVar = qrmanager -> mrows ; nullStart = ( ( ( ( qrmanager -> mrows - objective -> nvar ) / 2 ) << 1 ) + objective -> nvar ) + 1 ; vectorUB = nullStart - 2 ; for ( mNull = nullStartIdx ; mNull <= vectorUB ; mNull += 2 ) { tmp = _mm_loadu_pd ( & solution -> searchDir [ mNull - 1 ] ) ; _mm_storeu_pd ( & solution -> searchDir [ mNull - 1 ] , _mm_mul_pd ( tmp , _mm_set1_pd ( smax ) ) ) ; } for ( mNull = nullStart ; mNull <= nVar ; mNull ++ ) { solution -> searchDir [ mNull - 1 ] *= smax ; } } } break ; default : break ; } } else { vectorUB = 221 * qrmanager -> ncols + 1 ; if ( objective -> objtype == 5 ) { for ( nullStartIdx = 0 ; nullStartIdx < mNull ; nullStartIdx ++ ) { memspace -> workspace_float [ nullStartIdx ] = - qrmanager -> Q [ ( qrmanager -> ncols + nullStartIdx ) * 221 + nVar ] ; } xgemv_o71yBVcy ( qrmanager -> mrows , mNull , qrmanager -> Q , vectorUB , memspace -> workspace_float , solution -> searchDir ) ; } else { if ( objective -> objtype == 3 ) { xgemm_hPCPNDMQ ( qrmanager -> mrows , mNull , qrmanager -> mrows , H , qrmanager -> mrows , qrmanager -> Q , vectorUB , memspace -> workspace_float ) ; xgemm_A838MKtE ( mNull , mNull , qrmanager -> mrows , qrmanager -> Q , vectorUB , memspace -> workspace_float , cholmanager -> FMat ) ; } else if ( alwaysPositiveDef ) { nVars = qrmanager -> mrows ; xgemm_hPCPNDMQ ( objective -> nvar , mNull , objective -> nvar , H , objective -> nvar , qrmanager -> Q , vectorUB , memspace -> workspace_float ) ; for ( nullStartIdx = 0 ; nullStartIdx < mNull ; nullStartIdx ++ ) { b_nullStart = objective -> nvar + 1 ; for ( nullStart = b_nullStart ; nullStart <= nVars ; nullStart ++ ) { memspace -> workspace_float [ ( nullStart + 221 * nullStartIdx ) - 1 ] = qrmanager -> Q [ ( ( nullStartIdx + qrmanager -> ncols ) * 221 + nullStart ) - 1 ] * objective -> beta ; } } xgemm_A838MKtE ( mNull , mNull , qrmanager -> mrows , qrmanager -> Q , vectorUB , memspace -> workspace_float , cholmanager -> FMat ) ; } if ( alwaysPositiveDef ) { cholmanager -> ndims = mNull ; cholmanager -> info = xpotrf_3B98IbMt ( mNull , cholmanager -> FMat ) ; } else { cholmanager -> ndims = mNull ; nullStart = 0 ; if ( mNull > 1 ) { smax = muDoubleScalarAbs ( cholmanager -> FMat [ 0 ] ) ; for ( nullStartIdx = 2 ; nullStartIdx <= mNull ; nullStartIdx ++ ) { s = muDoubleScalarAbs ( cholmanager -> FMat [ ( nullStartIdx - 1 ) * 222 ] ) ; if ( s > smax ) { nullStart = nullStartIdx - 1 ; smax = s ; } } } cholmanager -> regTol_ = muDoubleScalarMax ( muDoubleScalarAbs ( cholmanager -> FMat [ 221 * nullStart + nullStart ] ) * 2.2204460492503131E-16 , 0.0 ) ; if ( mNull > 128 ) { nullStartIdx = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( nullStartIdx < mNull ) ) { nullStart = 222 * nullStartIdx + 1 ; nVars = mNull - nullStartIdx ; if ( nullStartIdx + 48 <= mNull ) { bgcgohintf ( cholmanager , nullStart , nVars ) ; nullStartIdx += 48 ; } else { nl2ovhgzvl ( cholmanager , nullStart , nVars ) ; exitg1 = true ; } } } else { nl2ovhgzvl ( cholmanager , 1 , mNull ) ; } if ( cholmanager -> ConvexCheck ) { nullStartIdx = 0 ; do { exitg2 = 0 ; if ( nullStartIdx <= mNull - 1 ) { if ( cholmanager -> FMat [ 221 * nullStartIdx + nullStartIdx ] <= 0.0 ) { cholmanager -> info = - nullStartIdx - 1 ; exitg2 = 1 ; } else { nullStartIdx ++ ; } } else { cholmanager -> ConvexCheck = false ; exitg2 = 1 ; } } while ( exitg2 == 0 ) ; } } if ( cholmanager -> info != 0 ) { solution -> state = - 6 ; } else { if ( qrmanager -> mrows != 0 ) { for ( nullStartIdx = 0 ; nullStartIdx < mNull ; nullStartIdx ++ ) { memspace -> workspace_float [ nullStartIdx ] = 0.0 ; } nVars = ( mNull - 1 ) * 221 + vectorUB ; for ( nullStartIdx = vectorUB ; nullStartIdx <= nVars ; nullStartIdx += 221 ) { smax = 0.0 ; b_nullStart = nullStartIdx + nVar ; for ( nullStart = nullStartIdx ; nullStart <= b_nullStart ; nullStart ++ ) { smax += qrmanager -> Q [ nullStart - 1 ] * objective -> grad [ nullStart - nullStartIdx ] ; } nullStart = div_nde_s32_floor ( nullStartIdx - vectorUB , 221 ) ; memspace -> workspace_float [ nullStart ] -= smax ; } } if ( alwaysPositiveDef ) { nullStart = cholmanager -> ndims ; if ( cholmanager -> ndims != 0 ) { for ( nVar = 0 ; nVar < nullStart ; nVar ++ ) { nVars = nVar * 221 ; smax = memspace -> workspace_float [ nVar ] ; for ( nullStartIdx = 0 ; nullStartIdx < nVar ; nullStartIdx ++ ) { smax -= cholmanager -> FMat [ nVars + nullStartIdx ] * memspace -> workspace_float [ nullStartIdx ] ; } memspace -> workspace_float [ nVar ] = smax / cholmanager -> FMat [ nVars + nVar ] ; } } if ( cholmanager -> ndims != 0 ) { for ( nVar = nullStart ; nVar >= 1 ; nVar -- ) { nVars = ( ( nVar - 1 ) * 221 + nVar ) - 2 ; memspace -> workspace_float [ nVar - 1 ] /= cholmanager -> FMat [ nVars + 1 ] ; for ( nullStartIdx = 0 ; nullStartIdx <= nVar - 2 ; nullStartIdx ++ ) { b_nullStart = ( nVar - nullStartIdx ) - 2 ; memspace -> workspace_float [ b_nullStart ] -= memspace -> workspace_float [ nVar - 1 ] * cholmanager -> FMat [ nVars - nullStartIdx ] ; } } } } else { nullStart = cholmanager -> ndims ; if ( cholmanager -> ndims != 0 ) { for ( nVar = 0 ; nVar < nullStart ; nVar ++ ) { nVars = nVar * 221 + nVar ; b_nullStart = ( nullStart - nVar ) - 2 ; for ( nullStartIdx = 0 ; nullStartIdx <= b_nullStart ; nullStartIdx ++ ) { c_ix = ( nullStartIdx + nVar ) + 1 ; memspace -> workspace_float [ c_ix ] -= cholmanager -> FMat [ ( nullStartIdx + nVars ) + 1 ] * memspace -> workspace_float [ nVar ] ; } } } for ( nVar = 0 ; nVar < nullStart ; nVar ++ ) { memspace -> workspace_float [ nVar ] /= cholmanager -> FMat [ 221 * nVar + nVar ] ; } if ( cholmanager -> ndims != 0 ) { for ( nVar = nullStart ; nVar >= 1 ; nVar -- ) { nVars = ( nVar - 1 ) * 221 ; smax = memspace -> workspace_float [ nVar - 1 ] ; for ( nullStartIdx = nullStart ; nullStartIdx >= nVar + 1 ; nullStartIdx -- ) { smax -= cholmanager -> FMat [ ( nVars + nullStartIdx ) - 1 ] * memspace -> workspace_float [ nullStartIdx - 1 ] ; } memspace -> workspace_float [ nVar - 1 ] = smax ; } } } xgemv_o71yBVcy ( qrmanager -> mrows , mNull , qrmanager -> Q , vectorUB , memspace -> workspace_float , solution -> searchDir ) ; } } } } } static void diz55ngdn0 ( const real_T solution_xstar [ 121 ] , const real_T solution_searchDir [ 121 ] , real_T workspace [ 26741 ] , int32_T workingset_nVar , const real_T workingset_Aineq [ 6534 ] , const real_T workingset_bineq [ 54 ] , const real_T workingset_lb [ 121 ] , const real_T workingset_ub [ 121 ] , const int32_T workingset_indexLB [ 121 ] , const int32_T workingset_indexUB [ 121 ] , const int32_T workingset_sizes [ 5 ] , const int32_T workingset_isActiveIdx [ 6 ] , const boolean_T workingset_isActiveConstr [ 221 ] , const int32_T workingset_nWConstr [ 5 ] , boolean_T isPhaseOne , real_T * alpha , boolean_T * newBlocking , int32_T * constrType , int32_T * constrIdx ) { real_T tmp [ 2 ] ; real_T alphaTemp ; real_T b_c ; real_T denomTol ; real_T phaseOneCorrectionP ; real_T ratio ; int32_T d ; int32_T ia ; int32_T k ; * alpha = 1.0E+30 ; * newBlocking = false ; * constrType = 0 ; * constrIdx = 0 ; denomTol = 2.2204460492503131E-13 * xnrm2_zbVenBlk ( workingset_nVar , solution_searchDir ) ; if ( workingset_nWConstr [ 2 ] < 54 ) { memcpy ( & workspace [ 0 ] , & workingset_bineq [ 0 ] , 54U * sizeof ( real_T ) ) ; xgemv_FKeSanhE ( workingset_nVar , workingset_Aineq , solution_xstar , workspace ) ; for ( k = 0 ; k < 54 ; k ++ ) { workspace [ k + 221 ] = 0.0 ; } for ( k = 0 ; k <= 6413 ; k += 121 ) { b_c = 0.0 ; d = k + workingset_nVar ; for ( ia = k + 1 ; ia <= d ; ia ++ ) { b_c += solution_searchDir [ ( ia - k ) - 1 ] * workingset_Aineq [ ia - 1 ] ; } ia = div_nde_s32_floor ( k , 121 ) + 221 ; workspace [ ia ] += b_c ; } for ( k = 0 ; k < 54 ; k ++ ) { ratio = workspace [ k + 221 ] ; if ( ( ratio > denomTol ) && ( ! workingset_isActiveConstr [ ( workingset_isActiveIdx [ 2 ] + k ) - 1 ] ) ) { b_c = workspace [ k ] ; alphaTemp = muDoubleScalarMin ( muDoubleScalarAbs ( b_c ) , 1.0E-6 - b_c ) / ratio ; if ( alphaTemp < * alpha ) { * alpha = alphaTemp ; * constrType = 3 ; * constrIdx = k + 1 ; * newBlocking = true ; } } } } if ( workingset_nWConstr [ 3 ] < workingset_sizes [ 3 ] ) { _mm_storeu_pd ( & tmp [ 0 ] , _mm_mul_pd ( _mm_set_pd ( solution_searchDir [ workingset_nVar - 1 ] , solution_xstar [ workingset_nVar - 1 ] ) , _mm_set1_pd ( isPhaseOne ) ) ) ; b_c = tmp [ 0 ] ; phaseOneCorrectionP = tmp [ 1 ] ; ia = workingset_sizes [ 3 ] ; for ( k = 0 ; k <= ia - 2 ; k ++ ) { d = workingset_indexLB [ k ] ; alphaTemp = - solution_searchDir [ d - 1 ] - phaseOneCorrectionP ; if ( ( alphaTemp > denomTol ) && ( ! workingset_isActiveConstr [ ( workingset_isActiveIdx [ 3 ] + k ) - 1 ] ) ) { ratio = ( - solution_xstar [ d - 1 ] - workingset_lb [ d - 1 ] ) - b_c ; alphaTemp = muDoubleScalarMin ( muDoubleScalarAbs ( ratio ) , 1.0E-6 - ratio ) / alphaTemp ; if ( alphaTemp < * alpha ) { * alpha = alphaTemp ; * constrType = 4 ; * constrIdx = k + 1 ; * newBlocking = true ; } } } ia = workingset_indexLB [ workingset_sizes [ 3 ] - 1 ] - 1 ; b_c = - solution_searchDir [ ia ] ; if ( ( b_c > denomTol ) && ( ! workingset_isActiveConstr [ ( workingset_isActiveIdx [ 3 ] + workingset_sizes [ 3 ] ) - 2 ] ) ) { ratio = - solution_xstar [ ia ] - workingset_lb [ ia ] ; alphaTemp = muDoubleScalarMin ( muDoubleScalarAbs ( ratio ) , 1.0E-6 - ratio ) / b_c ; if ( alphaTemp < * alpha ) { * alpha = alphaTemp ; * constrType = 4 ; * constrIdx = workingset_sizes [ 3 ] ; * newBlocking = true ; } } } if ( workingset_nWConstr [ 4 ] < workingset_sizes [ 4 ] ) { _mm_storeu_pd ( & tmp [ 0 ] , _mm_mul_pd ( _mm_set_pd ( solution_searchDir [ workingset_nVar - 1 ] , solution_xstar [ workingset_nVar - 1 ] ) , _mm_set1_pd ( isPhaseOne ) ) ) ; b_c = tmp [ 0 ] ; phaseOneCorrectionP = tmp [ 1 ] ; ia = ( uint8_T ) workingset_sizes [ 4 ] ; for ( k = 0 ; k < ia ; k ++ ) { d = workingset_indexUB [ k ] ; alphaTemp = solution_searchDir [ d - 1 ] - phaseOneCorrectionP ; if ( ( alphaTemp > denomTol ) && ( ! workingset_isActiveConstr [ ( workingset_isActiveIdx [ 4 ] + k ) - 1 ] ) ) { ratio = ( solution_xstar [ d - 1 ] - workingset_ub [ d - 1 ] ) - b_c ; alphaTemp = muDoubleScalarMin ( muDoubleScalarAbs ( ratio ) , 1.0E-6 - ratio ) / alphaTemp ; if ( alphaTemp < * alpha ) { * alpha = alphaTemp ; * constrType = 5 ; * constrIdx = k + 1 ; * newBlocking = true ; } } } } if ( ! isPhaseOne ) { * newBlocking = ( ( ( ! * newBlocking ) || ( ! ( * alpha > 1.0 ) ) ) && ( * newBlocking ) ) ; * alpha = muDoubleScalarMin ( * alpha , 1.0 ) ; } } static void gg30krxp5f ( real_T workspace [ 26741 ] , ci1jcnwvc5 * solution , const iamwnmrrfd * objective , const oytx5zapfu * qrmanager ) { __m128d tmp ; real_T c ; int32_T b_idx ; int32_T idxQR ; int32_T ix ; int32_T jjA ; int32_T nActiveConstr_tmp_tmp ; boolean_T guard1 ; boolean_T guard2 ; boolean_T nonDegenerate ; nActiveConstr_tmp_tmp = qrmanager -> ncols ; if ( qrmanager -> ncols > 0 ) { guard1 = false ; if ( objective -> objtype != 4 ) { c = muDoubleScalarMin ( 1.4901161193847656E-8 , 2.2204460492503131E-15 * ( real_T ) muIntScalarMax_sint32 ( qrmanager -> mrows , qrmanager -> ncols ) ) ; nonDegenerate = ( ( qrmanager -> mrows > 0 ) && ( qrmanager -> ncols > 0 ) ) ; if ( nonDegenerate ) { b_idx = qrmanager -> ncols ; guard2 = false ; if ( qrmanager -> mrows < qrmanager -> ncols ) { idxQR = ( qrmanager -> ncols - 1 ) * 221 + qrmanager -> mrows ; while ( ( b_idx > qrmanager -> mrows ) && ( muDoubleScalarAbs ( qrmanager -> QR [ idxQR - 1 ] ) >= c ) ) { b_idx -- ; idxQR -= 221 ; } nonDegenerate = ( b_idx == qrmanager -> mrows ) ; if ( ! nonDegenerate ) { } else { guard2 = true ; } } else { guard2 = true ; } if ( guard2 ) { idxQR = ( b_idx - 1 ) * 221 + b_idx ; while ( ( b_idx >= 1 ) && ( muDoubleScalarAbs ( qrmanager -> QR [ idxQR - 1 ] ) >= c ) ) { b_idx -- ; idxQR -= 222 ; } nonDegenerate = ( b_idx == 0 ) ; } } if ( ! nonDegenerate ) { solution -> state = - 7 ; } else { guard1 = true ; } } else { guard1 = true ; } if ( guard1 ) { if ( qrmanager -> mrows != 0 ) { for ( b_idx = 0 ; b_idx < nActiveConstr_tmp_tmp ; b_idx ++ ) { workspace [ b_idx ] = 0.0 ; } jjA = ( qrmanager -> ncols - 1 ) * 221 + 1 ; for ( b_idx = 1 ; b_idx <= jjA ; b_idx += 221 ) { c = 0.0 ; ix = ( b_idx + qrmanager -> mrows ) - 1 ; for ( idxQR = b_idx ; idxQR <= ix ; idxQR ++ ) { c += qrmanager -> Q [ idxQR - 1 ] * objective -> grad [ idxQR - b_idx ] ; } idxQR = div_nde_s32_floor ( b_idx - 1 , 221 ) ; workspace [ idxQR ] += c ; } } if ( qrmanager -> ncols != 0 ) { for ( b_idx = nActiveConstr_tmp_tmp ; b_idx >= 1 ; b_idx -- ) { jjA = ( ( b_idx - 1 ) * 221 + b_idx ) - 2 ; workspace [ b_idx - 1 ] /= qrmanager -> QR [ jjA + 1 ] ; for ( idxQR = 0 ; idxQR <= b_idx - 2 ; idxQR ++ ) { ix = ( b_idx - idxQR ) - 2 ; workspace [ ix ] -= workspace [ b_idx - 1 ] * qrmanager -> QR [ jjA - idxQR ] ; } } } idxQR = ( qrmanager -> ncols / 2 ) << 1 ; jjA = idxQR - 2 ; for ( b_idx = 0 ; b_idx <= jjA ; b_idx += 2 ) { tmp = _mm_loadu_pd ( & workspace [ b_idx ] ) ; _mm_storeu_pd ( & solution -> lambda [ b_idx ] , _mm_mul_pd ( tmp , _mm_set1_pd ( - 1.0 ) ) ) ; } for ( b_idx = idxQR ; b_idx < nActiveConstr_tmp_tmp ; b_idx ++ ) { solution -> lambda [ b_idx ] = - workspace [ b_idx ] ; } } } } static void fw3u2letrf ( ci1jcnwvc5 * solution , const iamwnmrrfd * objective ) { if ( objective -> objtype == 5 ) { if ( xnrm2_zbVenBlk ( objective -> nvar , solution -> searchDir ) > 100.0 * ( real_T ) objective -> nvar * 1.4901161193847656E-8 ) { solution -> state = 3 ; } else { solution -> state = 4 ; } } } static void dywa1naf0c ( c3tcu1vsoj * obj , int32_T TYPE , int32_T idx_local ) { int32_T b ; int32_T colOffset ; int32_T idx ; int32_T idx_bnd_local ; obj -> nWConstr [ TYPE - 1 ] ++ ; obj -> isActiveConstr [ ( obj -> isActiveIdx [ TYPE - 1 ] + idx_local ) - 2 ] = true ; obj -> nActiveConstr ++ ; obj -> Wid [ obj -> nActiveConstr - 1 ] = TYPE ; obj -> Wlocalidx [ obj -> nActiveConstr - 1 ] = idx_local ; colOffset = ( obj -> nActiveConstr - 1 ) * 121 - 1 ; if ( TYPE == 5 ) { idx_bnd_local = obj -> indexUB [ idx_local - 1 ] ; obj -> bwset [ obj -> nActiveConstr - 1 ] = obj -> ub [ idx_bnd_local - 1 ] ; } else { idx_bnd_local = obj -> indexLB [ idx_local - 1 ] ; obj -> bwset [ obj -> nActiveConstr - 1 ] = obj -> lb [ idx_bnd_local - 1 ] ; } b = ( uint8_T ) ( idx_bnd_local - 1 ) ; for ( idx = 0 ; idx < b ; idx ++ ) { obj -> ATwset [ ( idx + colOffset ) + 1 ] = 0.0 ; } obj -> ATwset [ idx_bnd_local + colOffset ] = ( real_T ) ( TYPE == 5 ) * 2.0 - 1.0 ; b = obj -> nVar ; for ( idx = idx_bnd_local + 1 ; idx <= b ; idx ++ ) { obj -> ATwset [ idx + colOffset ] = 0.0 ; } switch ( obj -> probType ) { case 3 : case 2 : break ; default : obj -> ATwset [ obj -> nVar + colOffset ] = - 1.0 ; break ; } } static void p22oac0uqf ( c3tcu1vsoj * obj , int32_T idx_local ) { int32_T b ; int32_T iAineq0 ; int32_T iAw0 ; int32_T idx ; obj -> nWConstr [ 2 ] ++ ; obj -> isActiveConstr [ ( obj -> isActiveIdx [ 2 ] + idx_local ) - 2 ] = true ; obj -> nActiveConstr ++ ; obj -> Wid [ obj -> nActiveConstr - 1 ] = 3 ; obj -> Wlocalidx [ obj -> nActiveConstr - 1 ] = idx_local ; iAineq0 = ( idx_local - 1 ) * 121 ; iAw0 = ( obj -> nActiveConstr - 1 ) * 121 ; b = obj -> nVar ; for ( idx = 0 ; idx < b ; idx ++ ) { obj -> ATwset [ iAw0 + idx ] = obj -> Aineq [ iAineq0 + idx ] ; } obj -> bwset [ obj -> nActiveConstr - 1 ] = obj -> bineq [ idx_local - 1 ] ; } static void ozc3jikxh0 ( c3tcu1vsoj * obj , int32_T idx_global ) { int32_T TYPE_tmp ; int32_T b ; int32_T idx ; TYPE_tmp = obj -> Wid [ idx_global - 1 ] - 1 ; obj -> isActiveConstr [ ( obj -> isActiveIdx [ TYPE_tmp ] + obj -> Wlocalidx [ idx_global - 1 ] ) - 2 ] = false ; if ( idx_global < obj -> nActiveConstr ) { obj -> Wid [ idx_global - 1 ] = obj -> Wid [ obj -> nActiveConstr - 1 ] ; obj -> Wlocalidx [ idx_global - 1 ] = obj -> Wlocalidx [ obj -> nActiveConstr - 1 ] ; b = ( uint8_T ) obj -> nVar ; for ( idx = 0 ; idx < b ; idx ++ ) { obj -> ATwset [ idx + 121 * ( idx_global - 1 ) ] = obj -> ATwset [ ( obj -> nActiveConstr - 1 ) * 121 + idx ] ; } obj -> bwset [ idx_global - 1 ] = obj -> bwset [ obj -> nActiveConstr - 1 ] ; } obj -> nActiveConstr -- ; obj -> nWConstr [ TYPE_tmp ] -- ; } static void ijxevqoovk ( oytx5zapfu * obj , const real_T A [ 26741 ] , int32_T mrows , int32_T ncols ) { int32_T b ; int32_T idx ; int32_T ix0 ; int32_T iy0 ; int32_T k ; boolean_T guard1 ; idx = mrows * ncols ; guard1 = false ; if ( idx > 0 ) { for ( idx = 0 ; idx < ncols ; idx ++ ) { ix0 = 121 * idx ; iy0 = 221 * idx ; b = ( uint8_T ) mrows ; for ( k = 0 ; k < b ; k ++ ) { obj -> QR [ iy0 + k ] = A [ ix0 + k ] ; } } guard1 = true ; } else if ( idx == 0 ) { obj -> mrows = mrows ; obj -> ncols = ncols ; obj -> minRowCol = 0 ; } else { guard1 = true ; } if ( guard1 ) { obj -> usedPivoting = true ; obj -> mrows = mrows ; obj -> ncols = ncols ; obj -> minRowCol = muIntScalarMin_sint32 ( mrows , ncols ) ; xgeqp3_QxlrhgAO ( obj -> QR , mrows , ncols , obj -> jpvt , obj -> tau ) ; } } static int32_T iri1hxo114 ( const real_T qrmanager_QR [ 48841 ] , int32_T qrmanager_mrows , int32_T qrmanager_ncols ) { real_T tol ; int32_T minmn ; int32_T r ; r = 0 ; minmn = muIntScalarMin_sint32 ( qrmanager_mrows , qrmanager_ncols ) ; if ( minmn > 0 ) { tol = muDoubleScalarMin ( 1.4901161193847656E-8 , 2.2204460492503131E-15 * ( real_T ) muIntScalarMax_sint32 ( qrmanager_mrows , qrmanager_ncols ) ) * muDoubleScalarAbs ( qrmanager_QR [ 0 ] ) ; while ( ( r < minmn ) && ( ! ( muDoubleScalarAbs ( qrmanager_QR [ 221 * r + r ] ) <= tol ) ) ) { r ++ ; } } return r ; } static real_T p3kkfowucmz ( c3tcu1vsoj * obj , const real_T x [ 26741 ] ) { real_T obj_maxConstrWorkspace ; real_T v ; int32_T b ; int32_T k ; if ( obj -> probType == 2 ) { v = 0.0 ; memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> bineq [ 0 ] , 54U * sizeof ( real_T ) ) ; xgemv_pXms4vNT ( 26 , obj -> Aineq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 54 ; k ++ ) { obj_maxConstrWorkspace = obj -> maxConstrWorkspace [ k ] - x [ k + 26 ] ; obj -> maxConstrWorkspace [ k ] = obj_maxConstrWorkspace ; v = muDoubleScalarMax ( v , obj_maxConstrWorkspace ) ; } memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> beq [ 0 ] , 20U * sizeof ( real_T ) ) ; xgemv_nX1Gae0k ( 26 , obj -> Aeq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 20 ; k ++ ) { obj_maxConstrWorkspace = ( obj -> maxConstrWorkspace [ k ] - x [ k + 80 ] ) + x [ k + 100 ] ; obj -> maxConstrWorkspace [ k ] = obj_maxConstrWorkspace ; v = muDoubleScalarMax ( v , muDoubleScalarAbs ( obj_maxConstrWorkspace ) ) ; } } else { v = 0.0 ; memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> bineq [ 0 ] , 54U * sizeof ( real_T ) ) ; xgemv_pXms4vNT ( obj -> nVar , obj -> Aineq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 54 ; k ++ ) { v = muDoubleScalarMax ( v , obj -> maxConstrWorkspace [ k ] ) ; } memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> beq [ 0 ] , 20U * sizeof ( real_T ) ) ; xgemv_nX1Gae0k ( obj -> nVar , obj -> Aeq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 20 ; k ++ ) { v = muDoubleScalarMax ( v , muDoubleScalarAbs ( obj -> maxConstrWorkspace [ k ] ) ) ; } } if ( obj -> sizes [ 3 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 3 ] ; for ( k = 0 ; k < b ; k ++ ) { v = muDoubleScalarMax ( v , - x [ obj -> indexLB [ k ] - 1 ] - obj -> lb [ obj -> indexLB [ k ] - 1 ] ) ; } } if ( obj -> sizes [ 4 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 4 ] ; for ( k = 0 ; k < b ; k ++ ) { v = muDoubleScalarMax ( v , x [ obj -> indexUB [ k ] - 1 ] - obj -> ub [ obj -> indexUB [ k ] - 1 ] ) ; } } if ( obj -> sizes [ 0 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 0 ] ; for ( k = 0 ; k < b ; k ++ ) { v = muDoubleScalarMax ( v , muDoubleScalarAbs ( x [ obj -> indexFixed [ k ] - 1 ] - obj -> ub [ obj -> indexFixed [ k ] - 1 ] ) ) ; } } return v ; } static real_T p3kkfowucmzw ( c3tcu1vsoj * obj , const real_T x [ 26741 ] ) { real_T obj_maxConstrWorkspace ; real_T v ; int32_T b ; int32_T k ; if ( obj -> probType == 2 ) { v = 0.0 ; memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> bineq [ 0 ] , 54U * sizeof ( real_T ) ) ; xgemv_KU6NVrGg ( 26 , obj -> Aineq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 54 ; k ++ ) { obj_maxConstrWorkspace = obj -> maxConstrWorkspace [ k ] - x [ k + 247 ] ; obj -> maxConstrWorkspace [ k ] = obj_maxConstrWorkspace ; v = muDoubleScalarMax ( v , obj_maxConstrWorkspace ) ; } memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> beq [ 0 ] , 20U * sizeof ( real_T ) ) ; xgemv_SHwV9wCf ( 26 , obj -> Aeq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 20 ; k ++ ) { obj_maxConstrWorkspace = ( obj -> maxConstrWorkspace [ k ] - x [ k + 301 ] ) + x [ k + 321 ] ; obj -> maxConstrWorkspace [ k ] = obj_maxConstrWorkspace ; v = muDoubleScalarMax ( v , muDoubleScalarAbs ( obj_maxConstrWorkspace ) ) ; } } else { v = 0.0 ; memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> bineq [ 0 ] , 54U * sizeof ( real_T ) ) ; xgemv_KU6NVrGg ( obj -> nVar , obj -> Aineq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 54 ; k ++ ) { v = muDoubleScalarMax ( v , obj -> maxConstrWorkspace [ k ] ) ; } memcpy ( & obj -> maxConstrWorkspace [ 0 ] , & obj -> beq [ 0 ] , 20U * sizeof ( real_T ) ) ; xgemv_SHwV9wCf ( obj -> nVar , obj -> Aeq , x , obj -> maxConstrWorkspace ) ; for ( k = 0 ; k < 20 ; k ++ ) { v = muDoubleScalarMax ( v , muDoubleScalarAbs ( obj -> maxConstrWorkspace [ k ] ) ) ; } } if ( obj -> sizes [ 3 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 3 ] ; for ( k = 0 ; k < b ; k ++ ) { v = muDoubleScalarMax ( v , - x [ obj -> indexLB [ k ] + 220 ] - obj -> lb [ obj -> indexLB [ k ] - 1 ] ) ; } } if ( obj -> sizes [ 4 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 4 ] ; for ( k = 0 ; k < b ; k ++ ) { v = muDoubleScalarMax ( v , x [ obj -> indexUB [ k ] + 220 ] - obj -> ub [ obj -> indexUB [ k ] - 1 ] ) ; } } if ( obj -> sizes [ 0 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 0 ] ; for ( k = 0 ; k < b ; k ++ ) { v = muDoubleScalarMax ( v , muDoubleScalarAbs ( x [ obj -> indexFixed [ k ] + 220 ] - obj -> ub [ obj -> indexFixed [ k ] - 1 ] ) ) ; } } return v ; } static boolean_T dsoxlnhlbq ( real_T workspace [ 26741 ] , real_T xCurrent [ 121 ] , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , d4m2qnxaxx * localB ) { __m128d tmp ; __m128d tmp_p ; real_T constrViolation_basicX ; real_T temp ; int32_T b_idx ; int32_T c_k ; int32_T exitg1 ; int32_T iAcol ; int32_T ia ; int32_T ix ; int32_T iy ; int32_T mWConstr ; int32_T nVar ; int32_T rankQR ; int32_T scalarLB ; int32_T vectorUB ; boolean_T nonDegenerateWset ; mWConstr = workingset -> nActiveConstr ; nVar = workingset -> nVar ; nonDegenerateWset = true ; if ( workingset -> nActiveConstr != 0 ) { if ( workingset -> nActiveConstr >= workingset -> nVar ) { scalarLB = ( uint8_T ) workingset -> nVar ; for ( rankQR = 0 ; rankQR < scalarLB ; rankQR ++ ) { ix = 221 * rankQR ; for ( b_idx = 0 ; b_idx < mWConstr ; b_idx ++ ) { qrmanager -> QR [ b_idx + ix ] = workingset -> ATwset [ 121 * b_idx + rankQR ] ; } qrmanager -> jpvt [ rankQR ] = 0 ; } if ( workingset -> nActiveConstr * workingset -> nVar == 0 ) { qrmanager -> mrows = workingset -> nActiveConstr ; qrmanager -> ncols = workingset -> nVar ; qrmanager -> minRowCol = 0 ; } else { qrmanager -> usedPivoting = true ; qrmanager -> mrows = workingset -> nActiveConstr ; qrmanager -> ncols = workingset -> nVar ; qrmanager -> minRowCol = muIntScalarMin_sint32 ( workingset -> nActiveConstr , workingset -> nVar ) ; xgeqp3_QxlrhgAO ( qrmanager -> QR , workingset -> nActiveConstr , workingset -> nVar , qrmanager -> jpvt , qrmanager -> tau ) ; } d2y4tsvypc ( qrmanager , qrmanager -> mrows ) ; rankQR = iri1hxo114 ( qrmanager -> QR , qrmanager -> mrows , qrmanager -> ncols ) ; for ( b_idx = 0 ; b_idx < mWConstr ; b_idx ++ ) { workspace [ b_idx ] = workingset -> bwset [ b_idx ] ; workspace [ b_idx + 221 ] = workingset -> bwset [ b_idx ] ; } iy = ( workingset -> nActiveConstr - 1 ) * 121 + 1 ; for ( b_idx = 1 ; b_idx <= iy ; b_idx += 121 ) { temp = 0.0 ; ia = ( b_idx + nVar ) - 1 ; for ( c_k = b_idx ; c_k <= ia ; c_k ++ ) { temp += workingset -> ATwset [ c_k - 1 ] * xCurrent [ c_k - b_idx ] ; } ia = div_nde_s32_floor ( b_idx - 1 , 121 ) ; workspace [ ia ] -= temp ; } memcpy ( & localB -> B [ 0 ] , & workspace [ 0 ] , 26741U * sizeof ( real_T ) ) ; for ( b_idx = 0 ; b_idx <= 221 ; b_idx += 221 ) { ix = b_idx + nVar ; for ( c_k = b_idx + 1 ; c_k <= ix ; c_k ++ ) { workspace [ c_k - 1 ] = 0.0 ; } } iy = - 1 ; for ( b_idx = 0 ; b_idx <= 221 ; b_idx += 221 ) { iAcol = - 1 ; ia = b_idx + nVar ; for ( c_k = b_idx + 1 ; c_k <= ia ; c_k ++ ) { temp = 0.0 ; for ( ix = 0 ; ix < mWConstr ; ix ++ ) { temp += qrmanager -> Q [ ( ix + iAcol ) + 1 ] * localB -> B [ ( ix + iy ) + 1 ] ; } workspace [ c_k - 1 ] += temp ; iAcol += 221 ; } iy += 221 ; } for ( mWConstr = 0 ; mWConstr < 2 ; mWConstr ++ ) { ix = 221 * mWConstr - 1 ; for ( b_idx = rankQR ; b_idx >= 1 ; b_idx -- ) { iy = ( b_idx - 1 ) * 221 ; ia = b_idx + ix ; temp = workspace [ ia ] ; if ( temp != 0.0 ) { workspace [ ia ] = temp / qrmanager -> QR [ ( b_idx + iy ) - 1 ] ; iAcol = ( uint8_T ) ( b_idx - 1 ) ; for ( c_k = 0 ; c_k < iAcol ; c_k ++ ) { vectorUB = ( c_k + ix ) + 1 ; workspace [ vectorUB ] -= qrmanager -> QR [ c_k + iy ] * workspace [ ia ] ; } } } } for ( mWConstr = rankQR + 1 ; mWConstr <= nVar ; mWConstr ++ ) { workspace [ mWConstr - 1 ] = 0.0 ; workspace [ mWConstr + 220 ] = 0.0 ; } for ( rankQR = 0 ; rankQR < scalarLB ; rankQR ++ ) { workspace [ qrmanager -> jpvt [ rankQR ] + 441 ] = workspace [ rankQR ] ; } for ( rankQR = 0 ; rankQR < scalarLB ; rankQR ++ ) { workspace [ rankQR ] = workspace [ rankQR + 442 ] ; } for ( rankQR = 0 ; rankQR < scalarLB ; rankQR ++ ) { workspace [ qrmanager -> jpvt [ rankQR ] + 441 ] = workspace [ rankQR + 221 ] ; } for ( rankQR = 0 ; rankQR < scalarLB ; rankQR ++ ) { workspace [ rankQR + 221 ] = workspace [ rankQR + 442 ] ; } } else { if ( workingset -> nActiveConstr - 1 >= 0 ) { memset ( & qrmanager -> jpvt [ 0 ] , 0 , ( uint32_T ) workingset -> nActiveConstr * sizeof ( int32_T ) ) ; } ijxevqoovk ( qrmanager , workingset -> ATwset , workingset -> nVar , workingset -> nActiveConstr ) ; d2y4tsvypc ( qrmanager , qrmanager -> minRowCol ) ; rankQR = iri1hxo114 ( qrmanager -> QR , qrmanager -> mrows , qrmanager -> ncols ) ; for ( b_idx = 0 ; b_idx < mWConstr ; b_idx ++ ) { ix = ( qrmanager -> jpvt [ b_idx ] - 1 ) * 121 ; temp = 0.0 ; iAcol = ( uint8_T ) nVar ; for ( c_k = 0 ; c_k < iAcol ; c_k ++ ) { temp += workingset -> ATwset [ ix + c_k ] * xCurrent [ c_k ] ; } constrViolation_basicX = workingset -> bwset [ qrmanager -> jpvt [ b_idx ] - 1 ] ; workspace [ b_idx ] = constrViolation_basicX - temp ; workspace [ b_idx + 221 ] = constrViolation_basicX ; } iy = ( uint8_T ) rankQR ; for ( mWConstr = 0 ; mWConstr < 2 ; mWConstr ++ ) { ix = 221 * mWConstr ; for ( b_idx = 0 ; b_idx < iy ; b_idx ++ ) { iAcol = 221 * b_idx ; ia = b_idx + ix ; temp = workspace [ ia ] ; for ( c_k = 0 ; c_k < b_idx ; c_k ++ ) { temp -= qrmanager -> QR [ c_k + iAcol ] * workspace [ c_k + ix ] ; } workspace [ ia ] = temp / qrmanager -> QR [ b_idx + iAcol ] ; } } memcpy ( & localB -> B [ 0 ] , & workspace [ 0 ] , 26741U * sizeof ( real_T ) ) ; for ( mWConstr = 0 ; mWConstr <= 221 ; mWConstr += 221 ) { c_k = mWConstr + nVar ; for ( b_idx = mWConstr + 1 ; b_idx <= c_k ; b_idx ++ ) { workspace [ b_idx - 1 ] = 0.0 ; } } ix = 1 ; for ( mWConstr = 0 ; mWConstr <= 221 ; mWConstr += 221 ) { iy = - 1 ; iAcol = ix + rankQR ; for ( b_idx = ix ; b_idx < iAcol ; b_idx ++ ) { ia = mWConstr + nVar ; scalarLB = ( ( ( ( ia - mWConstr ) / 2 ) << 1 ) + mWConstr ) + 1 ; vectorUB = scalarLB - 2 ; for ( c_k = mWConstr + 1 ; c_k <= vectorUB ; c_k += 2 ) { tmp = _mm_loadu_pd ( & qrmanager -> Q [ ( iy + c_k ) - mWConstr ] ) ; tmp_p = _mm_loadu_pd ( & workspace [ c_k - 1 ] ) ; _mm_storeu_pd ( & workspace [ c_k - 1 ] , _mm_add_pd ( _mm_mul_pd ( tmp , _mm_set1_pd ( localB -> B [ b_idx - 1 ] ) ) , tmp_p ) ) ; } for ( c_k = scalarLB ; c_k <= ia ; c_k ++ ) { workspace [ c_k - 1 ] += qrmanager -> Q [ ( iy + c_k ) - mWConstr ] * localB -> B [ b_idx - 1 ] ; } iy += 221 ; } ix += 221 ; } } rankQR = 0 ; do { exitg1 = 0 ; if ( rankQR <= ( uint8_T ) nVar - 1 ) { if ( muDoubleScalarIsInf ( workspace [ rankQR ] ) || muDoubleScalarIsNaN ( workspace [ rankQR ] ) ) { nonDegenerateWset = false ; exitg1 = 1 ; } else { constrViolation_basicX = workspace [ rankQR + 221 ] ; if ( muDoubleScalarIsInf ( constrViolation_basicX ) || muDoubleScalarIsNaN ( constrViolation_basicX ) ) { nonDegenerateWset = false ; exitg1 = 1 ; } else { rankQR ++ ; } } } else { scalarLB = ( nVar / 2 ) << 1 ; vectorUB = scalarLB - 2 ; for ( rankQR = 0 ; rankQR <= vectorUB ; rankQR += 2 ) { tmp = _mm_loadu_pd ( & workspace [ rankQR ] ) ; tmp_p = _mm_loadu_pd ( & xCurrent [ rankQR ] ) ; _mm_storeu_pd ( & workspace [ rankQR ] , _mm_add_pd ( tmp , tmp_p ) ) ; } for ( rankQR = scalarLB ; rankQR < nVar ; rankQR ++ ) { workspace [ rankQR ] += xCurrent [ rankQR ] ; } temp = p3kkfowucmz ( workingset , workspace ) ; constrViolation_basicX = p3kkfowucmzw ( workingset , workspace ) ; if ( ( temp <= 2.2204460492503131E-16 ) || ( temp < constrViolation_basicX ) ) { memcpy ( & xCurrent [ 0 ] , & workspace [ 0 ] , ( uint8_T ) nVar * sizeof ( real_T ) ) ; } else { memcpy ( & xCurrent [ 0 ] , & workspace [ 221 ] , ( uint8_T ) nVar * sizeof ( real_T ) ) ; } exitg1 = 1 ; } } while ( exitg1 == 0 ) ; } return nonDegenerateWset ; } static void jzdsxapqec ( int32_T * activeSetChangeID , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , const iamwnmrrfd * objective , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , int32_T runTimeOptions_MaxIterations , const boolean_T * updateFval , d4m2qnxaxx * localB ) { real_T tempMaxConstr ; boolean_T nonDegenerateWset ; solution -> iterations ++ ; if ( ( solution -> iterations >= runTimeOptions_MaxIterations ) && ( ( solution -> state != 1 ) || ( objective -> objtype == 5 ) ) ) { solution -> state = 0 ; } if ( solution -> iterations - solution -> iterations / 50 * 50 == 0 ) { solution -> maxConstr = p3kkfowucmzwk ( workingset , solution -> xstar ) ; tempMaxConstr = solution -> maxConstr ; if ( objective -> objtype == 5 ) { tempMaxConstr = solution -> maxConstr - solution -> xstar [ objective -> nvar - 1 ] ; } if ( tempMaxConstr > 1.0E-6 ) { if ( objective -> nvar - 1 >= 0 ) { memcpy ( & solution -> searchDir [ 0 ] , & solution -> xstar [ 0 ] , ( uint32_T ) objective -> nvar * sizeof ( real_T ) ) ; } nonDegenerateWset = dsoxlnhlbq ( memspace -> workspace_float , solution -> searchDir , workingset , qrmanager , localB ) ; if ( ( ! nonDegenerateWset ) && ( solution -> state != 0 ) ) { solution -> state = - 2 ; } * activeSetChangeID = 0 ; tempMaxConstr = p3kkfowucmzwk ( workingset , solution -> searchDir ) ; if ( tempMaxConstr < solution -> maxConstr ) { if ( objective -> nvar - 1 >= 0 ) { memcpy ( & solution -> xstar [ 0 ] , & solution -> searchDir [ 0 ] , ( uint32_T ) objective -> nvar * sizeof ( real_T ) ) ; } solution -> maxConstr = tempMaxConstr ; } } } if ( * updateFval ) { solution -> fstar = ha4rdqgm4g ( objective , memspace -> workspace_float , f , solution -> xstar ) ; if ( ( solution -> fstar < 1.0E-6 ) && ( ( solution -> state != 0 ) || ( objective -> objtype != 5 ) ) ) { solution -> state = 2 ; } } } static void acuz0bhfbi ( const real_T H [ 676 ] , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , iamwnmrrfd * objective , const char_T options_SolverName [ 7 ] , int32_T runTimeOptions_MaxIterations , d4m2qnxaxx * localB ) { __m128d tmp ; __m128d tmp_p ; real_T normDelta ; real_T solution_lambda ; int32_T activeSetChangeID ; int32_T exitg1 ; int32_T g ; int32_T globalActiveConstrIdx ; int32_T idxMinLambda ; int32_T k ; int32_T nVar ; int32_T vectorUB ; boolean_T guard1 ; boolean_T subProblemChanged ; boolean_T updateFval ; subProblemChanged = true ; updateFval = true ; activeSetChangeID = 0 ; nVar = workingset -> nVar ; globalActiveConstrIdx = 0 ; gnvee1hvpj ( objective , H , f , solution -> xstar ) ; solution -> fstar = ha4rdqgm4g ( objective , memspace -> workspace_float , f , solution -> xstar ) ; solution -> state = - 5 ; for ( k = 0 ; k < 221 ; k ++ ) { solution -> lambda [ k ] = 0.0 ; } do { exitg1 = 0 ; if ( solution -> state == - 5 ) { guard1 = false ; if ( subProblemChanged ) { switch ( activeSetChangeID ) { case 1 : lf2exsz2ex ( qrmanager , workingset -> ATwset , 121 * ( workingset -> nActiveConstr - 1 ) + 1 ) ; break ; case - 1 : cilnv2vgqh ( qrmanager , globalActiveConstrIdx ) ; break ; default : b453z2zntr ( qrmanager , workingset -> ATwset , nVar , workingset -> nActiveConstr ) ; d2y4tsvypc ( qrmanager , qrmanager -> mrows ) ; break ; } fhnd1v2j0m ( H , solution , memspace , qrmanager , cholmanager , objective , k1a0kvuk51 ( options_SolverName ) ) ; if ( solution -> state != - 5 ) { exitg1 = 1 ; } else { normDelta = xnrm2_zbVenBlk ( nVar , solution -> searchDir ) ; guard1 = true ; } } else { idxMinLambda = ( uint8_T ) nVar ; for ( k = 0 ; k < idxMinLambda ; k ++ ) { solution -> searchDir [ k ] = 0.0 ; } normDelta = 0.0 ; guard1 = true ; } if ( guard1 ) { if ( ( ! subProblemChanged ) || ( normDelta < 1.4901161193847657E-10 ) || ( workingset -> nActiveConstr >= nVar ) ) { gg30krxp5f ( memspace -> workspace_float , solution , objective , qrmanager ) ; if ( ( solution -> state != - 7 ) || ( workingset -> nActiveConstr > nVar ) ) { idxMinLambda = 0 ; normDelta = 0.0 ; vectorUB = ( workingset -> nWConstr [ 0 ] + workingset -> nWConstr [ 1 ] ) + 1 ; g = workingset -> nActiveConstr ; for ( k = vectorUB ; k <= g ; k ++ ) { solution_lambda = solution -> lambda [ k - 1 ] ; if ( solution_lambda < normDelta ) { normDelta = solution_lambda ; idxMinLambda = k ; } } if ( idxMinLambda == 0 ) { solution -> state = 1 ; } else { activeSetChangeID = - 1 ; globalActiveConstrIdx = idxMinLambda ; subProblemChanged = true ; ozc3jikxh0 ( workingset , idxMinLambda ) ; if ( idxMinLambda < workingset -> nActiveConstr + 1 ) { solution -> lambda [ idxMinLambda - 1 ] = solution -> lambda [ workingset -> nActiveConstr ] ; } solution -> lambda [ workingset -> nActiveConstr ] = 0.0 ; } } else { idxMinLambda = workingset -> nActiveConstr ; activeSetChangeID = 0 ; globalActiveConstrIdx = workingset -> nActiveConstr ; subProblemChanged = true ; ozc3jikxh0 ( workingset , workingset -> nActiveConstr ) ; solution -> lambda [ idxMinLambda - 1 ] = 0.0 ; } updateFval = false ; } else { diz55ngdn0 ( solution -> xstar , solution -> searchDir , memspace -> workspace_float , workingset -> nVar , workingset -> Aineq , workingset -> bineq , workingset -> lb , workingset -> ub , workingset -> indexLB , workingset -> indexUB , workingset -> sizes , workingset -> isActiveIdx , workingset -> isActiveConstr , workingset -> nWConstr , true , & normDelta , & updateFval , & k , & idxMinLambda ) ; if ( updateFval ) { switch ( k ) { case 3 : p22oac0uqf ( workingset , idxMinLambda ) ; break ; case 4 : dywa1naf0c ( workingset , 4 , idxMinLambda ) ; break ; default : dywa1naf0c ( workingset , 5 , idxMinLambda ) ; break ; } activeSetChangeID = 1 ; } else { fw3u2letrf ( solution , objective ) ; subProblemChanged = false ; if ( workingset -> nActiveConstr == 0 ) { solution -> state = 1 ; } } if ( ( nVar >= 1 ) && ( ! ( normDelta == 0.0 ) ) ) { idxMinLambda = ( nVar / 2 ) << 1 ; vectorUB = idxMinLambda - 2 ; for ( k = 0 ; k <= vectorUB ; k += 2 ) { tmp = _mm_loadu_pd ( & solution -> searchDir [ k ] ) ; tmp_p = _mm_loadu_pd ( & solution -> xstar [ k ] ) ; _mm_storeu_pd ( & solution -> xstar [ k ] , _mm_add_pd ( _mm_mul_pd ( _mm_set1_pd ( normDelta ) , tmp ) , tmp_p ) ) ; } for ( k = idxMinLambda ; k < nVar ; k ++ ) { solution -> xstar [ k ] += normDelta * solution -> searchDir [ k ] ; } } gnvee1hvpj ( objective , H , f , solution -> xstar ) ; updateFval = true ; } jzdsxapqec ( & activeSetChangeID , f , solution , memspace , objective , workingset , qrmanager , runTimeOptions_MaxIterations , & updateFval , localB ) ; } } else { if ( ! updateFval ) { solution -> fstar = ha4rdqgm4g ( objective , memspace -> workspace_float , f , solution -> xstar ) ; } exitg1 = 1 ; } } while ( exitg1 == 0 ) ; } static void hwriukhbq4 ( const real_T H [ 676 ] , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , iamwnmrrfd * objective , const char_T options_SolverName [ 7 ] , const i4h2yyndkb * runTimeOptions , d4m2qnxaxx * localB ) { int32_T PROBTYPE_ORIG ; int32_T idxEndIneq ; int32_T idxStartIneq ; int32_T idxStartIneq_tmp ; int32_T mConstr ; int32_T nVar_tmp ; boolean_T exitg1 ; PROBTYPE_ORIG = workingset -> probType ; nVar_tmp = workingset -> nVar ; solution -> xstar [ workingset -> nVar ] = solution -> maxConstr + 1.0 ; if ( workingset -> probType == 3 ) { mConstr = 1 ; } else { mConstr = 4 ; } i3lcleconb ( workingset , mConstr ) ; idxStartIneq_tmp = workingset -> nWConstr [ 0 ] + workingset -> nWConstr [ 1 ] ; idxStartIneq = idxStartIneq_tmp + 1 ; idxEndIneq = workingset -> nActiveConstr ; for ( mConstr = idxStartIneq ; mConstr <= idxEndIneq ; mConstr ++ ) { workingset -> isActiveConstr [ ( workingset -> isActiveIdx [ workingset -> Wid [ mConstr - 1 ] - 1 ] + workingset -> Wlocalidx [ mConstr - 1 ] ) - 2 ] = false ; } workingset -> nWConstr [ 2 ] = 0 ; workingset -> nWConstr [ 3 ] = 0 ; workingset -> nWConstr [ 4 ] = 0 ; workingset -> nActiveConstr = idxStartIneq_tmp ; objective -> prev_objtype = objective -> objtype ; objective -> prev_nvar = objective -> nvar ; objective -> prev_hasLinear = objective -> hasLinear ; objective -> objtype = 5 ; objective -> nvar = nVar_tmp + 1 ; objective -> gammaScalar = 1.0 ; objective -> hasLinear = true ; solution -> fstar = solution -> xstar [ nVar_tmp ] ; solution -> state = 5 ; acuz0bhfbi ( H , f , solution , memspace , workingset , qrmanager , cholmanager , objective , options_SolverName , runTimeOptions -> MaxIterations , localB ) ; if ( workingset -> isActiveConstr [ ( workingset -> isActiveIdx [ 3 ] + workingset -> sizes [ 3 ] ) - 2 ] ) { mConstr = workingset -> sizes [ 0 ] + 21 ; exitg1 = false ; while ( ( ! exitg1 ) && ( mConstr <= workingset -> nActiveConstr ) ) { if ( ( workingset -> Wid [ mConstr - 1 ] == 4 ) && ( workingset -> Wlocalidx [ mConstr - 1 ] == workingset -> sizes [ 3 ] ) ) { ozc3jikxh0 ( workingset , mConstr ) ; exitg1 = true ; } else { mConstr ++ ; } } } mConstr = workingset -> nActiveConstr ; while ( ( mConstr > workingset -> sizes [ 0 ] + 20 ) && ( mConstr > nVar_tmp ) ) { ozc3jikxh0 ( workingset , mConstr ) ; mConstr -- ; } solution -> maxConstr = solution -> xstar [ nVar_tmp ] ; i3lcleconb ( workingset , PROBTYPE_ORIG ) ; objective -> objtype = objective -> prev_objtype ; objective -> nvar = objective -> prev_nvar ; objective -> hasLinear = objective -> prev_hasLinear ; } static void jzdsxapqeco ( int32_T * activeSetChangeID , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , const iamwnmrrfd * objective , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , int32_T runTimeOptions_MaxIterations , boolean_T * updateFval , d4m2qnxaxx * localB ) { real_T tempMaxConstr ; boolean_T nonDegenerateWset ; solution -> iterations ++ ; if ( ( solution -> iterations >= runTimeOptions_MaxIterations ) && ( ( solution -> state != 1 ) || ( objective -> objtype == 5 ) ) ) { solution -> state = 0 ; } if ( solution -> iterations - solution -> iterations / 50 * 50 == 0 ) { tempMaxConstr = p3kkfowucmzwk ( workingset , solution -> xstar ) ; solution -> maxConstr = tempMaxConstr ; if ( objective -> objtype == 5 ) { tempMaxConstr = solution -> maxConstr - solution -> xstar [ objective -> nvar - 1 ] ; } if ( tempMaxConstr > 1.0E-6 ) { if ( objective -> nvar - 1 >= 0 ) { memcpy ( & solution -> searchDir [ 0 ] , & solution -> xstar [ 0 ] , ( uint32_T ) objective -> nvar * sizeof ( real_T ) ) ; } nonDegenerateWset = dsoxlnhlbq ( memspace -> workspace_float , solution -> searchDir , workingset , qrmanager , localB ) ; if ( ( ! nonDegenerateWset ) && ( solution -> state != 0 ) ) { solution -> state = - 2 ; } * activeSetChangeID = 0 ; tempMaxConstr = p3kkfowucmzwk ( workingset , solution -> searchDir ) ; if ( tempMaxConstr < solution -> maxConstr ) { if ( objective -> nvar - 1 >= 0 ) { memcpy ( & solution -> xstar [ 0 ] , & solution -> searchDir [ 0 ] , ( uint32_T ) objective -> nvar * sizeof ( real_T ) ) ; } solution -> maxConstr = tempMaxConstr ; } } } if ( * updateFval ) { * updateFval = false ; } } static void acuz0bhfbih ( const real_T H [ 676 ] , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , iamwnmrrfd * objective , const char_T options_SolverName [ 7 ] , int32_T runTimeOptions_MaxIterations , d4m2qnxaxx * localB ) { __m128d tmp ; __m128d tmp_p ; real_T normDelta ; real_T solution_lambda ; int32_T activeSetChangeID ; int32_T exitg1 ; int32_T g ; int32_T globalActiveConstrIdx ; int32_T idxMinLambda ; int32_T k ; int32_T nVar ; int32_T vectorUB ; boolean_T guard1 ; boolean_T subProblemChanged ; boolean_T updateFval ; subProblemChanged = true ; updateFval = true ; activeSetChangeID = 0 ; nVar = workingset -> nVar ; globalActiveConstrIdx = 0 ; gnvee1hvpj ( objective , H , f , solution -> xstar ) ; solution -> fstar = ha4rdqgm4g ( objective , memspace -> workspace_float , f , solution -> xstar ) ; if ( solution -> iterations < runTimeOptions_MaxIterations ) { solution -> state = - 5 ; } else { solution -> state = 0 ; } for ( k = 0 ; k < 221 ; k ++ ) { solution -> lambda [ k ] = 0.0 ; } do { exitg1 = 0 ; if ( solution -> state == - 5 ) { guard1 = false ; if ( subProblemChanged ) { switch ( activeSetChangeID ) { case 1 : lf2exsz2ex ( qrmanager , workingset -> ATwset , 121 * ( workingset -> nActiveConstr - 1 ) + 1 ) ; break ; case - 1 : cilnv2vgqh ( qrmanager , globalActiveConstrIdx ) ; break ; default : b453z2zntr ( qrmanager , workingset -> ATwset , nVar , workingset -> nActiveConstr ) ; d2y4tsvypc ( qrmanager , qrmanager -> mrows ) ; break ; } fhnd1v2j0m ( H , solution , memspace , qrmanager , cholmanager , objective , k1a0kvuk51 ( options_SolverName ) ) ; if ( solution -> state != - 5 ) { exitg1 = 1 ; } else { normDelta = xnrm2_zbVenBlk ( nVar , solution -> searchDir ) ; guard1 = true ; } } else { idxMinLambda = ( uint8_T ) nVar ; for ( k = 0 ; k < idxMinLambda ; k ++ ) { solution -> searchDir [ k ] = 0.0 ; } normDelta = 0.0 ; guard1 = true ; } if ( guard1 ) { if ( ( ! subProblemChanged ) || ( normDelta < 1.0E-6 ) || ( workingset -> nActiveConstr >= nVar ) ) { gg30krxp5f ( memspace -> workspace_float , solution , objective , qrmanager ) ; if ( ( solution -> state != - 7 ) || ( workingset -> nActiveConstr > nVar ) ) { idxMinLambda = 0 ; normDelta = 0.0 ; vectorUB = ( workingset -> nWConstr [ 0 ] + workingset -> nWConstr [ 1 ] ) + 1 ; g = workingset -> nActiveConstr ; for ( k = vectorUB ; k <= g ; k ++ ) { solution_lambda = solution -> lambda [ k - 1 ] ; if ( solution_lambda < normDelta ) { normDelta = solution_lambda ; idxMinLambda = k ; } } if ( idxMinLambda == 0 ) { solution -> state = 1 ; } else { activeSetChangeID = - 1 ; globalActiveConstrIdx = idxMinLambda ; subProblemChanged = true ; ozc3jikxh0 ( workingset , idxMinLambda ) ; if ( idxMinLambda < workingset -> nActiveConstr + 1 ) { solution -> lambda [ idxMinLambda - 1 ] = solution -> lambda [ workingset -> nActiveConstr ] ; } solution -> lambda [ workingset -> nActiveConstr ] = 0.0 ; } } else { idxMinLambda = workingset -> nActiveConstr ; activeSetChangeID = 0 ; globalActiveConstrIdx = workingset -> nActiveConstr ; subProblemChanged = true ; ozc3jikxh0 ( workingset , workingset -> nActiveConstr ) ; solution -> lambda [ idxMinLambda - 1 ] = 0.0 ; } updateFval = false ; } else { diz55ngdn0 ( solution -> xstar , solution -> searchDir , memspace -> workspace_float , workingset -> nVar , workingset -> Aineq , workingset -> bineq , workingset -> lb , workingset -> ub , workingset -> indexLB , workingset -> indexUB , workingset -> sizes , workingset -> isActiveIdx , workingset -> isActiveConstr , workingset -> nWConstr , ( objective -> objtype == 5 ) , & normDelta , & updateFval , & k , & idxMinLambda ) ; if ( updateFval ) { switch ( k ) { case 3 : p22oac0uqf ( workingset , idxMinLambda ) ; break ; case 4 : dywa1naf0c ( workingset , 4 , idxMinLambda ) ; break ; default : dywa1naf0c ( workingset , 5 , idxMinLambda ) ; break ; } activeSetChangeID = 1 ; } else { fw3u2letrf ( solution , objective ) ; subProblemChanged = false ; if ( workingset -> nActiveConstr == 0 ) { solution -> state = 1 ; } } if ( ( nVar >= 1 ) && ( ! ( normDelta == 0.0 ) ) ) { idxMinLambda = ( nVar / 2 ) << 1 ; vectorUB = idxMinLambda - 2 ; for ( k = 0 ; k <= vectorUB ; k += 2 ) { tmp = _mm_loadu_pd ( & solution -> searchDir [ k ] ) ; tmp_p = _mm_loadu_pd ( & solution -> xstar [ k ] ) ; _mm_storeu_pd ( & solution -> xstar [ k ] , _mm_add_pd ( _mm_mul_pd ( _mm_set1_pd ( normDelta ) , tmp ) , tmp_p ) ) ; } for ( k = idxMinLambda ; k < nVar ; k ++ ) { solution -> xstar [ k ] += normDelta * solution -> searchDir [ k ] ; } } gnvee1hvpj ( objective , H , f , solution -> xstar ) ; updateFval = true ; } jzdsxapqeco ( & activeSetChangeID , solution , memspace , objective , workingset , qrmanager , runTimeOptions_MaxIterations , & updateFval , localB ) ; } } else { if ( ! updateFval ) { solution -> fstar = ha4rdqgm4g ( objective , memspace -> workspace_float , f , solution -> xstar ) ; } exitg1 = 1 ; } } while ( exitg1 == 0 ) ; } static int32_T dd3g4xxgaf ( oytx5zapfu * qrmanager , const real_T beqf [ 221 ] , int32_T mConstr , int32_T nVar ) { real_T qtb ; real_T tol ; int32_T b ; int32_T ix ; int32_T numDependent ; int32_T totalRank ; boolean_T exitg1 ; totalRank = mConstr - nVar ; numDependent = muIntScalarMax_sint32 ( 0 , totalRank ) ; memset ( & qrmanager -> jpvt [ 0 ] , 0 , ( uint8_T ) nVar * sizeof ( int32_T ) ) ; if ( mConstr * nVar == 0 ) { qrmanager -> mrows = mConstr ; qrmanager -> ncols = nVar ; qrmanager -> minRowCol = 0 ; } else { qrmanager -> usedPivoting = true ; qrmanager -> mrows = mConstr ; qrmanager -> ncols = nVar ; qrmanager -> minRowCol = muIntScalarMin_sint32 ( mConstr , nVar ) ; xgeqp3_QxlrhgAO ( qrmanager -> QR , mConstr , nVar , qrmanager -> jpvt , qrmanager -> tau ) ; } tol = muDoubleScalarMin ( 1.4901161193847656E-8 , 2.2204460492503131E-15 * ( real_T ) muIntScalarMax_sint32 ( mConstr , nVar ) ) ; totalRank = muIntScalarMin_sint32 ( nVar , mConstr ) ; totalRank += ( totalRank - 1 ) * 221 ; while ( ( totalRank > 0 ) && ( muDoubleScalarAbs ( qrmanager -> QR [ totalRank - 1 ] ) < tol * muDoubleScalarAbs ( qrmanager -> QR [ 0 ] ) ) ) { totalRank -= 222 ; numDependent ++ ; } if ( numDependent > 0 ) { d2y4tsvypc ( qrmanager , qrmanager -> mrows ) ; b = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( b <= numDependent - 1 ) ) { ix = ( ( mConstr - b ) - 1 ) * 221 ; qtb = 0.0 ; for ( totalRank = 0 ; totalRank < mConstr ; totalRank ++ ) { qtb += qrmanager -> Q [ ix + totalRank ] * beqf [ totalRank ] ; } if ( muDoubleScalarAbs ( qtb ) >= tol ) { numDependent = - 1 ; exitg1 = true ; } else { b ++ ; } } } return numDependent ; } static void k2kcdu0qax ( int32_T depIdx [ 221 ] , int32_T mFixed , int32_T nDep , oytx5zapfu * qrmanager , int32_T mRows , int32_T nCols ) { int32_T idx ; for ( idx = 0 ; idx < mFixed ; idx ++ ) { qrmanager -> jpvt [ idx ] = 1 ; } if ( mFixed + 1 <= nCols ) { memset ( & qrmanager -> jpvt [ mFixed ] , 0 , ( uint32_T ) ( nCols - mFixed ) * sizeof ( int32_T ) ) ; } if ( mRows * nCols == 0 ) { qrmanager -> mrows = mRows ; qrmanager -> ncols = nCols ; qrmanager -> minRowCol = 0 ; } else { qrmanager -> usedPivoting = true ; qrmanager -> mrows = mRows ; qrmanager -> ncols = nCols ; qrmanager -> minRowCol = muIntScalarMin_sint32 ( mRows , nCols ) ; xgeqp3_QxlrhgAO ( qrmanager -> QR , mRows , nCols , qrmanager -> jpvt , qrmanager -> tau ) ; } for ( idx = 0 ; idx < nDep ; idx ++ ) { depIdx [ idx ] = qrmanager -> jpvt [ ( nCols - nDep ) + idx ] ; } } static int32_T o0tv2kc1z5 ( kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager ) { int32_T TYPE ; int32_T b ; int32_T ix0 ; int32_T mTotalWorkingEq_tmp ; int32_T nDepInd ; int32_T nVar_tmp ; int32_T totalEq ; mTotalWorkingEq_tmp = workingset -> nWConstr [ 0 ] + workingset -> nWConstr [ 1 ] ; nDepInd = 0 ; if ( mTotalWorkingEq_tmp > 0 ) { nVar_tmp = ( uint8_T ) workingset -> nVar ; for ( totalEq = 0 ; totalEq < mTotalWorkingEq_tmp ; totalEq ++ ) { for ( TYPE = 0 ; TYPE < nVar_tmp ; TYPE ++ ) { qrmanager -> QR [ totalEq + 221 * TYPE ] = workingset -> ATwset [ 121 * totalEq + TYPE ] ; } } nDepInd = dd3g4xxgaf ( qrmanager , workingset -> bwset , mTotalWorkingEq_tmp , workingset -> nVar ) ; if ( nDepInd > 0 ) { for ( totalEq = 0 ; totalEq < mTotalWorkingEq_tmp ; totalEq ++ ) { b = 221 * totalEq ; ix0 = 121 * totalEq ; for ( TYPE = 0 ; TYPE < nVar_tmp ; TYPE ++ ) { qrmanager -> QR [ b + TYPE ] = workingset -> ATwset [ ix0 + TYPE ] ; } } k2kcdu0qax ( memspace -> workspace_int , workingset -> nWConstr [ 0 ] , nDepInd , qrmanager , workingset -> nVar , mTotalWorkingEq_tmp ) ; countsort_mFQteL5g ( memspace -> workspace_int , nDepInd , memspace -> workspace_sort , 1 , mTotalWorkingEq_tmp ) ; for ( totalEq = nDepInd ; totalEq >= 1 ; totalEq -- ) { mTotalWorkingEq_tmp = workingset -> nWConstr [ 0 ] + workingset -> nWConstr [ 1 ] ; if ( mTotalWorkingEq_tmp != 0 ) { ix0 = memspace -> workspace_int [ totalEq - 1 ] ; if ( ix0 <= mTotalWorkingEq_tmp ) { if ( ( mTotalWorkingEq_tmp == workingset -> nActiveConstr ) || ( mTotalWorkingEq_tmp == ix0 ) ) { workingset -> mEqRemoved ++ ; workingset -> indexEqRemoved [ workingset -> mEqRemoved - 1 ] = workingset -> Wlocalidx [ ix0 - 1 ] ; ozc3jikxh0 ( workingset , memspace -> workspace_int [ totalEq - 1 ] ) ; } else { workingset -> mEqRemoved ++ ; b = workingset -> Wid [ ix0 - 1 ] - 1 ; TYPE = workingset -> Wlocalidx [ ix0 - 1 ] ; workingset -> indexEqRemoved [ workingset -> mEqRemoved - 1 ] = TYPE ; workingset -> isActiveConstr [ ( workingset -> isActiveIdx [ b ] + TYPE ) - 2 ] = false ; workingset -> Wid [ ix0 - 1 ] = workingset -> Wid [ mTotalWorkingEq_tmp - 1 ] ; workingset -> Wlocalidx [ ix0 - 1 ] = workingset -> Wlocalidx [ mTotalWorkingEq_tmp - 1 ] ; for ( TYPE = 0 ; TYPE < nVar_tmp ; TYPE ++ ) { workingset -> ATwset [ TYPE + 121 * ( ix0 - 1 ) ] = workingset -> ATwset [ ( mTotalWorkingEq_tmp - 1 ) * 121 + TYPE ] ; } workingset -> bwset [ ix0 - 1 ] = workingset -> bwset [ mTotalWorkingEq_tmp - 1 ] ; workingset -> Wid [ mTotalWorkingEq_tmp - 1 ] = workingset -> Wid [ workingset -> nActiveConstr - 1 ] ; workingset -> Wlocalidx [ mTotalWorkingEq_tmp - 1 ] = workingset -> Wlocalidx [ workingset -> nActiveConstr - 1 ] ; for ( TYPE = 0 ; TYPE < nVar_tmp ; TYPE ++ ) { workingset -> ATwset [ TYPE + 121 * ( mTotalWorkingEq_tmp - 1 ) ] = workingset -> ATwset [ ( workingset -> nActiveConstr - 1 ) * 121 + TYPE ] ; } workingset -> bwset [ mTotalWorkingEq_tmp - 1 ] = workingset -> bwset [ workingset -> nActiveConstr - 1 ] ; workingset -> nActiveConstr -- ; workingset -> nWConstr [ b ] -- ; } } } } } } return nDepInd ; } static void ijvdhcksfr ( c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kmbpuy2anc * memspace , real_T tolfactor ) { real_T maxDiag ; real_T tol ; int32_T d ; int32_T ix0 ; int32_T iy0 ; int32_T nActiveConstr ; int32_T nActiveConstr_tmp ; int32_T nDepIneq ; int32_T nFixedConstr ; int32_T nVar ; nActiveConstr_tmp = workingset -> nActiveConstr ; nFixedConstr = workingset -> nWConstr [ 0 ] + workingset -> nWConstr [ 1 ] ; nVar = workingset -> nVar ; if ( ( workingset -> nWConstr [ 2 ] + workingset -> nWConstr [ 3 ] ) + workingset -> nWConstr [ 4 ] > 0 ) { tol = muDoubleScalarMin ( 1.4901161193847656E-8 , 2.2204460492503131E-15 * ( real_T ) muIntScalarMax_sint32 ( workingset -> nVar , workingset -> nActiveConstr ) ) * tolfactor ; for ( nDepIneq = 0 ; nDepIneq < nFixedConstr ; nDepIneq ++ ) { qrmanager -> jpvt [ nDepIneq ] = 1 ; } if ( nFixedConstr + 1 <= workingset -> nActiveConstr ) { memset ( & qrmanager -> jpvt [ nFixedConstr ] , 0 , ( uint32_T ) ( workingset -> nActiveConstr - nFixedConstr ) * sizeof ( int32_T ) ) ; } for ( nDepIneq = 0 ; nDepIneq < nActiveConstr_tmp ; nDepIneq ++ ) { iy0 = 221 * nDepIneq ; ix0 = 121 * nDepIneq ; d = ( uint8_T ) nVar ; for ( nActiveConstr = 0 ; nActiveConstr < d ; nActiveConstr ++ ) { qrmanager -> QR [ iy0 + nActiveConstr ] = workingset -> ATwset [ ix0 + nActiveConstr ] ; } } if ( workingset -> nVar * workingset -> nActiveConstr == 0 ) { qrmanager -> mrows = workingset -> nVar ; qrmanager -> ncols = workingset -> nActiveConstr ; qrmanager -> minRowCol = 0 ; } else { qrmanager -> usedPivoting = true ; qrmanager -> mrows = workingset -> nVar ; qrmanager -> ncols = workingset -> nActiveConstr ; qrmanager -> minRowCol = muIntScalarMin_sint32 ( workingset -> nVar , workingset -> nActiveConstr ) ; xgeqp3_QxlrhgAO ( qrmanager -> QR , workingset -> nVar , workingset -> nActiveConstr , qrmanager -> jpvt , qrmanager -> tau ) ; } nDepIneq = 0 ; for ( nActiveConstr = workingset -> nActiveConstr - 1 ; nActiveConstr + 1 > nVar ; nActiveConstr -- ) { nDepIneq ++ ; memspace -> workspace_int [ nDepIneq - 1 ] = qrmanager -> jpvt [ nActiveConstr ] ; } maxDiag = muDoubleScalarAbs ( qrmanager -> QR [ 0 ] ) ; for ( nVar = 0 ; nVar < nActiveConstr ; nVar ++ ) { maxDiag = muDoubleScalarMax ( maxDiag , muDoubleScalarAbs ( qrmanager -> QR [ ( ( nVar + 1 ) * 221 + nVar ) + 1 ] ) ) ; } if ( nActiveConstr + 1 <= workingset -> nVar ) { nVar = 221 * nActiveConstr + nActiveConstr ; while ( ( nActiveConstr + 1 > nFixedConstr ) && ( muDoubleScalarAbs ( qrmanager -> QR [ nVar ] ) < tol * maxDiag ) ) { nDepIneq ++ ; memspace -> workspace_int [ nDepIneq - 1 ] = qrmanager -> jpvt [ nActiveConstr ] ; nActiveConstr -- ; nVar -= 222 ; } } countsort_mFQteL5g ( memspace -> workspace_int , nDepIneq , memspace -> workspace_sort , nFixedConstr + 1 , workingset -> nActiveConstr ) ; for ( nFixedConstr = nDepIneq ; nFixedConstr >= 1 ; nFixedConstr -- ) { ozc3jikxh0 ( workingset , memspace -> workspace_int [ nFixedConstr - 1 ] ) ; } } } static void glmbbxgvqt ( ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , d4m2qnxaxx * localB ) { real_T constrViolation ; int32_T b ; int32_T idxEndIneq ; int32_T idxStartIneq ; int32_T idxStartIneq_tmp ; boolean_T guard1 ; boolean_T okWorkingSet ; solution -> state = 82 ; b = o0tv2kc1z5 ( memspace , workingset , qrmanager ) ; if ( ( b != - 1 ) && ( workingset -> nActiveConstr <= 221 ) ) { ijvdhcksfr ( workingset , qrmanager , memspace , 1.0 ) ; okWorkingSet = dsoxlnhlbq ( memspace -> workspace_float , solution -> xstar , workingset , qrmanager , localB ) ; guard1 = false ; if ( ! okWorkingSet ) { ijvdhcksfr ( workingset , qrmanager , memspace , 10.0 ) ; okWorkingSet = dsoxlnhlbq ( memspace -> workspace_float , solution -> xstar , workingset , qrmanager , localB ) ; if ( ! okWorkingSet ) { solution -> state = - 7 ; } else { guard1 = true ; } } else { guard1 = true ; } if ( guard1 ) { if ( workingset -> nWConstr [ 0 ] + workingset -> nWConstr [ 1 ] == workingset -> nVar ) { constrViolation = p3kkfowucmzwk ( workingset , solution -> xstar ) ; if ( constrViolation > 1.0E-6 ) { solution -> state = - 2 ; } } } } else { solution -> state = - 3 ; idxStartIneq_tmp = workingset -> nWConstr [ 0 ] + workingset -> nWConstr [ 1 ] ; idxStartIneq = idxStartIneq_tmp + 1 ; idxEndIneq = workingset -> nActiveConstr ; for ( b = idxStartIneq ; b <= idxEndIneq ; b ++ ) { workingset -> isActiveConstr [ ( workingset -> isActiveIdx [ workingset -> Wid [ b - 1 ] - 1 ] + workingset -> Wlocalidx [ b - 1 ] ) - 2 ] = false ; } workingset -> nWConstr [ 2 ] = 0 ; workingset -> nWConstr [ 3 ] = 0 ; workingset -> nWConstr [ 4 ] = 0 ; workingset -> nActiveConstr = idxStartIneq_tmp ; } } static void o5obldhs3v ( boolean_T obj_hasLinear , int32_T obj_nvar , real_T workspace [ 26741 ] , const real_T H [ 676 ] , const real_T f [ 121 ] , const real_T x [ 121 ] ) { real_T c ; int32_T beta1 ; int32_T d ; int32_T e ; int32_T ia ; int32_T ix ; int32_T tmp ; beta1 = 0 ; if ( obj_hasLinear ) { if ( obj_nvar - 1 >= 0 ) { memcpy ( & workspace [ 0 ] , & f [ 0 ] , ( uint32_T ) obj_nvar * sizeof ( real_T ) ) ; } beta1 = 1 ; } if ( obj_nvar != 0 ) { if ( beta1 != 1 ) { for ( beta1 = 0 ; beta1 < obj_nvar ; beta1 ++ ) { workspace [ beta1 ] = 0.0 ; } } ix = 0 ; d = ( obj_nvar - 1 ) * obj_nvar + 1 ; for ( beta1 = 1 ; obj_nvar < 0 ? beta1 >= d : beta1 <= d ; beta1 += obj_nvar ) { c = 0.5 * x [ ix ] ; e = ( beta1 + obj_nvar ) - 1 ; for ( ia = beta1 ; ia <= e ; ia ++ ) { tmp = ia - beta1 ; workspace [ tmp ] += H [ ia - 1 ] * c ; } ix ++ ; } } } static void ckrin4u0eh1 ( const real_T H [ 676 ] , const real_T f [ 121 ] , ci1jcnwvc5 * solution , kmbpuy2anc * memspace , c3tcu1vsoj * workingset , oytx5zapfu * qrmanager , kzv4ftj4e2 * cholmanager , iamwnmrrfd * objective , const i4h2yyndkb * options , const i4h2yyndkb * runTimeOptions , d4m2qnxaxx * localB ) { __m128d tmp ; real_T maxConstr_new ; int32_T c ; int32_T ixlast ; int32_T nVar ; int32_T vectorUB ; boolean_T guard1 ; solution -> iterations = 0 ; nVar = workingset -> nVar ; guard1 = false ; if ( workingset -> probType == 3 ) { c = ( uint8_T ) workingset -> sizes [ 0 ] ; for ( ixlast = 0 ; ixlast < c ; ixlast ++ ) { solution -> xstar [ workingset -> indexFixed [ ixlast ] - 1 ] = workingset -> ub [ workingset -> indexFixed [ ixlast ] - 1 ] ; } c = ( uint8_T ) workingset -> sizes [ 3 ] ; for ( ixlast = 0 ; ixlast < c ; ixlast ++ ) { if ( workingset -> isActiveConstr [ ( workingset -> isActiveIdx [ 3 ] + ixlast ) - 1 ] ) { solution -> xstar [ workingset -> indexLB [ ixlast ] - 1 ] = - workingset -> lb [ workingset -> indexLB [ ixlast ] - 1 ] ; } } c = ( uint8_T ) workingset -> sizes [ 4 ] ; for ( ixlast = 0 ; ixlast < c ; ixlast ++ ) { if ( workingset -> isActiveConstr [ ( workingset -> isActiveIdx [ 4 ] + ixlast ) - 1 ] ) { solution -> xstar [ workingset -> indexUB [ ixlast ] - 1 ] = workingset -> ub [ workingset -> indexUB [ ixlast ] - 1 ] ; } } glmbbxgvqt ( solution , memspace , workingset , qrmanager , localB ) ; if ( solution -> state < 0 ) { } else { guard1 = true ; } } else { solution -> state = 82 ; guard1 = true ; } if ( guard1 ) { solution -> iterations = 0 ; solution -> maxConstr = p3kkfowucmzwk ( workingset , solution -> xstar ) ; if ( solution -> maxConstr > 1.0E-6 ) { hwriukhbq4 ( H , f , solution , memspace , workingset , qrmanager , cholmanager , objective , options -> SolverName , runTimeOptions , localB ) ; if ( solution -> state == 0 ) { } else { solution -> maxConstr = p3kkfowucmzwk ( workingset , solution -> xstar ) ; if ( solution -> maxConstr > 1.0E-6 ) { for ( nVar = 0 ; nVar < 221 ; nVar ++ ) { solution -> lambda [ nVar ] = 0.0 ; } maxConstr_new = 0.0 ; switch ( objective -> objtype ) { case 5 : maxConstr_new = solution -> xstar [ objective -> nvar - 1 ] * objective -> gammaScalar ; break ; case 3 : o5obldhs3v ( objective -> hasLinear , objective -> nvar , memspace -> workspace_float , H , f , solution -> xstar ) ; if ( objective -> nvar >= 1 ) { ixlast = objective -> nvar ; for ( nVar = 0 ; nVar < ixlast ; nVar ++ ) { maxConstr_new += solution -> xstar [ nVar ] * memspace -> workspace_float [ nVar ] ; } } break ; case 4 : o5obldhs3v ( objective -> hasLinear , objective -> nvar , memspace -> workspace_float , H , f , solution -> xstar ) ; ixlast = objective -> nvar + 1 ; c = ( ( ( ( 120 - objective -> nvar ) / 2 ) << 1 ) + objective -> nvar ) + 1 ; vectorUB = c - 2 ; for ( nVar = ixlast ; nVar <= vectorUB ; nVar += 2 ) { tmp = _mm_loadu_pd ( & solution -> xstar [ nVar - 1 ] ) ; _mm_storeu_pd ( & memspace -> workspace_float [ nVar - 1 ] , _mm_add_pd ( _mm_mul_pd ( _mm_set1_pd ( 0.5 * objective -> beta ) , tmp ) , _mm_set1_pd ( objective -> rho ) ) ) ; } for ( nVar = c ; nVar < 121 ; nVar ++ ) { memspace -> workspace_float [ nVar - 1 ] = 0.5 * objective -> beta * solution -> xstar [ nVar - 1 ] + objective -> rho ; } for ( nVar = 0 ; nVar < 120 ; nVar ++ ) { maxConstr_new += solution -> xstar [ nVar ] * memspace -> workspace_float [ nVar ] ; } break ; default : break ; } solution -> fstar = maxConstr_new ; solution -> state = - 2 ; } else { if ( solution -> maxConstr > 0.0 ) { if ( nVar - 1 >= 0 ) { memcpy ( & solution -> searchDir [ 0 ] , & solution -> xstar [ 0 ] , ( uint32_T ) nVar * sizeof ( real_T ) ) ; } glmbbxgvqt ( solution , memspace , workingset , qrmanager , localB ) ; maxConstr_new = p3kkfowucmzwk ( workingset , solution -> xstar ) ; if ( maxConstr_new >= solution -> maxConstr ) { solution -> maxConstr = maxConstr_new ; if ( nVar - 1 >= 0 ) { memcpy ( & solution -> xstar [ 0 ] , & solution -> searchDir [ 0 ] , ( uint32_T ) nVar * sizeof ( real_T ) ) ; } } } acuz0bhfbih ( H , f , solution , memspace , workingset , qrmanager , cholmanager , objective , options -> SolverName , runTimeOptions -> MaxIterations , localB ) ; } } } else { acuz0bhfbih ( H , f , solution , memspace , workingset , qrmanager , cholmanager , objective , options -> SolverName , runTimeOptions -> MaxIterations , localB ) ; } } } static void dudfwmvulx ( c3tcu1vsoj * obj , int32_T idx_local ) { int32_T b_idx ; int32_T iAeq0 ; int32_T iAw0 ; int32_T iAw0_tmp ; int32_T totalEq ; totalEq = obj -> nWConstr [ 0 ] + obj -> nWConstr [ 1 ] ; if ( ( obj -> nActiveConstr == totalEq ) && ( idx_local > obj -> nWConstr [ 1 ] ) ) { obj -> nWConstr [ 1 ] ++ ; obj -> isActiveConstr [ ( obj -> isActiveIdx [ 1 ] + idx_local ) - 2 ] = true ; obj -> nActiveConstr ++ ; obj -> Wid [ obj -> nActiveConstr - 1 ] = 2 ; obj -> Wlocalidx [ obj -> nActiveConstr - 1 ] = idx_local ; iAeq0 = ( idx_local - 1 ) * 121 ; iAw0 = ( obj -> nActiveConstr - 1 ) * 121 ; b_idx = ( uint8_T ) obj -> nVar ; for ( totalEq = 0 ; totalEq < b_idx ; totalEq ++ ) { obj -> ATwset [ iAw0 + totalEq ] = obj -> Aeq [ iAeq0 + totalEq ] ; } obj -> bwset [ obj -> nActiveConstr - 1 ] = obj -> beq [ idx_local - 1 ] ; } else { obj -> nActiveConstr ++ ; obj -> Wid [ obj -> nActiveConstr - 1 ] = obj -> Wid [ totalEq ] ; obj -> Wlocalidx [ obj -> nActiveConstr - 1 ] = obj -> Wlocalidx [ totalEq ] ; iAw0_tmp = ( uint8_T ) obj -> nVar ; for ( iAeq0 = 0 ; iAeq0 < iAw0_tmp ; iAeq0 ++ ) { obj -> ATwset [ iAeq0 + 121 * ( obj -> nActiveConstr - 1 ) ] = obj -> ATwset [ 121 * totalEq + iAeq0 ] ; } obj -> bwset [ obj -> nActiveConstr - 1 ] = obj -> bwset [ totalEq ] ; obj -> nWConstr [ 1 ] ++ ; obj -> isActiveConstr [ ( obj -> isActiveIdx [ 1 ] + idx_local ) - 2 ] = true ; obj -> Wid [ totalEq ] = 2 ; obj -> Wlocalidx [ totalEq ] = idx_local ; iAeq0 = ( idx_local - 1 ) * 121 ; iAw0 = 121 * totalEq ; for ( b_idx = 0 ; b_idx < iAw0_tmp ; b_idx ++ ) { obj -> ATwset [ iAw0 + b_idx ] = obj -> Aeq [ iAeq0 + b_idx ] ; } obj -> bwset [ totalEq ] = obj -> beq [ idx_local - 1 ] ; } } static void myxjrkt4iq ( real_T lambda [ 221 ] , int32_T WorkingSet_nActiveConstr , const int32_T WorkingSet_sizes [ 5 ] , const int32_T WorkingSet_isActiveIdx [ 6 ] , const int32_T WorkingSet_Wid [ 221 ] , const int32_T WorkingSet_Wlocalidx [ 221 ] , real_T workspace [ 26741 ] ) { int32_T currentMplier ; int32_T idxOffset ; int32_T mAll ; if ( WorkingSet_nActiveConstr != 0 ) { mAll = ( ( WorkingSet_sizes [ 0 ] + WorkingSet_sizes [ 3 ] ) + WorkingSet_sizes [ 4 ] ) + 73 ; memcpy ( & workspace [ 0 ] , & lambda [ 0 ] , ( uint16_T ) ( mAll + 1 ) * sizeof ( real_T ) ) ; for ( currentMplier = 0 ; currentMplier <= mAll ; currentMplier ++ ) { lambda [ currentMplier ] = 0.0 ; } currentMplier = 0 ; mAll = 0 ; while ( ( mAll + 1 <= WorkingSet_nActiveConstr ) && ( WorkingSet_Wid [ mAll ] <= 2 ) ) { if ( WorkingSet_Wid [ mAll ] == 1 ) { idxOffset = 1 ; } else { idxOffset = WorkingSet_isActiveIdx [ 1 ] ; } lambda [ ( idxOffset + WorkingSet_Wlocalidx [ mAll ] ) - 2 ] = workspace [ currentMplier ] ; currentMplier ++ ; mAll ++ ; } while ( mAll + 1 <= WorkingSet_nActiveConstr ) { switch ( WorkingSet_Wid [ mAll ] ) { case 3 : idxOffset = WorkingSet_isActiveIdx [ 2 ] ; break ; case 4 : idxOffset = WorkingSet_isActiveIdx [ 3 ] ; break ; default : idxOffset = WorkingSet_isActiveIdx [ 4 ] ; break ; } lambda [ ( idxOffset + WorkingSet_Wlocalidx [ mAll ] ) - 2 ] = workspace [ currentMplier ] ; currentMplier ++ ; mAll ++ ; } } } static boolean_T l1cacwyidk ( const real_T Hessian [ 676 ] , const real_T grad [ 121 ] , ci1jcnwvc5 * TrialState , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , kzv4ftj4e2 * CholManager , iamwnmrrfd * QPObjective , const i4h2yyndkb * qpoptions , d4m2qnxaxx * localB ) { __m128d tmp ; __m128d tmp_p ; real_T b_c ; int32_T g_tmp ; int32_T idxEndIneq ; int32_T idxIneqOffset ; int32_T idx_Aineq ; int32_T idx_Partition ; int32_T ix ; int32_T iy ; int32_T nVar ; int32_T nWIneq_old ; int32_T nWLower_old ; int32_T nWUpper_old ; boolean_T success ; nWIneq_old = WorkingSet -> nWConstr [ 2 ] ; nWLower_old = WorkingSet -> nWConstr [ 3 ] ; nWUpper_old = WorkingSet -> nWConstr [ 4 ] ; nVar = WorkingSet -> nVar ; memcpy ( & TrialState -> xstarsqp [ 0 ] , & TrialState -> xstarsqp_old [ 0 ] , ( uint8_T ) WorkingSet -> nVar * sizeof ( real_T ) ) ; memcpy ( & TrialState -> socDirection [ 0 ] , & TrialState -> xstar [ 0 ] , ( uint8_T ) WorkingSet -> nVar * sizeof ( real_T ) ) ; memcpy ( & TrialState -> lambdaStopTest [ 0 ] , & TrialState -> lambda [ 0 ] , 221U * sizeof ( real_T ) ) ; idxIneqOffset = WorkingSet -> isActiveIdx [ 2 ] ; for ( idxEndIneq = 0 ; idxEndIneq <= 18 ; idxEndIneq += 2 ) { tmp_p = _mm_loadu_pd ( & TrialState -> cEq [ idxEndIneq ] ) ; _mm_storeu_pd ( & WorkingSet -> beq [ idxEndIneq ] , _mm_mul_pd ( tmp_p , _mm_set1_pd ( - 1.0 ) ) ) ; } for ( idxEndIneq = 0 ; idxEndIneq <= 2299 ; idxEndIneq += 121 ) { b_c = 0.0 ; iy = idxEndIneq + WorkingSet -> nVar ; for ( idx_Aineq = idxEndIneq + 1 ; idx_Aineq <= iy ; idx_Aineq ++ ) { b_c += TrialState -> searchDir [ ( idx_Aineq - idxEndIneq ) - 1 ] * WorkingSet -> Aeq [ idx_Aineq - 1 ] ; } idx_Aineq = div_nde_s32_floor ( idxEndIneq , 121 ) ; WorkingSet -> beq [ idx_Aineq ] += b_c ; } for ( idxEndIneq = 0 ; idxEndIneq < 20 ; idxEndIneq ++ ) { WorkingSet -> bwset [ WorkingSet -> sizes [ 0 ] + idxEndIneq ] = WorkingSet -> beq [ idxEndIneq ] ; } for ( idxEndIneq = 0 ; idxEndIneq <= 52 ; idxEndIneq += 2 ) { tmp_p = _mm_loadu_pd ( & TrialState -> cIneq [ idxEndIneq ] ) ; _mm_storeu_pd ( & WorkingSet -> bineq [ idxEndIneq ] , _mm_mul_pd ( tmp_p , _mm_set1_pd ( - 1.0 ) ) ) ; } for ( idxEndIneq = 0 ; idxEndIneq <= 6413 ; idxEndIneq += 121 ) { b_c = 0.0 ; iy = idxEndIneq + WorkingSet -> nVar ; for ( idx_Aineq = idxEndIneq + 1 ; idx_Aineq <= iy ; idx_Aineq ++ ) { b_c += TrialState -> searchDir [ ( idx_Aineq - idxEndIneq ) - 1 ] * WorkingSet -> Aineq [ idx_Aineq - 1 ] ; } idx_Aineq = div_nde_s32_floor ( idxEndIneq , 121 ) ; WorkingSet -> bineq [ idx_Aineq ] += b_c ; } idx_Aineq = 1 ; iy = 55 ; ix = WorkingSet -> sizes [ 3 ] + 55 ; g_tmp = WorkingSet -> nActiveConstr ; for ( idxEndIneq = idxIneqOffset ; idxEndIneq <= g_tmp ; idxEndIneq ++ ) { switch ( WorkingSet -> Wid [ idxEndIneq - 1 ] ) { case 3 : idx_Partition = idx_Aineq ; idx_Aineq ++ ; WorkingSet -> bwset [ idxEndIneq - 1 ] = WorkingSet -> bineq [ WorkingSet -> Wlocalidx [ idxEndIneq - 1 ] - 1 ] ; break ; case 4 : idx_Partition = iy ; iy ++ ; break ; default : idx_Partition = ix ; ix ++ ; break ; } TrialState -> workingset_old [ idx_Partition - 1 ] = WorkingSet -> Wlocalidx [ idxEndIneq - 1 ] ; } memcpy ( & TrialState -> xstar [ 0 ] , & TrialState -> xstarsqp [ 0 ] , ( uint8_T ) WorkingSet -> nVar * sizeof ( real_T ) ) ; ckrin4u0eh1 ( Hessian , grad , TrialState , memspace , WorkingSet , QRManager , CholManager , QPObjective , qpoptions , qpoptions , localB ) ; while ( ( WorkingSet -> mEqRemoved > 0 ) && ( WorkingSet -> indexEqRemoved [ WorkingSet -> mEqRemoved - 1 ] >= 1 ) ) { dudfwmvulx ( WorkingSet , WorkingSet -> indexEqRemoved [ WorkingSet -> mEqRemoved - 1 ] ) ; WorkingSet -> mEqRemoved -- ; } idxEndIneq = ( uint8_T ) nVar ; idx_Aineq = ( ( uint8_T ) nVar / 2 ) << 1 ; iy = idx_Aineq - 2 ; for ( idxIneqOffset = 0 ; idxIneqOffset <= iy ; idxIneqOffset += 2 ) { tmp_p = _mm_loadu_pd ( & TrialState -> socDirection [ idxIneqOffset ] ) ; tmp = _mm_loadu_pd ( & TrialState -> xstar [ idxIneqOffset ] ) ; _mm_storeu_pd ( & TrialState -> socDirection [ idxIneqOffset ] , _mm_sub_pd ( tmp , tmp_p ) ) ; _mm_storeu_pd ( & TrialState -> xstar [ idxIneqOffset ] , tmp_p ) ; } for ( idxIneqOffset = idx_Aineq ; idxIneqOffset < idxEndIneq ; idxIneqOffset ++ ) { b_c = TrialState -> socDirection [ idxIneqOffset ] ; TrialState -> socDirection [ idxIneqOffset ] = TrialState -> xstar [ idxIneqOffset ] - b_c ; TrialState -> xstar [ idxIneqOffset ] = b_c ; } success = ( xnrm2_zbVenBlk ( nVar , TrialState -> socDirection ) <= 2.0 * xnrm2_zbVenBlk ( nVar , TrialState -> xstar ) ) ; for ( nVar = 0 ; nVar <= 18 ; nVar += 2 ) { tmp_p = _mm_loadu_pd ( & TrialState -> cEq [ nVar ] ) ; _mm_storeu_pd ( & WorkingSet -> beq [ nVar ] , _mm_mul_pd ( tmp_p , _mm_set1_pd ( - 1.0 ) ) ) ; } for ( nVar = 0 ; nVar < 20 ; nVar ++ ) { WorkingSet -> bwset [ WorkingSet -> sizes [ 0 ] + nVar ] = WorkingSet -> beq [ nVar ] ; } for ( nVar = 0 ; nVar <= 52 ; nVar += 2 ) { tmp_p = _mm_loadu_pd ( & TrialState -> cIneq [ nVar ] ) ; _mm_storeu_pd ( & WorkingSet -> bineq [ nVar ] , _mm_mul_pd ( tmp_p , _mm_set1_pd ( - 1.0 ) ) ) ; } if ( ! success ) { idx_Aineq = WorkingSet -> nWConstr [ 0 ] + WorkingSet -> nWConstr [ 1 ] ; idxIneqOffset = idx_Aineq + 1 ; idxEndIneq = WorkingSet -> nActiveConstr ; for ( nVar = idxIneqOffset ; nVar <= idxEndIneq ; nVar ++ ) { WorkingSet -> isActiveConstr [ ( WorkingSet -> isActiveIdx [ WorkingSet -> Wid [ nVar - 1 ] - 1 ] + WorkingSet -> Wlocalidx [ nVar - 1 ] ) - 2 ] = false ; } WorkingSet -> nWConstr [ 2 ] = 0 ; WorkingSet -> nWConstr [ 3 ] = 0 ; WorkingSet -> nWConstr [ 4 ] = 0 ; WorkingSet -> nActiveConstr = idx_Aineq ; for ( nVar = 0 ; nVar < nWIneq_old ; nVar ++ ) { p22oac0uqf ( WorkingSet , TrialState -> workingset_old [ nVar ] ) ; } for ( nWIneq_old = 0 ; nWIneq_old < nWLower_old ; nWIneq_old ++ ) { dywa1naf0c ( WorkingSet , 4 , TrialState -> workingset_old [ nWIneq_old + 54 ] ) ; } for ( nWLower_old = 0 ; nWLower_old < nWUpper_old ; nWLower_old ++ ) { dywa1naf0c ( WorkingSet , 5 , TrialState -> workingset_old [ ( nWLower_old + WorkingSet -> sizes [ 3 ] ) + 54 ] ) ; } memcpy ( & TrialState -> lambda [ 0 ] , & TrialState -> lambdaStopTest [ 0 ] , 221U * sizeof ( real_T ) ) ; } else { myxjrkt4iq ( TrialState -> lambda , WorkingSet -> nActiveConstr , WorkingSet -> sizes , WorkingSet -> isActiveIdx , WorkingSet -> Wid , WorkingSet -> Wlocalidx , memspace -> workspace_float ) ; } return success ; } static real_T p3kkfowucm ( const c3tcu1vsoj * obj , const real_T x [ 121 ] , d4m2qnxaxx * localB ) { real_T v ; int32_T b ; int32_T idx ; if ( obj -> probType == 2 ) { localB -> b_obj = * obj ; v = kkqgbfnbrg ( & localB -> b_obj , x ) ; } else { localB -> b_obj = * obj ; v = bjypmi3wva ( & localB -> b_obj , x ) ; } if ( obj -> sizes [ 3 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 3 ] ; for ( idx = 0 ; idx < b ; idx ++ ) { v = muDoubleScalarMax ( v , - x [ localB -> b_obj . indexLB [ idx ] - 1 ] - localB -> b_obj . lb [ localB -> b_obj . indexLB [ idx ] - 1 ] ) ; } } if ( obj -> sizes [ 4 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 4 ] ; for ( idx = 0 ; idx < b ; idx ++ ) { v = muDoubleScalarMax ( v , x [ localB -> b_obj . indexUB [ idx ] - 1 ] - localB -> b_obj . ub [ localB -> b_obj . indexUB [ idx ] - 1 ] ) ; } } if ( obj -> sizes [ 0 ] > 0 ) { b = ( uint8_T ) obj -> sizes [ 0 ] ; for ( idx = 0 ; idx < b ; idx ++ ) { v = muDoubleScalarMax ( v , muDoubleScalarAbs ( x [ localB -> b_obj . indexFixed [ idx ] - 1 ] - localB -> b_obj . ub [ localB -> b_obj . indexFixed [ idx ] - 1 ] ) ) ; } } return v ; } static void okx5oukmjm ( const real_T Hessian [ 676 ] , const real_T grad [ 121 ] , ci1jcnwvc5 * TrialState , bhtu1h5bl5 * MeritFunction , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , kzv4ftj4e2 * CholManager , iamwnmrrfd * QPObjective , const i4h2yyndkb * qpoptions , drf2ph4ldh * stepFlags , d4m2qnxaxx * localB ) { real_T TrialState_cIneq ; real_T constrViolationEq ; real_T constrViolationIneq ; real_T penaltyParamTrial ; int32_T k ; boolean_T isEqAndIneqFeasible ; ckrin4u0eh1 ( Hessian , grad , TrialState , memspace , WorkingSet , QRManager , CholManager , QPObjective , qpoptions , qpoptions , localB ) ; isEqAndIneqFeasible = ( p3kkfowucm ( WorkingSet , TrialState -> xstar , localB ) <= 1.0E-6 ) ; if ( ( TrialState -> state > 0 ) || ( ( TrialState -> state == 0 ) && isEqAndIneqFeasible ) ) { penaltyParamTrial = MeritFunction -> penaltyParam ; constrViolationEq = 0.0 ; for ( k = 0 ; k < 20 ; k ++ ) { constrViolationEq += muDoubleScalarAbs ( TrialState -> cEq [ k ] ) ; } constrViolationIneq = 0.0 ; for ( k = 0 ; k < 54 ; k ++ ) { TrialState_cIneq = TrialState -> cIneq [ k ] ; if ( TrialState_cIneq > 0.0 ) { constrViolationIneq += TrialState_cIneq ; } } constrViolationEq += constrViolationIneq ; constrViolationIneq = MeritFunction -> linearizedConstrViol ; MeritFunction -> linearizedConstrViol = 0.0 ; constrViolationIneq += constrViolationEq ; if ( ( constrViolationIneq > 2.2204460492503131E-16 ) && ( TrialState -> fstar > 0.0 ) ) { if ( TrialState -> sqpFval == 0.0 ) { penaltyParamTrial = 1.0 ; } else { penaltyParamTrial = 1.5 ; } penaltyParamTrial = penaltyParamTrial * TrialState -> fstar / constrViolationIneq ; } if ( penaltyParamTrial < MeritFunction -> penaltyParam ) { MeritFunction -> phi = penaltyParamTrial * constrViolationEq + TrialState -> sqpFval ; if ( ( ( MeritFunction -> initConstrViolationEq + MeritFunction -> initConstrViolationIneq ) * penaltyParamTrial + MeritFunction -> initFval ) - MeritFunction -> phi > ( real_T ) MeritFunction -> nPenaltyDecreases * MeritFunction -> threshold ) { MeritFunction -> nPenaltyDecreases ++ ; if ( ( MeritFunction -> nPenaltyDecreases << 1 ) > TrialState -> sqpIterations ) { MeritFunction -> threshold *= 10.0 ; } MeritFunction -> penaltyParam = muDoubleScalarMax ( penaltyParamTrial , 1.0E-10 ) ; } else { MeritFunction -> phi = MeritFunction -> penaltyParam * constrViolationEq + TrialState -> sqpFval ; } } else { MeritFunction -> penaltyParam = muDoubleScalarMax ( penaltyParamTrial , 1.0E-10 ) ; MeritFunction -> phi = MeritFunction -> penaltyParam * constrViolationEq + TrialState -> sqpFval ; } MeritFunction -> phiPrimePlus = muDoubleScalarMin ( TrialState -> fstar - MeritFunction -> penaltyParam * constrViolationEq , 0.0 ) ; } else if ( TrialState -> state != - 6 ) { stepFlags -> stepType = 2 ; } myxjrkt4iq ( TrialState -> lambda , WorkingSet -> nActiveConstr , WorkingSet -> sizes , WorkingSet -> isActiveIdx , WorkingSet -> Wid , WorkingSet -> Wlocalidx , memspace -> workspace_float ) ; isEqAndIneqFeasible = ( WorkingSet -> mEqRemoved > 0 ) ; while ( ( WorkingSet -> mEqRemoved > 0 ) && ( WorkingSet -> indexEqRemoved [ WorkingSet -> mEqRemoved - 1 ] >= 1 ) ) { dudfwmvulx ( WorkingSet , WorkingSet -> indexEqRemoved [ WorkingSet -> mEqRemoved - 1 ] ) ; WorkingSet -> mEqRemoved -- ; } if ( isEqAndIneqFeasible ) { for ( k = 0 ; k < 20 ; k ++ ) { WorkingSet -> Wlocalidx [ WorkingSet -> sizes [ 0 ] + k ] = k + 1 ; } } } static void g2ye2po1ca ( const real_T Hessian [ 676 ] , const real_T grad [ 121 ] , ci1jcnwvc5 * TrialState , bhtu1h5bl5 * MeritFunction , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , kzv4ftj4e2 * CholManager , iamwnmrrfd * QPObjective , i4h2yyndkb * qpoptions , d4m2qnxaxx * localB ) { __m128d tmp ; real_T beta ; real_T qpfvalQuadExcess ; real_T qpfvalQuadExcess_tmp ; real_T s ; real_T smax ; int32_T d ; int32_T h_idx ; int32_T idx_max ; int32_T mLBOrig ; int32_T nVarOrig ; boolean_T b_tf ; boolean_T tf ; nVarOrig = WorkingSet -> nVar ; beta = 0.0 ; idx_max = ( uint8_T ) WorkingSet -> nVar ; for ( h_idx = 0 ; h_idx < idx_max ; h_idx ++ ) { beta += Hessian [ 26 * h_idx + h_idx ] ; } beta /= ( real_T ) WorkingSet -> nVar ; if ( TrialState -> sqpIterations <= 1 ) { mLBOrig = QPObjective -> nvar ; if ( QPObjective -> nvar < 1 ) { idx_max = 0 ; } else { idx_max = 1 ; if ( QPObjective -> nvar > 1 ) { smax = muDoubleScalarAbs ( grad [ 0 ] ) ; for ( h_idx = 2 ; h_idx <= mLBOrig ; h_idx ++ ) { s = muDoubleScalarAbs ( grad [ h_idx - 1 ] ) ; if ( s > smax ) { idx_max = h_idx ; smax = s ; } } } } smax = muDoubleScalarMax ( 1.0 , muDoubleScalarAbs ( grad [ idx_max - 1 ] ) ) * 100.0 ; } else { mLBOrig = WorkingSet -> mConstr ; idx_max = 1 ; smax = muDoubleScalarAbs ( TrialState -> lambdasqp [ 0 ] ) ; for ( h_idx = 2 ; h_idx <= mLBOrig ; h_idx ++ ) { s = muDoubleScalarAbs ( TrialState -> lambdasqp [ h_idx - 1 ] ) ; if ( s > smax ) { idx_max = h_idx ; smax = s ; } } smax = muDoubleScalarAbs ( TrialState -> lambdasqp [ idx_max - 1 ] ) ; } QPObjective -> nvar = WorkingSet -> nVar ; QPObjective -> beta = beta ; QPObjective -> rho = smax ; QPObjective -> hasLinear = true ; QPObjective -> objtype = 4 ; localB -> c_WorkingSet = * WorkingSet ; i3lcleconb ( & localB -> c_WorkingSet , 2 ) ; mLBOrig = localB -> c_WorkingSet . sizes [ 3 ] - 39 ; memcpy ( & memspace -> workspace_float [ 0 ] , & localB -> c_WorkingSet . bineq [ 0 ] , 54U * sizeof ( real_T ) ) ; xgemv_FKeSanhE ( WorkingSet -> nVar , localB -> c_WorkingSet . Aineq , TrialState -> xstar , memspace -> workspace_float ) ; for ( h_idx = 0 ; h_idx < 54 ; h_idx ++ ) { s = memspace -> workspace_float [ h_idx ] ; TrialState -> xstar [ nVarOrig + h_idx ] = ( real_T ) ( s > 0.0 ) * s ; } for ( h_idx = 0 ; h_idx <= 18 ; h_idx += 2 ) { tmp = _mm_loadu_pd ( & localB -> c_WorkingSet . beq [ h_idx ] ) ; _mm_storeu_pd ( & memspace -> workspace_float [ h_idx ] , _mm_mul_pd ( tmp , _mm_set1_pd ( - 1.0 ) ) ) ; } for ( h_idx = 0 ; h_idx <= 2299 ; h_idx += 121 ) { s = 0.0 ; d = h_idx + nVarOrig ; for ( idx_max = h_idx + 1 ; idx_max <= d ; idx_max ++ ) { s += TrialState -> xstar [ ( idx_max - h_idx ) - 1 ] * localB -> c_WorkingSet . Aeq [ idx_max - 1 ] ; } d = div_nde_s32_floor ( h_idx , 121 ) ; memspace -> workspace_float [ d ] += s ; } for ( h_idx = 0 ; h_idx < 20 ; h_idx ++ ) { s = memspace -> workspace_float [ h_idx ] ; if ( s <= 0.0 ) { d = nVarOrig + h_idx ; TrialState -> xstar [ d + 54 ] = 0.0 ; TrialState -> xstar [ d + 74 ] = - s ; d = mLBOrig + h_idx ; dywa1naf0c ( & localB -> c_WorkingSet , 4 , d ) ; if ( s >= - 1.0E-6 ) { dywa1naf0c ( & localB -> c_WorkingSet , 4 , d + 20 ) ; } } else { d = nVarOrig + h_idx ; TrialState -> xstar [ d + 54 ] = s ; TrialState -> xstar [ d + 74 ] = 0.0 ; d = mLBOrig + h_idx ; dywa1naf0c ( & localB -> c_WorkingSet , 4 , d + 20 ) ; if ( s <= 1.0E-6 ) { dywa1naf0c ( & localB -> c_WorkingSet , 4 , d ) ; } } } nVarOrig = qpoptions -> MaxIterations ; qpoptions -> MaxIterations = ( qpoptions -> MaxIterations + localB -> c_WorkingSet . nVar ) - WorkingSet -> nVar ; ckrin4u0eh1 ( Hessian , grad , TrialState , memspace , & localB -> c_WorkingSet , QRManager , CholManager , QPObjective , qpoptions , qpoptions , localB ) ; qpoptions -> MaxIterations = nVarOrig ; idx_max = localB -> c_WorkingSet . sizes [ 3 ] - 95 ; nVarOrig = 0 ; for ( h_idx = 0 ; h_idx < 20 ; h_idx ++ ) { mLBOrig = ( localB -> c_WorkingSet . isActiveIdx [ 3 ] + idx_max ) + h_idx ; tf = localB -> c_WorkingSet . isActiveConstr [ mLBOrig + 54 ] ; b_tf = localB -> c_WorkingSet . isActiveConstr [ mLBOrig + 74 ] ; memspace -> workspace_int [ h_idx ] = tf ; memspace -> workspace_int [ h_idx + 20 ] = b_tf ; nVarOrig = ( nVarOrig + tf ) + b_tf ; } for ( h_idx = 0 ; h_idx < 54 ; h_idx ++ ) { d = localB -> c_WorkingSet . isActiveConstr [ ( localB -> c_WorkingSet . isActiveIdx [ 3 ] + idx_max ) + h_idx ] ; memspace -> workspace_int [ h_idx + 40 ] = d ; nVarOrig += d ; } if ( TrialState -> state != - 6 ) { mLBOrig = WorkingSet -> nVar + 1 ; s = 0.0 ; if ( 120 - WorkingSet -> nVar >= 1 ) { for ( h_idx = mLBOrig ; h_idx < 121 ; h_idx ++ ) { s += muDoubleScalarAbs ( TrialState -> xstar [ h_idx - 1 ] ) ; } } qpfvalQuadExcess = 0.0 ; if ( 120 - WorkingSet -> nVar >= 1 ) { idx_max = ( uint8_T ) ( 120 - WorkingSet -> nVar ) ; for ( h_idx = 0 ; h_idx < idx_max ; h_idx ++ ) { qpfvalQuadExcess_tmp = TrialState -> xstar [ WorkingSet -> nVar + h_idx ] ; qpfvalQuadExcess += qpfvalQuadExcess_tmp * qpfvalQuadExcess_tmp ; } } beta = ( TrialState -> fstar - smax * s ) - beta / 2.0 * qpfvalQuadExcess ; smax = MeritFunction -> penaltyParam ; s = 0.0 ; for ( h_idx = 0 ; h_idx < 20 ; h_idx ++ ) { s += muDoubleScalarAbs ( TrialState -> cEq [ h_idx ] ) ; } qpfvalQuadExcess = 0.0 ; for ( h_idx = 0 ; h_idx < 54 ; h_idx ++ ) { qpfvalQuadExcess_tmp = TrialState -> cIneq [ h_idx ] ; if ( qpfvalQuadExcess_tmp > 0.0 ) { qpfvalQuadExcess += qpfvalQuadExcess_tmp ; } } s += qpfvalQuadExcess ; qpfvalQuadExcess = MeritFunction -> linearizedConstrViol ; qpfvalQuadExcess_tmp = 0.0 ; if ( 120 - WorkingSet -> nVar >= 1 ) { for ( h_idx = mLBOrig ; h_idx < 121 ; h_idx ++ ) { qpfvalQuadExcess_tmp += muDoubleScalarAbs ( TrialState -> xstar [ h_idx - 1 ] ) ; } } MeritFunction -> linearizedConstrViol = qpfvalQuadExcess_tmp ; qpfvalQuadExcess = ( s + qpfvalQuadExcess ) - qpfvalQuadExcess_tmp ; if ( ( qpfvalQuadExcess > 2.2204460492503131E-16 ) && ( beta > 0.0 ) ) { if ( TrialState -> sqpFval == 0.0 ) { smax = 1.0 ; } else { smax = 1.5 ; } smax = smax * beta / qpfvalQuadExcess ; } if ( smax < MeritFunction -> penaltyParam ) { MeritFunction -> phi = smax * s + TrialState -> sqpFval ; if ( ( ( MeritFunction -> initConstrViolationEq + MeritFunction -> initConstrViolationIneq ) * smax + MeritFunction -> initFval ) - MeritFunction -> phi > ( real_T ) MeritFunction -> nPenaltyDecreases * MeritFunction -> threshold ) { MeritFunction -> nPenaltyDecreases ++ ; if ( ( MeritFunction -> nPenaltyDecreases << 1 ) > TrialState -> sqpIterations ) { MeritFunction -> threshold *= 10.0 ; } MeritFunction -> penaltyParam = muDoubleScalarMax ( smax , 1.0E-10 ) ; } else { MeritFunction -> phi = MeritFunction -> penaltyParam * s + TrialState -> sqpFval ; } } else { MeritFunction -> penaltyParam = muDoubleScalarMax ( smax , 1.0E-10 ) ; MeritFunction -> phi = MeritFunction -> penaltyParam * s + TrialState -> sqpFval ; } MeritFunction -> phiPrimePlus = muDoubleScalarMin ( beta - MeritFunction -> penaltyParam * s , 0.0 ) ; idx_max = localB -> c_WorkingSet . isActiveIdx [ 1 ] - 1 ; for ( h_idx = 0 ; h_idx < 20 ; h_idx ++ ) { if ( ( memspace -> workspace_int [ h_idx ] != 0 ) && ( memspace -> workspace_int [ h_idx + 20 ] != 0 ) ) { tf = true ; } else { tf = false ; } d = idx_max + h_idx ; TrialState -> lambda [ d ] *= ( real_T ) tf ; } idx_max = localB -> c_WorkingSet . isActiveIdx [ 2 ] ; mLBOrig = localB -> c_WorkingSet . nActiveConstr ; for ( h_idx = idx_max ; h_idx <= mLBOrig ; h_idx ++ ) { if ( localB -> c_WorkingSet . Wid [ h_idx - 1 ] == 3 ) { TrialState -> lambda [ h_idx - 1 ] *= ( real_T ) memspace -> workspace_int [ localB -> c_WorkingSet . Wlocalidx [ h_idx - 1 ] + 39 ] ; } } } h_idx = localB -> c_WorkingSet . nActiveConstr ; while ( ( h_idx > localB -> c_WorkingSet . sizes [ 0 ] + 20 ) && ( nVarOrig > 0 ) ) { if ( ( localB -> c_WorkingSet . Wid [ h_idx - 1 ] == 4 ) && ( localB -> c_WorkingSet . Wlocalidx [ h_idx - 1 ] > localB -> c_WorkingSet . sizes [ 3 ] - 94 ) ) { beta = TrialState -> lambda [ localB -> c_WorkingSet . nActiveConstr - 1 ] ; TrialState -> lambda [ localB -> c_WorkingSet . nActiveConstr - 1 ] = 0.0 ; TrialState -> lambda [ h_idx - 1 ] = beta ; ozc3jikxh0 ( & localB -> c_WorkingSet , h_idx ) ; nVarOrig -- ; } h_idx -- ; } QPObjective -> nvar = WorkingSet -> nVar ; QPObjective -> hasLinear = true ; QPObjective -> objtype = 3 ; * WorkingSet = localB -> c_WorkingSet ; i3lcleconb ( WorkingSet , 3 ) ; myxjrkt4iq ( TrialState -> lambda , WorkingSet -> nActiveConstr , WorkingSet -> sizes , WorkingSet -> isActiveIdx , WorkingSet -> Wid , WorkingSet -> Wlocalidx , memspace -> workspace_float ) ; } static void bkzwtwyp4q ( drf2ph4ldh * stepFlags , real_T Hessian [ 676 ] , const real_T lb [ 26 ] , const real_T ub [ 26 ] , ci1jcnwvc5 * TrialState , bhtu1h5bl5 * MeritFunction , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , kzv4ftj4e2 * CholManager , iamwnmrrfd * QPObjective , i4h2yyndkb * qpoptions , d4m2qnxaxx * localB ) { __m128d tmp ; __m128d tmp_p ; real_T j [ 121 ] ; real_T tmp_e [ 2 ] ; real_T nrmDirInf ; real_T nrmGradInf ; int32_T exitg1 ; int32_T idxEndIneq ; int32_T idxStartIneq ; int32_T k ; int32_T nVar ; int32_T vectorUB ; boolean_T checkBoundViolation ; boolean_T guard1 ; stepFlags -> stepAccepted = true ; checkBoundViolation = true ; nVar = WorkingSet -> nVar - 1 ; if ( stepFlags -> stepType != 3 ) { memcpy ( & TrialState -> xstar [ 0 ] , & TrialState -> xstarsqp [ 0 ] , ( uint8_T ) WorkingSet -> nVar * sizeof ( real_T ) ) ; } else if ( WorkingSet -> nVar - 1 >= 0 ) { memcpy ( & TrialState -> searchDir [ 0 ] , & TrialState -> xstar [ 0 ] , ( uint32_T ) ( ( WorkingSet -> nVar - 1 ) + 1 ) * sizeof ( real_T ) ) ; } do { exitg1 = 0 ; guard1 = false ; switch ( stepFlags -> stepType ) { case 1 : okx5oukmjm ( Hessian , TrialState -> grad , TrialState , MeritFunction , memspace , WorkingSet , QRManager , CholManager , QPObjective , qpoptions , stepFlags , localB ) ; if ( stepFlags -> stepType == 2 ) { } else { if ( nVar >= 0 ) { memcpy ( & TrialState -> delta_x [ 0 ] , & TrialState -> xstar [ 0 ] , ( uint32_T ) ( nVar + 1 ) * sizeof ( real_T ) ) ; } guard1 = true ; } break ; case 2 : vectorUB = WorkingSet -> nWConstr [ 0 ] + WorkingSet -> nWConstr [ 1 ] ; idxStartIneq = vectorUB + 1 ; idxEndIneq = WorkingSet -> nActiveConstr ; for ( k = idxStartIneq ; k <= idxEndIneq ; k ++ ) { WorkingSet -> isActiveConstr [ ( WorkingSet -> isActiveIdx [ WorkingSet -> Wid [ k - 1 ] - 1 ] + WorkingSet -> Wlocalidx [ k - 1 ] ) - 2 ] = false ; } WorkingSet -> nWConstr [ 2 ] = 0 ; WorkingSet -> nWConstr [ 3 ] = 0 ; WorkingSet -> nWConstr [ 4 ] = 0 ; WorkingSet -> nActiveConstr = vectorUB ; memcpy ( & j [ 0 ] , & TrialState -> xstar [ 0 ] , 121U * sizeof ( real_T ) ) ; idxStartIneq = ( uint8_T ) WorkingSet -> sizes [ 3 ] ; for ( k = 0 ; k < idxStartIneq ; k ++ ) { nrmGradInf = WorkingSet -> lb [ WorkingSet -> indexLB [ k ] - 1 ] ; if ( - j [ WorkingSet -> indexLB [ k ] - 1 ] > nrmGradInf ) { if ( muDoubleScalarIsInf ( ub [ WorkingSet -> indexLB [ k ] - 1 ] ) ) { j [ WorkingSet -> indexLB [ k ] - 1 ] = - nrmGradInf + muDoubleScalarAbs ( nrmGradInf ) ; } else { j [ WorkingSet -> indexLB [ k ] - 1 ] = ( WorkingSet -> ub [ WorkingSet -> indexLB [ k ] - 1 ] - nrmGradInf ) / 2.0 ; } } } idxStartIneq = ( uint8_T ) WorkingSet -> sizes [ 4 ] ; for ( k = 0 ; k < idxStartIneq ; k ++ ) { nrmGradInf = WorkingSet -> ub [ WorkingSet -> indexUB [ k ] - 1 ] ; if ( j [ WorkingSet -> indexUB [ k ] - 1 ] > nrmGradInf ) { if ( muDoubleScalarIsInf ( lb [ WorkingSet -> indexUB [ k ] - 1 ] ) ) { j [ WorkingSet -> indexUB [ k ] - 1 ] = nrmGradInf - muDoubleScalarAbs ( nrmGradInf ) ; } else { j [ WorkingSet -> indexUB [ k ] - 1 ] = ( nrmGradInf - WorkingSet -> lb [ WorkingSet -> indexUB [ k ] - 1 ] ) / 2.0 ; } } } memcpy ( & TrialState -> xstar [ 0 ] , & j [ 0 ] , 121U * sizeof ( real_T ) ) ; g2ye2po1ca ( Hessian , TrialState -> grad , TrialState , MeritFunction , memspace , WorkingSet , QRManager , CholManager , QPObjective , qpoptions , localB ) ; if ( nVar >= 0 ) { memcpy ( & TrialState -> delta_x [ 0 ] , & TrialState -> xstar [ 0 ] , ( uint32_T ) ( nVar + 1 ) * sizeof ( real_T ) ) ; } guard1 = true ; break ; default : checkBoundViolation = l1cacwyidk ( Hessian , TrialState -> grad , TrialState , memspace , WorkingSet , QRManager , CholManager , QPObjective , qpoptions , localB ) ; stepFlags -> stepAccepted = checkBoundViolation ; if ( stepFlags -> stepAccepted && ( TrialState -> state != - 6 ) ) { idxStartIneq = ( uint8_T ) ( nVar + 1 ) ; idxEndIneq = ( ( uint8_T ) ( nVar + 1 ) / 2 ) << 1 ; vectorUB = idxEndIneq - 2 ; for ( k = 0 ; k <= vectorUB ; k += 2 ) { tmp = _mm_loadu_pd ( & TrialState -> xstar [ k ] ) ; tmp_p = _mm_loadu_pd ( & TrialState -> socDirection [ k ] ) ; _mm_storeu_pd ( & TrialState -> delta_x [ k ] , _mm_add_pd ( tmp , tmp_p ) ) ; } for ( k = idxEndIneq ; k < idxStartIneq ; k ++ ) { TrialState -> delta_x [ k ] = TrialState -> xstar [ k ] + TrialState -> socDirection [ k ] ; } } guard1 = true ; break ; } if ( guard1 ) { if ( TrialState -> state != - 6 ) { exitg1 = 1 ; } else { nrmGradInf = 0.0 ; nrmDirInf = 1.0 ; for ( k = 0 ; k < 26 ; k ++ ) { nrmGradInf = muDoubleScalarMax ( nrmGradInf , muDoubleScalarAbs ( TrialState -> grad [ k ] ) ) ; nrmDirInf = muDoubleScalarMax ( nrmDirInf , muDoubleScalarAbs ( TrialState -> xstar [ k ] ) ) ; } nrmGradInf = muDoubleScalarMax ( 2.2204460492503131E-16 , nrmGradInf / nrmDirInf ) ; for ( k = 0 ; k < 26 ; k ++ ) { idxEndIneq = 26 * k ; for ( idxStartIneq = 0 ; idxStartIneq < k ; idxStartIneq ++ ) { Hessian [ idxEndIneq + idxStartIneq ] = 0.0 ; } vectorUB = 26 * k + k ; Hessian [ vectorUB ] = nrmGradInf ; idxEndIneq = 24 - k ; for ( idxStartIneq = 0 ; idxStartIneq <= idxEndIneq ; idxStartIneq ++ ) { Hessian [ ( vectorUB + idxStartIneq ) + 1 ] = 0.0 ; } } } } } while ( exitg1 == 0 ) ; if ( checkBoundViolation ) { memcpy ( & j [ 0 ] , & TrialState -> delta_x [ 0 ] , 121U * sizeof ( real_T ) ) ; k = ( uint8_T ) WorkingSet -> sizes [ 3 ] ; for ( nVar = 0 ; nVar < k ; nVar ++ ) { nrmDirInf = j [ WorkingSet -> indexLB [ nVar ] - 1 ] ; nrmGradInf = ( TrialState -> xstarsqp [ WorkingSet -> indexLB [ nVar ] - 1 ] + nrmDirInf ) - lb [ WorkingSet -> indexLB [ nVar ] - 1 ] ; if ( nrmGradInf < 0.0 ) { _mm_storeu_pd ( & tmp_e [ 0 ] , _mm_sub_pd ( _mm_set_pd ( TrialState -> xstar [ WorkingSet -> indexLB [ nVar ] - 1 ] , nrmDirInf ) , _mm_set1_pd ( nrmGradInf ) ) ) ; j [ WorkingSet -> indexLB [ nVar ] - 1 ] = tmp_e [ 0 ] ; TrialState -> xstar [ WorkingSet -> indexLB [ nVar ] - 1 ] = tmp_e [ 1 ] ; } } k = ( uint8_T ) WorkingSet -> sizes [ 4 ] ; for ( nVar = 0 ; nVar < k ; nVar ++ ) { nrmDirInf = j [ WorkingSet -> indexUB [ nVar ] - 1 ] ; nrmGradInf = ( ub [ WorkingSet -> indexUB [ nVar ] - 1 ] - TrialState -> xstarsqp [ WorkingSet -> indexUB [ nVar ] - 1 ] ) - nrmDirInf ; if ( nrmGradInf < 0.0 ) { _mm_storeu_pd ( & tmp_e [ 0 ] , _mm_add_pd ( _mm_set_pd ( TrialState -> xstar [ WorkingSet -> indexUB [ nVar ] - 1 ] , nrmDirInf ) , _mm_set1_pd ( nrmGradInf ) ) ) ; j [ WorkingSet -> indexUB [ nVar ] - 1 ] = tmp_e [ 0 ] ; TrialState -> xstar [ WorkingSet -> indexUB [ nVar ] - 1 ] = tmp_e [ 1 ] ; } } memcpy ( & TrialState -> delta_x [ 0 ] , & j [ 0 ] , 121U * sizeof ( real_T ) ) ; } } static void fw12bnjdboi ( real_T fscales_objective , int32_T nVar , const real_T gradLag [ 26741 ] , boolean_T * gradOK , real_T * val ) { int32_T exitg1 ; int32_T idx ; * gradOK = true ; * val = 0.0 ; idx = 0 ; do { exitg1 = 0 ; if ( idx <= ( uint8_T ) nVar - 1 ) { * gradOK = ( ( ! muDoubleScalarIsInf ( gradLag [ idx ] ) ) && ( ! muDoubleScalarIsNaN ( gradLag [ idx ] ) ) ) ; if ( ! * gradOK ) { exitg1 = 1 ; } else { * val = muDoubleScalarMax ( * val , muDoubleScalarAbs ( gradLag [ idx ] ) ) ; idx ++ ; } } else { * val /= fscales_objective ; exitg1 = 1 ; } } while ( exitg1 == 0 ) ; } static void crspy0yej2a ( drf2ph4ldh * Flags , kmbpuy2anc * memspace , bhtu1h5bl5 * MeritFunction , real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , c3tcu1vsoj * WorkingSet , ci1jcnwvc5 * TrialState , oytx5zapfu * QRManager , const real_T lb [ 26 ] , const real_T ub [ 26 ] ) { real_T nlpComplErrorTmp ; real_T s ; real_T smax ; real_T tmp ; int32_T c_ix ; int32_T idx_max ; int32_T idx_max_tmp ; int32_T ix ; int32_T jjA ; int32_T minDim ; int32_T nVar ; boolean_T dxTooSmall ; boolean_T exitg1 ; boolean_T guard1 ; boolean_T isFeasible ; nVar = WorkingSet -> nVar ; idx_max_tmp = ( uint16_T ) ( ( ( WorkingSet -> sizes [ 0 ] + WorkingSet -> sizes [ 3 ] ) + WorkingSet -> sizes [ 4 ] ) + 74 ) ; memcpy ( & TrialState -> lambdaStopTest [ 0 ] , & TrialState -> lambdasqp [ 0 ] , ( uint32_T ) idx_max_tmp * sizeof ( real_T ) ) ; computeGradLag_RU6nJ0OR ( TrialState -> gradLag , WorkingSet -> nVar , TrialState -> grad , WorkingSet -> Aineq , WorkingSet -> Aeq , WorkingSet -> indexFixed , WorkingSet -> sizes [ 0 ] , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , TrialState -> lambdaStopTest ) ; if ( WorkingSet -> nVar < 1 ) { idx_max = 0 ; } else { idx_max = 1 ; if ( WorkingSet -> nVar > 1 ) { smax = muDoubleScalarAbs ( TrialState -> grad [ 0 ] ) ; for ( minDim = 2 ; minDim <= nVar ; minDim ++ ) { s = muDoubleScalarAbs ( TrialState -> grad [ minDim - 1 ] ) ; if ( s > smax ) { idx_max = minDim ; smax = s ; } } } } smax = muDoubleScalarMax ( 1.0 , muDoubleScalarAbs ( TrialState -> grad [ idx_max - 1 ] ) / fscales_objective ) ; if ( muDoubleScalarIsInf ( smax ) ) { smax = 1.0 ; } MeritFunction -> nlpPrimalFeasError = iqfbbuti1d ( fscales_cineq_constraint , fscales_ceq_constraint , TrialState -> xstarsqp , TrialState -> cIneq , TrialState -> cEq , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , lb , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , ub ) ; if ( TrialState -> sqpIterations == 0 ) { MeritFunction -> feasRelativeFactor = muDoubleScalarMax ( 1.0 , MeritFunction -> nlpPrimalFeasError ) ; } isFeasible = ( MeritFunction -> nlpPrimalFeasError <= 1.0E-6 * MeritFunction -> feasRelativeFactor ) ; fw12bnjdbo ( fscales_objective , WorkingSet -> nVar , TrialState -> gradLag , & Flags -> gradOK , & MeritFunction -> nlpDualFeasError ) ; if ( ! Flags -> gradOK ) { Flags -> done = true ; if ( isFeasible ) { TrialState -> sqpExitFlag = 2 ; } else { TrialState -> sqpExitFlag = - 2 ; } } else { MeritFunction -> nlpComplError = efjv1gsbna ( fscales_objective , fscales_cineq_constraint , TrialState -> xstarsqp , TrialState -> cIneq , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , lb , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , ub , TrialState -> lambdaStopTest , WorkingSet -> sizes [ 0 ] + 21 ) ; MeritFunction -> firstOrderOpt = muDoubleScalarMax ( MeritFunction -> nlpDualFeasError , MeritFunction -> nlpComplError ) ; if ( TrialState -> sqpIterations > 1 ) { computeGradLag_pqhj2Pn4 ( memspace -> workspace_float , WorkingSet -> nVar , TrialState -> grad , WorkingSet -> Aineq , WorkingSet -> Aeq , WorkingSet -> indexFixed , WorkingSet -> sizes [ 0 ] , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , TrialState -> lambdaStopTestPrev ) ; fw12bnjdboi ( fscales_objective , WorkingSet -> nVar , memspace -> workspace_float , & dxTooSmall , & s ) ; nlpComplErrorTmp = efjv1gsbna ( fscales_objective , fscales_cineq_constraint , TrialState -> xstarsqp , TrialState -> cIneq , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , lb , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , ub , TrialState -> lambdaStopTestPrev , WorkingSet -> sizes [ 0 ] + 21 ) ; if ( ( s < MeritFunction -> nlpDualFeasError ) && ( nlpComplErrorTmp < MeritFunction -> nlpComplError ) ) { MeritFunction -> nlpDualFeasError = s ; MeritFunction -> nlpComplError = nlpComplErrorTmp ; MeritFunction -> firstOrderOpt = muDoubleScalarMax ( s , nlpComplErrorTmp ) ; memcpy ( & TrialState -> lambdaStopTest [ 0 ] , & TrialState -> lambdaStopTestPrev [ 0 ] , ( uint32_T ) idx_max_tmp * sizeof ( real_T ) ) ; } else { memcpy ( & TrialState -> lambdaStopTestPrev [ 0 ] , & TrialState -> lambdaStopTest [ 0 ] , ( uint32_T ) idx_max_tmp * sizeof ( real_T ) ) ; } } else { memcpy ( & TrialState -> lambdaStopTestPrev [ 0 ] , & TrialState -> lambdaStopTest [ 0 ] , ( uint32_T ) idx_max_tmp * sizeof ( real_T ) ) ; } if ( isFeasible && ( MeritFunction -> nlpDualFeasError <= 1.0E-6 * smax ) && ( MeritFunction -> nlpComplError <= 1.0E-6 * smax ) ) { Flags -> done = true ; TrialState -> sqpExitFlag = 1 ; } else { Flags -> done = false ; if ( isFeasible && ( TrialState -> sqpFval / fscales_objective < - 1.0E+20 ) ) { Flags -> done = true ; TrialState -> sqpExitFlag = - 3 ; } else { guard1 = false ; if ( TrialState -> sqpIterations > 0 ) { dxTooSmall = true ; minDim = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( minDim <= ( uint8_T ) WorkingSet -> nVar - 1 ) ) { if ( 1.0E-6 * muDoubleScalarMax ( 1.0 , muDoubleScalarAbs ( TrialState -> xstarsqp [ minDim ] ) ) <= muDoubleScalarAbs ( TrialState -> delta_x [ minDim ] ) ) { dxTooSmall = false ; exitg1 = true ; } else { minDim ++ ; } } if ( dxTooSmall ) { if ( ! isFeasible ) { if ( Flags -> stepType == 2 ) { Flags -> done = true ; TrialState -> sqpExitFlag = - 2 ; } else { Flags -> stepType = 2 ; Flags -> failedLineSearch = false ; Flags -> stepAccepted = false ; guard1 = true ; } } else { idx_max = WorkingSet -> nActiveConstr ; if ( WorkingSet -> nActiveConstr == 0 ) { Flags -> done = true ; TrialState -> sqpExitFlag = 2 ; } else { hqukg0j2jsd ( TrialState -> xstarsqp , WorkingSet , TrialState -> cIneq , TrialState -> cEq , WorkingSet -> sizes [ 3 ] , lb , WorkingSet -> sizes [ 4 ] , ub , WorkingSet -> sizes [ 0 ] ) ; for ( minDim = 0 ; minDim < idx_max ; minDim ++ ) { TrialState -> lambda [ minDim ] = 0.0 ; } ijxevqoovk ( QRManager , WorkingSet -> ATwset , WorkingSet -> nVar , WorkingSet -> nActiveConstr ) ; d2y4tsvypc ( QRManager , QRManager -> mrows ) ; idx_max = ( uint8_T ) WorkingSet -> nVar ; for ( minDim = 0 ; minDim < idx_max ; minDim ++ ) { memspace -> workspace_float [ minDim ] = 0.0 ; } ix = 0 ; jjA = ( WorkingSet -> nVar - 1 ) * 221 + 1 ; for ( minDim = 1 ; minDim <= jjA ; minDim += 221 ) { s = 0.0 ; c_ix = ( minDim + nVar ) - 1 ; for ( idx_max = minDim ; idx_max <= c_ix ; idx_max ++ ) { s += QRManager -> Q [ idx_max - 1 ] * TrialState -> grad [ idx_max - minDim ] ; } idx_max = div_nde_s32_floor ( minDim - 1 , 221 ) ; memspace -> workspace_float [ idx_max ] -= s ; } s = muDoubleScalarMin ( 1.4901161193847656E-8 , ( real_T ) muIntScalarMax_sint32 ( WorkingSet -> nVar , WorkingSet -> nActiveConstr ) * 2.2204460492503131E-16 ) * muDoubleScalarAbs ( QRManager -> QR [ 0 ] ) ; idx_max = muIntScalarMin_sint32 ( WorkingSet -> nVar , WorkingSet -> nActiveConstr ) ; nVar = 0 ; while ( ( ix < idx_max ) && ( muDoubleScalarAbs ( QRManager -> QR [ nVar ] ) > s ) ) { ix ++ ; nVar += 222 ; } if ( ix != 0 ) { for ( nVar = ix ; nVar >= 1 ; nVar -- ) { jjA = ( ( nVar - 1 ) * 221 + nVar ) - 2 ; memspace -> workspace_float [ nVar - 1 ] /= QRManager -> QR [ jjA + 1 ] ; for ( minDim = 0 ; minDim <= nVar - 2 ; minDim ++ ) { c_ix = ( nVar - minDim ) - 2 ; memspace -> workspace_float [ c_ix ] -= memspace -> workspace_float [ nVar - 1 ] * QRManager -> QR [ jjA - minDim ] ; } } } minDim = muIntScalarMin_sint32 ( WorkingSet -> nActiveConstr , idx_max ) ; for ( nVar = 0 ; nVar < minDim ; nVar ++ ) { TrialState -> lambda [ QRManager -> jpvt [ nVar ] - 1 ] = memspace -> workspace_float [ nVar ] ; } myxjrkt4iq ( TrialState -> lambda , WorkingSet -> nActiveConstr , WorkingSet -> sizes , WorkingSet -> isActiveIdx , WorkingSet -> Wid , WorkingSet -> Wlocalidx , memspace -> workspace_float ) ; computeGradLag_pqhj2Pn4 ( memspace -> workspace_float , WorkingSet -> nVar , TrialState -> grad , WorkingSet -> Aineq , WorkingSet -> Aeq , WorkingSet -> indexFixed , WorkingSet -> sizes [ 0 ] , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , TrialState -> lambda ) ; fw12bnjdboi ( fscales_objective , WorkingSet -> nVar , memspace -> workspace_float , & isFeasible , & s ) ; nlpComplErrorTmp = efjv1gsbna ( fscales_objective , fscales_cineq_constraint , TrialState -> xstarsqp , TrialState -> cIneq , WorkingSet -> indexLB , WorkingSet -> sizes [ 3 ] , lb , WorkingSet -> indexUB , WorkingSet -> sizes [ 4 ] , ub , TrialState -> lambda , WorkingSet -> sizes [ 0 ] + 21 ) ; tmp = muDoubleScalarMax ( s , nlpComplErrorTmp ) ; if ( tmp <= muDoubleScalarMax ( MeritFunction -> nlpDualFeasError , MeritFunction -> nlpComplError ) ) { MeritFunction -> nlpDualFeasError = s ; MeritFunction -> nlpComplError = nlpComplErrorTmp ; MeritFunction -> firstOrderOpt = tmp ; memcpy ( & TrialState -> lambdaStopTest [ 0 ] , & TrialState -> lambda [ 0 ] , ( uint32_T ) idx_max_tmp * sizeof ( real_T ) ) ; } if ( ( MeritFunction -> nlpDualFeasError <= 1.0E-6 * smax ) && ( MeritFunction -> nlpComplError <= 1.0E-6 * smax ) ) { TrialState -> sqpExitFlag = 1 ; } else { TrialState -> sqpExitFlag = 2 ; } Flags -> done = true ; guard1 = true ; } } } else { guard1 = true ; } } else { guard1 = true ; } if ( guard1 ) { if ( TrialState -> sqpIterations >= 30 ) { Flags -> done = true ; TrialState -> sqpExitFlag = 0 ; } else if ( TrialState -> FunctionEvaluations >= 2600 ) { Flags -> done = true ; TrialState -> sqpExitFlag = 0 ; } } } } } } static void im2vn5wy2c ( const real_T obj_next_next_next_next_next_next_next_b_value_workspace_xk [ 2 ] , const real_T obj_next_next_next_next_next_next_next_b_value_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T obj_next_next_next_next_next_next_next_b_value_workspace_Vx , real_T obj_next_next_next_next_next_next_next_b_value_workspace_delta_Frnt , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxFrnt , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxRear , const real_T obj_next_next_next_next_next_next_next_b_value_workspace_Acc [ 3 ] , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMFrntTrq , real_T obj_next_next_next_next_next_next_next_b_value_workspace_EMRearTrq , const n4zzvudoa0 * obj_next_next_next_next_next_next_next_next_b_value_workspace , const real_T x [ 26 ] , real_T Cineq_workspace [ 54 ] , real_T Ceq_workspace [ 20 ] , real_T scales_objective , const real_T scales_cineq_constraint [ 54 ] , const real_T scales_ceq_constraint [ 20 ] , real_T * fval , int32_T * status ) { __m128d tmp_p ; real_T b [ 54 ] ; real_T c [ 20 ] ; real_T tmp_e [ 2 ] ; int32_T idx ; boolean_T tmp ; kqfgedufzz ( x , obj_next_next_next_next_next_next_next_next_b_value_workspace -> xk , obj_next_next_next_next_next_next_next_next_b_value_workspace -> PrevEMTrqCmdFinals , obj_next_next_next_next_next_next_next_next_b_value_workspace -> EMFrntTrq , obj_next_next_next_next_next_next_next_next_b_value_workspace -> EMRearTrq , obj_next_next_next_next_next_next_next_next_b_value_workspace -> r_ref , tmp_e ) ; * fval = scales_objective * sumColumnB_PypaGfPh ( tmp_e ) ; tmp = muDoubleScalarIsNaN ( * fval ) ; if ( muDoubleScalarIsInf ( * fval ) || tmp ) { if ( tmp ) { * status = - 3 ; } else if ( * fval < 0.0 ) { * status = - 1 ; } else { * status = - 2 ; } } else { evwyhhhxfb ( obj_next_next_next_next_next_next_next_b_value_workspace_xk , obj_next_next_next_next_next_next_next_b_value_workspace_PrevEMTrqCmdFinals , obj_next_next_next_next_next_next_next_b_value_workspace_Vx , obj_next_next_next_next_next_next_next_b_value_workspace_delta_Frnt , obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxFrnt , obj_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxRear , obj_next_next_next_next_next_next_next_b_value_workspace_Acc , obj_next_next_next_next_next_next_next_b_value_workspace_EMFrntTrq , obj_next_next_next_next_next_next_next_b_value_workspace_EMRearTrq , x , b , c ) ; memcpy ( & Cineq_workspace [ 0 ] , & b [ 0 ] , 54U * sizeof ( real_T ) ) ; memcpy ( & Ceq_workspace [ 0 ] , & c [ 0 ] , 20U * sizeof ( real_T ) ) ; for ( idx = 0 ; idx <= 52 ; idx += 2 ) { tmp_p = _mm_loadu_pd ( & Cineq_workspace [ idx ] ) ; _mm_storeu_pd ( & Cineq_workspace [ idx ] , _mm_mul_pd ( _mm_loadu_pd ( & scales_cineq_constraint [ idx ] ) , tmp_p ) ) ; } for ( idx = 0 ; idx <= 18 ; idx += 2 ) { tmp_p = _mm_loadu_pd ( & Ceq_workspace [ idx ] ) ; _mm_storeu_pd ( & Ceq_workspace [ idx ] , _mm_mul_pd ( _mm_loadu_pd ( & scales_ceq_constraint [ idx ] ) , tmp_p ) ) ; } * status = checkVectorNonFinite_Mtnc75LS ( Cineq_workspace ) ; if ( * status == 1 ) { * status = checkVectorNonFinite_Fp2Tnt5U ( Ceq_workspace ) ; } } } static real_T a1oi5z04nx ( real_T obj_penaltyParam , real_T fval , const real_T Cineq_workspace [ 54 ] , const real_T Ceq_workspace [ 20 ] , boolean_T evalWellDefined ) { real_T Cineq_workspace_p ; real_T constrViolationEq ; real_T constrViolationIneq ; real_T val ; int32_T k ; if ( evalWellDefined ) { constrViolationEq = 0.0 ; for ( k = 0 ; k < 20 ; k ++ ) { constrViolationEq += muDoubleScalarAbs ( Ceq_workspace [ k ] ) ; } constrViolationIneq = 0.0 ; for ( k = 0 ; k < 54 ; k ++ ) { Cineq_workspace_p = Cineq_workspace [ k ] ; if ( Cineq_workspace_p > 0.0 ) { constrViolationIneq += Cineq_workspace_p ; } } val = ( constrViolationEq + constrViolationIneq ) * obj_penaltyParam + fval ; } else { val = ( rtInf ) ; } return val ; } static void a43nr5o2hf ( boolean_T * evalWellDefined , int32_T WorkingSet_nVar , ci1jcnwvc5 * TrialState , real_T MeritFunction_penaltyParam , real_T MeritFunction_phi , real_T MeritFunction_phiPrimePlus , real_T MeritFunction_phiFullStep , const real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_xk [ 2 ] , const real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_Vx , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_delta_Frnt , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxFrnt , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxRear , const real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_Acc [ 3 ] , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMFrntTrq , real_T FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMRearTrq , const ptup5lzvsv * FcnEvaluator_next_next_next_next_next_next_next_next_b_value , boolean_T socTaken , real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , real_T * alpha , int32_T * exitflag ) { __m128d tmp ; __m128d tmp_p ; real_T phi_alpha ; int32_T b_tmp ; int32_T exitg1 ; int32_T k ; int32_T scalarLB ; int32_T scalarLB_tmp ; int32_T vectorUB ; int32_T vectorUB_tmp ; boolean_T exitg2 ; boolean_T tooSmallX ; * alpha = 1.0 ; * exitflag = 1 ; phi_alpha = MeritFunction_phiFullStep ; if ( WorkingSet_nVar - 1 >= 0 ) { memcpy ( & TrialState -> searchDir [ 0 ] , & TrialState -> delta_x [ 0 ] , ( uint32_T ) WorkingSet_nVar * sizeof ( real_T ) ) ; } do { exitg1 = 0 ; if ( TrialState -> FunctionEvaluations < 2600 ) { if ( ( * evalWellDefined ) && ( phi_alpha <= * alpha * 0.0001 * MeritFunction_phiPrimePlus + MeritFunction_phi ) ) { exitg1 = 1 ; } else { * alpha *= 0.7 ; b_tmp = ( uint8_T ) WorkingSet_nVar ; scalarLB_tmp = ( ( uint8_T ) WorkingSet_nVar / 2 ) << 1 ; vectorUB_tmp = scalarLB_tmp - 2 ; for ( k = 0 ; k <= vectorUB_tmp ; k += 2 ) { tmp_p = _mm_loadu_pd ( & TrialState -> xstar [ k ] ) ; _mm_storeu_pd ( & TrialState -> delta_x [ k ] , _mm_mul_pd ( _mm_set1_pd ( * alpha ) , tmp_p ) ) ; } for ( k = scalarLB_tmp ; k < b_tmp ; k ++ ) { TrialState -> delta_x [ k ] = * alpha * TrialState -> xstar [ k ] ; } if ( socTaken ) { phi_alpha = * alpha * * alpha ; if ( ( WorkingSet_nVar >= 1 ) && ( ! ( phi_alpha == 0.0 ) ) ) { scalarLB = ( WorkingSet_nVar / 2 ) << 1 ; vectorUB = scalarLB - 2 ; for ( k = 0 ; k <= vectorUB ; k += 2 ) { tmp_p = _mm_loadu_pd ( & TrialState -> socDirection [ k ] ) ; tmp = _mm_loadu_pd ( & TrialState -> delta_x [ k ] ) ; _mm_storeu_pd ( & TrialState -> delta_x [ k ] , _mm_add_pd ( _mm_mul_pd ( _mm_set1_pd ( phi_alpha ) , tmp_p ) , tmp ) ) ; } for ( k = scalarLB ; k < WorkingSet_nVar ; k ++ ) { TrialState -> delta_x [ k ] += phi_alpha * TrialState -> socDirection [ k ] ; } } } tooSmallX = true ; k = 0 ; exitg2 = false ; while ( ( ! exitg2 ) && ( k <= ( uint8_T ) WorkingSet_nVar - 1 ) ) { if ( 1.0E-6 * muDoubleScalarMax ( 1.0 , muDoubleScalarAbs ( TrialState -> xstarsqp [ k ] ) ) <= muDoubleScalarAbs ( TrialState -> delta_x [ k ] ) ) { tooSmallX = false ; exitg2 = true ; } else { k ++ ; } } if ( tooSmallX ) { * exitflag = - 2 ; exitg1 = 1 ; } else { for ( k = 0 ; k <= vectorUB_tmp ; k += 2 ) { tmp_p = _mm_loadu_pd ( & TrialState -> xstarsqp_old [ k ] ) ; tmp = _mm_loadu_pd ( & TrialState -> delta_x [ k ] ) ; _mm_storeu_pd ( & TrialState -> xstarsqp [ k ] , _mm_add_pd ( tmp_p , tmp ) ) ; } for ( k = scalarLB_tmp ; k < b_tmp ; k ++ ) { TrialState -> xstarsqp [ k ] = TrialState -> xstarsqp_old [ k ] + TrialState -> delta_x [ k ] ; } im2vn5wy2c ( FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_xk , FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_PrevEMTrqCmdFinals , FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_Vx , FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_delta_Frnt , FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxFrnt , FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMTrqMaxRear , FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_Acc , FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMFrntTrq , FcnEvaluator_next_next_next_next_next_next_next_b_value_workspace_EMRearTrq , & FcnEvaluator_next_next_next_next_next_next_next_next_b_value -> workspace , TrialState -> xstarsqp , TrialState -> cIneq , TrialState -> cEq , fscales_objective , fscales_cineq_constraint , fscales_ceq_constraint , & TrialState -> sqpFval , & k ) ; TrialState -> FunctionEvaluations ++ ; * evalWellDefined = ( k == 1 ) ; phi_alpha = a1oi5z04nx ( MeritFunction_penaltyParam , TrialState -> sqpFval , TrialState -> cIneq , TrialState -> cEq , * evalWellDefined ) ; } } } else { * exitflag = 0 ; exitg1 = 1 ; } } while ( exitg1 == 0 ) ; } static boolean_T dk3cfa35iak ( const real_T obj_objfun_workspace_xk [ 2 ] , const real_T obj_objfun_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T obj_objfun_workspace_EMFrntTrq , real_T obj_objfun_workspace_EMRearTrq , real_T obj_objfun_workspace_r_ref , const real_T obj_nonlin_workspace_xk [ 2 ] , const real_T obj_nonlin_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T obj_nonlin_workspace_Vx , real_T obj_nonlin_workspace_delta_Frnt , real_T obj_nonlin_workspace_EMTrqMaxFrnt , real_T obj_nonlin_workspace_EMTrqMaxRear , const real_T obj_nonlin_workspace_Acc [ 3 ] , real_T obj_nonlin_workspace_EMFrntTrq , real_T obj_nonlin_workspace_EMRearTrq , real_T * fplus , real_T cIneqPlus [ 54 ] , real_T cEqPlus [ 20 ] , int32_T dim , real_T delta , real_T xk [ 26 ] , real_T scales_objective , const real_T scales_cineq_constraint [ 54 ] , const real_T scales_ceq_constraint [ 20 ] ) { __m128d tmp ; real_T tmp_p [ 2 ] ; real_T temp_tmp ; int32_T b_idx ; boolean_T evalOK ; temp_tmp = xk [ dim - 1 ] ; xk [ dim - 1 ] = temp_tmp + delta ; kqfgedufzz ( xk , obj_objfun_workspace_xk , obj_objfun_workspace_PrevEMTrqCmdFinals , obj_objfun_workspace_EMFrntTrq , obj_objfun_workspace_EMRearTrq , obj_objfun_workspace_r_ref , tmp_p ) ; * fplus = scales_objective * sumColumnB_PypaGfPh ( tmp_p ) ; evalOK = ( ( ! muDoubleScalarIsInf ( * fplus ) ) && ( ! muDoubleScalarIsNaN ( * fplus ) ) ) ; if ( evalOK ) { evwyhhhxfb ( obj_nonlin_workspace_xk , obj_nonlin_workspace_PrevEMTrqCmdFinals , obj_nonlin_workspace_Vx , obj_nonlin_workspace_delta_Frnt , obj_nonlin_workspace_EMTrqMaxFrnt , obj_nonlin_workspace_EMTrqMaxRear , obj_nonlin_workspace_Acc , obj_nonlin_workspace_EMFrntTrq , obj_nonlin_workspace_EMRearTrq , xk , cIneqPlus , cEqPlus ) ; for ( b_idx = 0 ; b_idx <= 52 ; b_idx += 2 ) { tmp = _mm_loadu_pd ( & cIneqPlus [ b_idx ] ) ; _mm_storeu_pd ( & cIneqPlus [ b_idx ] , _mm_mul_pd ( tmp , _mm_loadu_pd ( & scales_cineq_constraint [ b_idx ] ) ) ) ; } for ( b_idx = 0 ; b_idx <= 18 ; b_idx += 2 ) { tmp = _mm_loadu_pd ( & cEqPlus [ b_idx ] ) ; _mm_storeu_pd ( & cEqPlus [ b_idx ] , _mm_mul_pd ( tmp , _mm_loadu_pd ( & scales_ceq_constraint [ b_idx ] ) ) ) ; } b_idx = 0 ; while ( evalOK && ( b_idx + 1 <= 54 ) ) { evalOK = ( ( ! muDoubleScalarIsInf ( cIneqPlus [ b_idx ] ) ) && ( ! muDoubleScalarIsNaN ( cIneqPlus [ b_idx ] ) ) ) ; b_idx ++ ; } if ( evalOK ) { b_idx = 0 ; while ( evalOK && ( b_idx + 1 <= 20 ) ) { evalOK = ( ( ! muDoubleScalarIsInf ( cEqPlus [ b_idx ] ) ) && ( ! muDoubleScalarIsNaN ( cEqPlus [ b_idx ] ) ) ) ; b_idx ++ ; } xk [ dim - 1 ] = temp_tmp ; } } return evalOK ; } static boolean_T bvp0ue5q2pa ( aoeufdu2eg * obj , real_T fCurrent , const real_T cIneqCurrent [ 54 ] , const real_T cEqCurrent [ 20 ] , real_T xk [ 26 ] , real_T gradf [ 121 ] , real_T JacCineqTrans [ 6534 ] , real_T JacCeqTrans [ 2420 ] , const real_T lb [ 26 ] , const real_T ub [ 26 ] , const ofxtwsq03r * scales ) { real_T deltaX ; real_T tmp ; int32_T idx ; int32_T idx_row ; boolean_T evalOK ; boolean_T exitg1 ; boolean_T guard1 ; boolean_T modifiedStep ; evalOK = true ; obj -> numEvals = 0 ; idx = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( idx < 26 ) ) { modifiedStep = false ; deltaX = ( 1.0 - ( real_T ) ( xk [ idx ] < 0.0 ) * 2.0 ) * 1.4901161193847656E-8 * muDoubleScalarMax ( muDoubleScalarAbs ( xk [ idx ] ) , 1.0 ) ; if ( obj -> hasLB [ idx ] || obj -> hasUB [ idx ] ) { if ( obj -> hasLB [ idx ] && obj -> hasUB [ idx ] ) { modifiedStep = fwdFinDiffInsideBnds_ackjW8wf ( xk [ idx ] , lb [ idx ] , ub [ idx ] , & deltaX ) ; } else if ( obj -> hasUB [ idx ] ) { if ( ( xk [ idx ] <= ub [ idx ] ) && ( xk [ idx ] + deltaX > ub [ idx ] ) ) { deltaX = - deltaX ; modifiedStep = true ; } } else if ( ( xk [ idx ] >= lb [ idx ] ) && ( xk [ idx ] + deltaX < lb [ idx ] ) ) { deltaX = - deltaX ; modifiedStep = true ; } } evalOK = dk3cfa35iak ( obj -> objfun . workspace . xk , obj -> objfun . workspace . PrevEMTrqCmdFinals , obj -> objfun . workspace . EMFrntTrq , obj -> objfun . workspace . EMRearTrq , obj -> objfun . workspace . r_ref , obj -> nonlin . workspace . xk , obj -> nonlin . workspace . PrevEMTrqCmdFinals , obj -> nonlin . workspace . Vx , obj -> nonlin . workspace . delta_Frnt , obj -> nonlin . workspace . EMTrqMaxFrnt , obj -> nonlin . workspace . EMTrqMaxRear , obj -> nonlin . workspace . Acc , obj -> nonlin . workspace . EMFrntTrq , obj -> nonlin . workspace . EMRearTrq , & obj -> f_1 , obj -> cIneq_1 , obj -> cEq_1 , idx + 1 , deltaX , xk , scales -> objective , scales -> cineq_constraint , scales -> ceq_constraint ) ; obj -> numEvals ++ ; guard1 = false ; if ( ! evalOK ) { if ( ! modifiedStep ) { deltaX = - deltaX ; if ( obj -> hasLB [ idx ] ) { tmp = xk [ idx ] + deltaX ; if ( ( tmp >= lb [ idx ] ) && obj -> hasUB [ idx ] && ( tmp <= ub [ idx ] ) ) { modifiedStep = true ; } } if ( ( ! obj -> hasBounds ) || modifiedStep ) { evalOK = dk3cfa35iak ( obj -> objfun . workspace . xk , obj -> objfun . workspace . PrevEMTrqCmdFinals , obj -> objfun . workspace . EMFrntTrq , obj -> objfun . workspace . EMRearTrq , obj -> objfun . workspace . r_ref , obj -> nonlin . workspace . xk , obj -> nonlin . workspace . PrevEMTrqCmdFinals , obj -> nonlin . workspace . Vx , obj -> nonlin . workspace . delta_Frnt , obj -> nonlin . workspace . EMTrqMaxFrnt , obj -> nonlin . workspace . EMTrqMaxRear , obj -> nonlin . workspace . Acc , obj -> nonlin . workspace . EMFrntTrq , obj -> nonlin . workspace . EMRearTrq , & obj -> f_1 , obj -> cIneq_1 , obj -> cEq_1 , idx + 1 , deltaX , xk , scales -> objective , scales -> cineq_constraint , scales -> ceq_constraint ) ; obj -> numEvals ++ ; } } if ( ! evalOK ) { exitg1 = true ; } else { guard1 = true ; } } else { guard1 = true ; } if ( guard1 ) { gradf [ idx ] = ( obj -> f_1 - fCurrent ) / deltaX ; for ( idx_row = 0 ; idx_row < 54 ; idx_row ++ ) { JacCineqTrans [ idx + 121 * idx_row ] = ( obj -> cIneq_1 [ idx_row ] - cIneqCurrent [ idx_row ] ) / deltaX ; } for ( idx_row = 0 ; idx_row < 20 ; idx_row ++ ) { JacCeqTrans [ idx + 121 * idx_row ] = ( obj -> cEq_1 [ idx_row ] - cEqCurrent [ idx_row ] ) / deltaX ; } idx ++ ; } } return evalOK ; } static void ckrin4u0eh ( const real_T lb [ 26 ] , const real_T ub [ 26 ] , ci1jcnwvc5 * TrialState , bhtu1h5bl5 * MeritFunction , const nged4bnpig * FcnEvaluator , aoeufdu2eg * FiniteDifferences , kmbpuy2anc * memspace , c3tcu1vsoj * WorkingSet , oytx5zapfu * QRManager , iamwnmrrfd * QPObjective , real_T fscales_objective , const real_T fscales_cineq_constraint [ 54 ] , const real_T fscales_ceq_constraint [ 20 ] , real_T Hessian [ 676 ] , kzv4ftj4e2 * CholManager , d4m2qnxaxx * localB ) { __m128d tmp ; __m128d tmp_p ; drf2ph4ldh Flags ; i4h2yyndkb expl_temp ; ofxtwsq03r expl_temp_p ; real_T a_tmp ; int32_T d ; int32_T i ; int32_T ix ; int32_T j ; int32_T mConstr ; int32_T mFixed ; int32_T mLB ; int32_T mUB ; int32_T nVar ; int32_T qpoptions_MaxIterations ; int32_T scalarLB ; static const int8_T p [ 676 ] = { 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } ; static const char_T o [ 7 ] = { 'f' , 'm' , 'i' , 'n' , 'c' , 'o' , 'n' } ; i4h2yyndkb expl_temp_e ; for ( scalarLB = 0 ; scalarLB < 48841 ; scalarLB ++ ) { CholManager -> FMat [ scalarLB ] = 0.0 ; } CholManager -> ldm = 221 ; CholManager -> ndims = 0 ; CholManager -> info = 0 ; CholManager -> scaleFactor = 0.0 ; CholManager -> ConvexCheck = true ; CholManager -> regTol_ = ( rtInf ) ; CholManager -> workspace_ = ( rtInf ) ; CholManager -> workspace2_ = ( rtInf ) ; for ( scalarLB = 0 ; scalarLB < 676 ; scalarLB ++ ) { Hessian [ scalarLB ] = p [ scalarLB ] ; } nVar = WorkingSet -> nVar ; mFixed = WorkingSet -> sizes [ 0 ] ; mLB = WorkingSet -> sizes [ 3 ] ; mUB = WorkingSet -> sizes [ 4 ] ; mConstr = ( ( WorkingSet -> sizes [ 0 ] + WorkingSet -> sizes [ 3 ] ) + WorkingSet -> sizes [ 4 ] ) + 74 ; scalarLB = ( ( WorkingSet -> sizes [ 3 ] + WorkingSet -> sizes [ 4 ] ) + ( WorkingSet -> sizes [ 0 ] << 1 ) ) + 54 ; qpoptions_MaxIterations = muIntScalarMax_sint32 ( WorkingSet -> nVar , scalarLB ) * 10 ; TrialState -> steplength = 1.0 ; crspy0yej2 ( MeritFunction , fscales_objective , fscales_cineq_constraint , fscales_ceq_constraint , WorkingSet , TrialState , lb , ub , & Flags . gradOK , & Flags . fevalOK , & Flags . done , & Flags . stepAccepted , & Flags . failedLineSearch , & Flags . stepType ) ; lmxrtyn3ij ( TrialState , WorkingSet -> nVar , WorkingSet -> Aineq , WorkingSet -> Aeq ) ; TrialState -> sqpFval_old = TrialState -> sqpFval ; for ( i = 0 ; i < 26 ; i ++ ) { TrialState -> xstarsqp_old [ i ] = TrialState -> xstarsqp [ i ] ; TrialState -> grad_old [ i ] = TrialState -> grad [ i ] ; } memcpy ( & TrialState -> cIneq_old [ 0 ] , & TrialState -> cIneq [ 0 ] , 54U * sizeof ( real_T ) ) ; memcpy ( & TrialState -> cEq_old [ 0 ] , & TrialState -> cEq [ 0 ] , 20U * sizeof ( real_T ) ) ; if ( ! Flags . done ) { TrialState -> sqpIterations = 1 ; } while ( ! Flags . done ) { if ( ( ! Flags . stepAccepted ) && ( ! Flags . failedLineSearch ) ) { expl_temp . IterDisplayQP = false ; expl_temp . RemainFeasible = false ; expl_temp . ProbRelTolFactor = 1.0 ; expl_temp . ConstrRelTolFactor = 1.0 ; expl_temp . PricingTolerance = 0.0 ; expl_temp . ObjectiveLimit = ( rtMinusInf ) ; expl_temp . ConstraintTolerance = 1.0E-6 ; expl_temp . OptimalityTolerance = 2.2204460492503131E-14 ; expl_temp . StepTolerance = 1.0E-6 ; expl_temp . MaxIterations = qpoptions_MaxIterations ; for ( scalarLB = 0 ; scalarLB < 7 ; scalarLB ++ ) { expl_temp . SolverName [ scalarLB ] = o [ scalarLB ] ; } } while ( ( ! Flags . stepAccepted ) && ( ! Flags . failedLineSearch ) ) { if ( Flags . stepType != 3 ) { hqukg0j2jsd ( TrialState -> xstarsqp , WorkingSet , TrialState -> cIneq , TrialState -> cEq , mLB , lb , mUB , ub , mFixed ) ; } expl_temp_e = expl_temp ; bkzwtwyp4q ( & Flags , Hessian , lb , ub , TrialState , MeritFunction , memspace , WorkingSet , QRManager , CholManager , QPObjective , & expl_temp_e , localB ) ; if ( Flags . stepAccepted ) { d = ( uint8_T ) nVar ; scalarLB = ( ( uint8_T ) nVar / 2 ) << 1 ; ix = scalarLB - 2 ; for ( i = 0 ; i <= ix ; i += 2 ) { tmp = _mm_loadu_pd ( & TrialState -> xstarsqp [ i ] ) ; tmp_p = _mm_loadu_pd ( & TrialState -> delta_x [ i ] ) ; _mm_storeu_pd ( & TrialState -> xstarsqp [ i ] , _mm_add_pd ( tmp , tmp_p ) ) ; } for ( i = scalarLB ; i < d ; i ++ ) { TrialState -> xstarsqp [ i ] += TrialState -> delta_x [ i ] ; } im2vn5wy2c ( FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . xk , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . PrevEMTrqCmdFinals , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . Vx , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . delta_Frnt , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . EMTrqMaxFrnt , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . EMTrqMaxRear , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . Acc , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . EMFrntTrq , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . EMRearTrq , & FcnEvaluator -> next . next . next . next . next . next . next . next . b_value . workspace , TrialState -> xstarsqp , TrialState -> cIneq , TrialState -> cEq , fscales_objective , fscales_cineq_constraint , fscales_ceq_constraint , & TrialState -> sqpFval , & i ) ; Flags . fevalOK = ( i == 1 ) ; TrialState -> FunctionEvaluations ++ ; MeritFunction -> phiFullStep = a1oi5z04nx ( MeritFunction -> penaltyParam , TrialState -> sqpFval , TrialState -> cIneq , TrialState -> cEq , Flags . fevalOK ) ; } if ( ( Flags . stepType == 1 ) && Flags . stepAccepted && Flags . fevalOK && ( MeritFunction -> phi < MeritFunction -> phiFullStep ) && ( TrialState -> sqpFval < TrialState -> sqpFval_old ) ) { Flags . stepType = 3 ; Flags . stepAccepted = false ; } else { a43nr5o2hf ( & Flags . fevalOK , WorkingSet -> nVar , TrialState , MeritFunction -> penaltyParam , MeritFunction -> phi , MeritFunction -> phiPrimePlus , MeritFunction -> phiFullStep , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . xk , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . PrevEMTrqCmdFinals , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . Vx , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . delta_Frnt , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . EMTrqMaxFrnt , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . EMTrqMaxRear , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . Acc , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . EMFrntTrq , FcnEvaluator -> next . next . next . next . next . next . next . b_value . workspace . EMRearTrq , & FcnEvaluator -> next . next . next . next . next . next . next . next . b_value , ( ( Flags . stepType == 3 ) && Flags . stepAccepted ) , fscales_objective , fscales_cineq_constraint , fscales_ceq_constraint , & a_tmp , & i ) ; TrialState -> steplength = a_tmp ; if ( i > 0 ) { Flags . stepAccepted = true ; } else { Flags . failedLineSearch = true ; } } } if ( Flags . stepAccepted && ( ! Flags . failedLineSearch ) ) { d = ( uint8_T ) nVar ; scalarLB = ( ( uint8_T ) nVar / 2 ) << 1 ; ix = scalarLB - 2 ; for ( i = 0 ; i <= ix ; i += 2 ) { tmp = _mm_loadu_pd ( & TrialState -> xstarsqp_old [ i ] ) ; tmp_p = _mm_loadu_pd ( & TrialState -> delta_x [ i ] ) ; _mm_storeu_pd ( & TrialState -> xstarsqp [ i ] , _mm_add_pd ( tmp , tmp_p ) ) ; } for ( i = scalarLB ; i < d ; i ++ ) { TrialState -> xstarsqp [ i ] = TrialState -> xstarsqp_old [ i ] + TrialState -> delta_x [ i ] ; } d = ( uint16_T ) mConstr ; scalarLB = ( ( uint16_T ) mConstr / 2 ) << 1 ; ix = scalarLB - 2 ; for ( i = 0 ; i <= ix ; i += 2 ) { tmp = _mm_loadu_pd ( & TrialState -> lambda [ i ] ) ; tmp_p = _mm_loadu_pd ( & TrialState -> lambdasqp [ i ] ) ; _mm_storeu_pd ( & TrialState -> lambdasqp [ i ] , _mm_add_pd ( _mm_mul_pd ( _mm_sub_pd ( tmp , tmp_p ) , _mm_set1_pd ( TrialState -> steplength ) ) , tmp_p ) ) ; } for ( i = scalarLB ; i < d ; i ++ ) { a_tmp = TrialState -> lambdasqp [ i ] ; TrialState -> lambdasqp [ i ] = ( TrialState -> lambda [ i ] - a_tmp ) * TrialState -> steplength + a_tmp ; } TrialState -> sqpFval_old = TrialState -> sqpFval ; for ( i = 0 ; i < 26 ; i ++ ) { TrialState -> xstarsqp_old [ i ] = TrialState -> xstarsqp [ i ] ; TrialState -> grad_old [ i ] = TrialState -> grad [ i ] ; } memcpy ( & TrialState -> cIneq_old [ 0 ] , & TrialState -> cIneq [ 0 ] , 54U * sizeof ( real_T ) ) ; memcpy ( & TrialState -> cEq_old [ 0 ] , & TrialState -> cEq [ 0 ] , 20U * sizeof ( real_T ) ) ; memcpy ( & expl_temp_p . ceq_constraint [ 0 ] , & fscales_ceq_constraint [ 0 ] , 20U * sizeof ( real_T ) ) ; memcpy ( & expl_temp_p . cineq_constraint [ 0 ] , & fscales_cineq_constraint [ 0 ] , 54U * sizeof ( real_T ) ) ; expl_temp_p . objective = fscales_objective ; Flags . gradOK = bvp0ue5q2pa ( FiniteDifferences , TrialState -> sqpFval , TrialState -> cIneq , TrialState -> cEq , TrialState -> xstarsqp , TrialState -> grad , WorkingSet -> Aineq , WorkingSet -> Aeq , lb , ub , & expl_temp_p ) ; TrialState -> FunctionEvaluations += FiniteDifferences -> numEvals ; } else { TrialState -> sqpFval = TrialState -> sqpFval_old ; memcpy ( & TrialState -> xstarsqp [ 0 ] , & TrialState -> xstarsqp_old [ 0 ] , 26U * sizeof ( real_T ) ) ; memcpy ( & TrialState -> cIneq [ 0 ] , & TrialState -> cIneq_old [ 0 ] , 54U * sizeof ( real_T ) ) ; memcpy ( & TrialState -> cEq [ 0 ] , & TrialState -> cEq_old [ 0 ] , 20U * sizeof ( real_T ) ) ; } crspy0yej2a ( & Flags , memspace , MeritFunction , fscales_objective , fscales_cineq_constraint , fscales_ceq_constraint , WorkingSet , TrialState , QRManager , lb , ub ) ; if ( ( ! Flags . done ) && Flags . stepAccepted ) { Flags . stepAccepted = false ; Flags . stepType = 1 ; Flags . failedLineSearch = false ; memcpy ( & TrialState -> delta_gradLag [ 0 ] , & TrialState -> grad [ 0 ] , ( uint8_T ) nVar * sizeof ( real_T ) ) ; if ( nVar >= 1 ) { scalarLB = ( nVar / 2 ) << 1 ; ix = scalarLB - 2 ; for ( i = 0 ; i <= ix ; i += 2 ) { tmp = _mm_loadu_pd ( & TrialState -> delta_gradLag [ i ] ) ; tmp_p = _mm_loadu_pd ( & TrialState -> grad_old [ i ] ) ; _mm_storeu_pd ( & TrialState -> delta_gradLag [ i ] , _mm_sub_pd ( tmp , tmp_p ) ) ; } for ( i = scalarLB ; i < nVar ; i ++ ) { TrialState -> delta_gradLag [ i ] -= TrialState -> grad_old [ i ] ; } } ix = mFixed ; for ( i = 0 ; i <= 2299 ; i += 121 ) { j = i + nVar ; for ( d = i + 1 ; d <= j ; d ++ ) { scalarLB = ( d - i ) - 1 ; TrialState -> delta_gradLag [ scalarLB ] += WorkingSet -> Aeq [ d - 1 ] * TrialState -> lambdasqp [ ix ] ; } ix ++ ; } ix = mFixed ; for ( i = 0 ; i <= 2299 ; i += 121 ) { j = i + nVar ; for ( d = i + 1 ; d <= j ; d ++ ) { scalarLB = ( d - i ) - 1 ; TrialState -> delta_gradLag [ scalarLB ] += TrialState -> JacCeqTrans_old [ d - 1 ] * - TrialState -> lambdasqp [ ix ] ; } ix ++ ; } ix = mFixed + 20 ; for ( i = 0 ; i <= 6413 ; i += 121 ) { j = i + nVar ; for ( d = i + 1 ; d <= j ; d ++ ) { scalarLB = ( d - i ) - 1 ; TrialState -> delta_gradLag [ scalarLB ] += WorkingSet -> Aineq [ d - 1 ] * TrialState -> lambdasqp [ ix ] ; } ix ++ ; } ix = mFixed + 20 ; for ( i = 0 ; i <= 6413 ; i += 121 ) { j = i + nVar ; for ( d = i + 1 ; d <= j ; d ++ ) { scalarLB = ( d - i ) - 1 ; TrialState -> delta_gradLag [ scalarLB ] += TrialState -> JacCineqTrans_old [ d - 1 ] * - TrialState -> lambdasqp [ ix ] ; } ix ++ ; } lmxrtyn3ij ( TrialState , nVar , WorkingSet -> Aineq , WorkingSet -> Aeq ) ; BFGSUpdate_LCEtP8Ng ( nVar , Hessian , TrialState -> delta_x , TrialState -> delta_gradLag , memspace -> workspace_float ) ; TrialState -> sqpIterations ++ ; } } TrialState -> sqpFval /= fscales_objective ; a_tmp = 1.0 / fscales_objective ; mLB = ( uint8_T ) nVar ; scalarLB = ( ( uint8_T ) nVar / 2 ) << 1 ; ix = scalarLB - 2 ; for ( mFixed = 0 ; mFixed <= ix ; mFixed += 2 ) { tmp = _mm_loadu_pd ( & TrialState -> grad [ mFixed ] ) ; _mm_storeu_pd ( & TrialState -> grad [ mFixed ] , _mm_mul_pd ( _mm_set1_pd ( a_tmp ) , tmp ) ) ; } for ( mFixed = scalarLB ; mFixed < mLB ; mFixed ++ ) { TrialState -> grad [ mFixed ] *= a_tmp ; } mFixed = ( uint16_T ) ( nVar * nVar ) ; scalarLB = ( mFixed / 2 ) << 1 ; ix = scalarLB - 2 ; for ( nVar = 0 ; nVar <= ix ; nVar += 2 ) { tmp = _mm_loadu_pd ( & Hessian [ nVar ] ) ; _mm_storeu_pd ( & Hessian [ nVar ] , _mm_mul_pd ( _mm_set1_pd ( a_tmp ) , tmp ) ) ; } for ( nVar = scalarLB ; nVar < mFixed ; nVar ++ ) { Hessian [ nVar ] *= a_tmp ; } } static void e0ysvsme4f ( const real_T fun_workspace_xk [ 2 ] , const real_T fun_workspace_PrevEMTrqCmdFinals [ 4 ] , real_T fun_workspace_EMFrntTrq , real_T fun_workspace_EMRearTrq , real_T fun_workspace_r_ref , real_T x0 [ 26 ] , const real_T lb [ 26 ] , const real_T ub [ 26 ] , const cuxlzjpzbn * nonlcon_workspace , real_T * fval , real_T * exitflag , real_T * output_iterations , real_T * output_funcCount , char_T output_algorithm [ 3 ] , real_T * output_constrviolation , real_T * output_stepsize , real_T * output_lssteplength , real_T * output_firstorderopt , d4m2qnxaxx * localB ) { __m128d tmp ; aoeufdu2eg FiniteDifferences ; bhtu1h5bl5 MeritFunction ; iamwnmrrfd QPObjective ; nged4bnpig FcnEvaluator ; real_T f [ 54 ] ; real_T d [ 20 ] ; real_T b ; real_T b_s ; real_T s ; real_T smax ; int32_T b_iAT0 ; int32_T d_idx ; int32_T i ; int32_T iAT0 ; int32_T ix ; int32_T mFixed ; int32_T mUB ; int32_T vectorUB ; boolean_T exitg1 ; boolean_T guard1 ; * exitflag = ( rtInf ) ; i = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( i < 26 ) ) { if ( lb [ i ] > ub [ i ] ) { * exitflag = - 2.0 ; exitg1 = true ; } else { i ++ ; } } if ( * exitflag == - 2.0 ) { * output_iterations = 0.0 ; * output_funcCount = 0.0 ; output_algorithm [ 0 ] = 's' ; output_algorithm [ 1 ] = 'q' ; output_algorithm [ 2 ] = 'p' ; * output_constrviolation = ( rtInf ) ; * output_stepsize = ( rtInf ) ; * output_lssteplength = ( rtInf ) ; * output_firstorderopt = ( rtInf ) ; * fval = ( rtInf ) ; } else { e4ctbgzcfy ( & localB -> TrialState ) ; memcpy ( & localB -> TrialState . xstarsqp [ 0 ] , & x0 [ 0 ] , 26U * sizeof ( real_T ) ) ; FcnEvaluator . next . next . next . next . next . next . next . b_value . workspace = * nonlcon_workspace ; FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace . xk [ 0 ] = fun_workspace_xk [ 0 ] ; FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace . xk [ 1 ] = fun_workspace_xk [ 1 ] ; FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace . PrevEMTrqCmdFinals [ 0 ] = fun_workspace_PrevEMTrqCmdFinals [ 0 ] ; FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace . PrevEMTrqCmdFinals [ 1 ] = fun_workspace_PrevEMTrqCmdFinals [ 1 ] ; FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace . PrevEMTrqCmdFinals [ 2 ] = fun_workspace_PrevEMTrqCmdFinals [ 2 ] ; FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace . PrevEMTrqCmdFinals [ 3 ] = fun_workspace_PrevEMTrqCmdFinals [ 3 ] ; FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace . EMFrntTrq = fun_workspace_EMFrntTrq ; FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace . EMRearTrq = fun_workspace_EMRearTrq ; FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace . r_ref = fun_workspace_r_ref ; localB -> WorkingSet . nVar = 26 ; localB -> WorkingSet . nVarOrig = 26 ; localB -> WorkingSet . nVarMax = 121 ; localB -> WorkingSet . ldA = 121 ; for ( i = 0 ; i < 6534 ; i ++ ) { localB -> WorkingSet . Aineq [ i ] = 0.0 ; } for ( i = 0 ; i < 54 ; i ++ ) { localB -> WorkingSet . bineq [ i ] = 0.0 ; } for ( i = 0 ; i < 2420 ; i ++ ) { localB -> WorkingSet . Aeq [ i ] = 0.0 ; } for ( i = 0 ; i < 20 ; i ++ ) { localB -> WorkingSet . beq [ i ] = 0.0 ; } for ( i = 0 ; i < 121 ; i ++ ) { localB -> WorkingSet . lb [ i ] = 0.0 ; localB -> WorkingSet . ub [ i ] = 0.0 ; } localB -> WorkingSet . mEqRemoved = 0 ; memset ( & localB -> WorkingSet . indexEqRemoved [ 0 ] , 0 , 20U * sizeof ( int32_T ) ) ; for ( i = 0 ; i < 26741 ; i ++ ) { localB -> WorkingSet . ATwset [ i ] = 0.0 ; } localB -> WorkingSet . nActiveConstr = 0 ; for ( i = 0 ; i < 221 ; i ++ ) { localB -> WorkingSet . bwset [ i ] = 0.0 ; localB -> WorkingSet . maxConstrWorkspace [ i ] = 0.0 ; localB -> WorkingSet . isActiveConstr [ i ] = false ; localB -> WorkingSet . Wid [ i ] = 0 ; localB -> WorkingSet . Wlocalidx [ i ] = 0 ; } for ( i = 0 ; i < 5 ; i ++ ) { localB -> WorkingSet . nWConstr [ i ] = 0 ; } localB -> WorkingSet . probType = 3 ; localB -> WorkingSet . SLACK0 = 1.0E-5 ; memset ( & localB -> WorkingSet . indexLB [ 0 ] , 0 , 121U * sizeof ( int32_T ) ) ; memset ( & localB -> WorkingSet . indexUB [ 0 ] , 0 , 121U * sizeof ( int32_T ) ) ; memset ( & localB -> WorkingSet . indexFixed [ 0 ] , 0 , 121U * sizeof ( int32_T ) ) ; i = 0 ; mUB = 0 ; mFixed = 0 ; for ( d_idx = 0 ; d_idx < 26 ; d_idx ++ ) { smax = lb [ d_idx ] ; guard1 = false ; if ( ( ! muDoubleScalarIsInf ( smax ) ) && ( ! muDoubleScalarIsNaN ( smax ) ) ) { if ( muDoubleScalarAbs ( smax - ub [ d_idx ] ) < 1.0E-6 ) { mFixed ++ ; localB -> WorkingSet . indexFixed [ mFixed - 1 ] = d_idx + 1 ; } else { i ++ ; localB -> WorkingSet . indexLB [ i - 1 ] = d_idx + 1 ; guard1 = true ; } } else { guard1 = true ; } if ( guard1 ) { smax = ub [ d_idx ] ; if ( ( ! muDoubleScalarIsInf ( smax ) ) && ( ! muDoubleScalarIsNaN ( smax ) ) ) { mUB ++ ; localB -> WorkingSet . indexUB [ mUB - 1 ] = d_idx + 1 ; } } } d_idx = ( ( i + mUB ) + mFixed ) + 74 ; localB -> WorkingSet . mConstr = d_idx ; localB -> WorkingSet . mConstrOrig = d_idx ; localB -> WorkingSet . mConstrMax = 221 ; localB -> WorkingSet . sizes [ 0 ] = mFixed ; localB -> WorkingSet . sizes [ 1 ] = 20 ; localB -> WorkingSet . sizes [ 2 ] = 54 ; localB -> WorkingSet . sizes [ 3 ] = i ; localB -> WorkingSet . sizes [ 4 ] = mUB ; for ( d_idx = 0 ; d_idx < 5 ; d_idx ++ ) { localB -> WorkingSet . sizesNormal [ d_idx ] = localB -> WorkingSet . sizes [ d_idx ] ; } localB -> WorkingSet . sizesPhaseOne [ 0 ] = mFixed ; localB -> WorkingSet . sizesPhaseOne [ 1 ] = 20 ; localB -> WorkingSet . sizesPhaseOne [ 2 ] = 54 ; localB -> WorkingSet . sizesPhaseOne [ 3 ] = i + 1 ; localB -> WorkingSet . sizesPhaseOne [ 4 ] = mUB ; localB -> WorkingSet . sizesRegularized [ 0 ] = mFixed ; localB -> WorkingSet . sizesRegularized [ 1 ] = 20 ; localB -> WorkingSet . sizesRegularized [ 2 ] = 54 ; localB -> WorkingSet . sizesRegularized [ 3 ] = i + 94 ; localB -> WorkingSet . sizesRegularized [ 4 ] = mUB ; localB -> WorkingSet . sizesRegPhaseOne [ 0 ] = mFixed ; localB -> WorkingSet . sizesRegPhaseOne [ 1 ] = 20 ; localB -> WorkingSet . sizesRegPhaseOne [ 2 ] = 54 ; localB -> WorkingSet . sizesRegPhaseOne [ 3 ] = i + 95 ; localB -> WorkingSet . sizesRegPhaseOne [ 4 ] = mUB ; localB -> WorkingSet . isActiveIdxNormal [ 0 ] = 1 ; localB -> WorkingSet . isActiveIdxNormal [ 1 ] = mFixed ; localB -> WorkingSet . isActiveIdxNormal [ 2 ] = 20 ; localB -> WorkingSet . isActiveIdxNormal [ 3 ] = 54 ; localB -> WorkingSet . isActiveIdxNormal [ 4 ] = i ; localB -> WorkingSet . isActiveIdxNormal [ 5 ] = mUB ; for ( d_idx = 0 ; d_idx < 6 ; d_idx ++ ) { localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx ] = localB -> WorkingSet . isActiveIdxNormal [ d_idx ] ; } for ( d_idx = 0 ; d_idx < 5 ; d_idx ++ ) { localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx + 1 ] += localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx ] ; } for ( d_idx = 0 ; d_idx < 6 ; d_idx ++ ) { localB -> WorkingSet . isActiveIdx [ d_idx ] = localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx ] ; } localB -> WorkingSet . isActiveIdxRegPhaseOne [ 0 ] = 1 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 1 ] = mFixed ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 2 ] = 20 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 3 ] = 54 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 4 ] = i + 1 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 5 ] = mUB ; for ( d_idx = 0 ; d_idx < 5 ; d_idx ++ ) { localB -> WorkingSet . isActiveIdxNormal [ d_idx + 1 ] += localB -> WorkingSet . isActiveIdxNormal [ d_idx ] ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx + 1 ] += localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx ] ; } for ( d_idx = 0 ; d_idx < 6 ; d_idx ++ ) { localB -> WorkingSet . isActiveIdxPhaseOne [ d_idx ] = localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx ] ; } localB -> WorkingSet . isActiveIdxRegPhaseOne [ 0 ] = 1 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 1 ] = mFixed ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 2 ] = 20 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 3 ] = 54 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 4 ] = i + 94 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 5 ] = mUB ; for ( d_idx = 0 ; d_idx < 5 ; d_idx ++ ) { localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx + 1 ] += localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx ] ; } for ( d_idx = 0 ; d_idx < 6 ; d_idx ++ ) { localB -> WorkingSet . isActiveIdxRegularized [ d_idx ] = localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx ] ; } localB -> WorkingSet . isActiveIdxRegPhaseOne [ 0 ] = 1 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 1 ] = mFixed ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 2 ] = 20 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 3 ] = 54 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 4 ] = i + 95 ; localB -> WorkingSet . isActiveIdxRegPhaseOne [ 5 ] = mUB ; for ( d_idx = 0 ; d_idx < 5 ; d_idx ++ ) { localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx + 1 ] += localB -> WorkingSet . isActiveIdxRegPhaseOne [ d_idx ] ; } iAT0 = ( uint8_T ) i ; for ( d_idx = 0 ; d_idx < iAT0 ; d_idx ++ ) { b_iAT0 = localB -> WorkingSet . indexLB [ d_idx ] ; localB -> TrialState . xstarsqp [ b_iAT0 - 1 ] = muDoubleScalarMax ( localB -> TrialState . xstarsqp [ b_iAT0 - 1 ] , lb [ b_iAT0 - 1 ] ) ; } iAT0 = ( uint8_T ) mUB ; for ( d_idx = 0 ; d_idx < iAT0 ; d_idx ++ ) { b_iAT0 = localB -> WorkingSet . indexUB [ d_idx ] ; localB -> TrialState . xstarsqp [ b_iAT0 - 1 ] = muDoubleScalarMin ( localB -> TrialState . xstarsqp [ b_iAT0 - 1 ] , ub [ b_iAT0 - 1 ] ) ; } iAT0 = ( uint8_T ) mFixed ; for ( d_idx = 0 ; d_idx < iAT0 ; d_idx ++ ) { b_iAT0 = localB -> WorkingSet . indexFixed [ d_idx ] ; localB -> TrialState . xstarsqp [ b_iAT0 - 1 ] = ub [ b_iAT0 - 1 ] ; } in0icnpfc3 ( nonlcon_workspace -> xk , nonlcon_workspace -> PrevEMTrqCmdFinals , nonlcon_workspace -> Vx , nonlcon_workspace -> delta_Frnt , nonlcon_workspace -> EMTrqMaxFrnt , nonlcon_workspace -> EMTrqMaxRear , nonlcon_workspace -> Acc , nonlcon_workspace -> EMFrntTrq , nonlcon_workspace -> EMRearTrq , & FcnEvaluator . next . next . next . next . next . next . next . next . b_value . workspace , localB -> TrialState . xstarsqp , localB -> TrialState . cIneq , localB -> TrialState . cEq , & localB -> TrialState . sqpFval , & d_idx ) ; e4ctbgzcfy3 ( fun_workspace_xk , fun_workspace_PrevEMTrqCmdFinals , fun_workspace_EMFrntTrq , fun_workspace_EMRearTrq , fun_workspace_r_ref , nonlcon_workspace , lb , ub , & FiniteDifferences ) ; bvp0ue5q2p ( & FiniteDifferences , localB -> TrialState . sqpFval , localB -> TrialState . cIneq , localB -> TrialState . cEq , localB -> TrialState . xstarsqp , localB -> TrialState . grad , localB -> WorkingSet . Aineq , localB -> WorkingSet . Aeq , lb , ub ) ; localB -> TrialState . FunctionEvaluations = FiniteDifferences . numEvals + 1 ; iAT0 = - 1 ; smax = muDoubleScalarAbs ( localB -> TrialState . grad [ 0 ] ) ; for ( b_iAT0 = 0 ; b_iAT0 < 25 ; b_iAT0 ++ ) { s = muDoubleScalarAbs ( localB -> TrialState . grad [ b_iAT0 + 1 ] ) ; if ( s > smax ) { iAT0 = b_iAT0 ; smax = s ; } } smax = muDoubleScalarAbs ( localB -> TrialState . grad [ iAT0 + 1 ] ) ; if ( smax < 4.4408920985006262E-16 ) { smax = 1.0 ; } smax = muDoubleScalarMax ( 1.0E-8 , muDoubleScalarMin ( 1.0 , 100.0 / smax ) ) ; for ( b_iAT0 = 1 ; b_iAT0 <= 25 ; b_iAT0 += 2 ) { tmp = _mm_loadu_pd ( & localB -> TrialState . grad [ b_iAT0 - 1 ] ) ; _mm_storeu_pd ( & localB -> TrialState . grad [ b_iAT0 - 1 ] , _mm_mul_pd ( tmp , _mm_set1_pd ( smax ) ) ) ; } b = localB -> TrialState . sqpFval * smax ; localB -> TrialState . sqpFval = b ; b_iAT0 = 0 ; for ( d_idx = 0 ; d_idx < 20 ; d_idx ++ ) { ix = - 1 ; s = muDoubleScalarAbs ( localB -> WorkingSet . Aeq [ b_iAT0 ] ) ; for ( iAT0 = 0 ; iAT0 < 25 ; iAT0 ++ ) { b_s = muDoubleScalarAbs ( localB -> WorkingSet . Aeq [ ( b_iAT0 + iAT0 ) + 1 ] ) ; if ( b_s > s ) { ix = iAT0 ; s = b_s ; } } s = muDoubleScalarAbs ( localB -> WorkingSet . Aeq [ ( b_iAT0 + ix ) + 1 ] ) ; if ( s < 4.4408920985006262E-16 ) { s = 1.0 ; } s = muDoubleScalarMin ( 1.0 , 100.0 / s ) ; d [ d_idx ] = muDoubleScalarMax ( 1.0E-8 , s ) ; ix = b_iAT0 + 27 ; vectorUB = b_iAT0 + 25 ; for ( iAT0 = b_iAT0 + 1 ; iAT0 <= vectorUB ; iAT0 += 2 ) { tmp = _mm_loadu_pd ( & localB -> WorkingSet . Aeq [ iAT0 - 1 ] ) ; _mm_storeu_pd ( & localB -> WorkingSet . Aeq [ iAT0 - 1 ] , _mm_mul_pd ( tmp , _mm_set1_pd ( d [ d_idx ] ) ) ) ; } for ( iAT0 = ix ; iAT0 <= b_iAT0 + 26 ; iAT0 ++ ) { localB -> WorkingSet . Aeq [ iAT0 - 1 ] *= d [ d_idx ] ; } localB -> TrialState . cEq [ d_idx ] *= d [ d_idx ] ; b_iAT0 += 121 ; } b_iAT0 = 0 ; for ( d_idx = 0 ; d_idx < 54 ; d_idx ++ ) { ix = - 1 ; s = muDoubleScalarAbs ( localB -> WorkingSet . Aineq [ b_iAT0 ] ) ; for ( iAT0 = 0 ; iAT0 < 25 ; iAT0 ++ ) { b_s = muDoubleScalarAbs ( localB -> WorkingSet . Aineq [ ( b_iAT0 + iAT0 ) + 1 ] ) ; if ( b_s > s ) { ix = iAT0 ; s = b_s ; } } s = muDoubleScalarAbs ( localB -> WorkingSet . Aineq [ ( b_iAT0 + ix ) + 1 ] ) ; if ( s < 4.4408920985006262E-16 ) { s = 1.0 ; } s = muDoubleScalarMin ( 1.0 , 100.0 / s ) ; f [ d_idx ] = muDoubleScalarMax ( 1.0E-8 , s ) ; ix = b_iAT0 + 27 ; vectorUB = b_iAT0 + 25 ; for ( iAT0 = b_iAT0 + 1 ; iAT0 <= vectorUB ; iAT0 += 2 ) { tmp = _mm_loadu_pd ( & localB -> WorkingSet . Aineq [ iAT0 - 1 ] ) ; _mm_storeu_pd ( & localB -> WorkingSet . Aineq [ iAT0 - 1 ] , _mm_mul_pd ( tmp , _mm_set1_pd ( f [ d_idx ] ) ) ) ; } for ( iAT0 = ix ; iAT0 <= b_iAT0 + 26 ; iAT0 ++ ) { localB -> WorkingSet . Aineq [ iAT0 - 1 ] *= f [ d_idx ] ; } localB -> TrialState . cIneq [ d_idx ] *= f [ d_idx ] ; b_iAT0 += 121 ; } hqukg0j2js ( x0 , & localB -> WorkingSet , localB -> TrialState . cIneq , localB -> TrialState . cEq , i , lb , mUB , ub , mFixed ) ; ai0qsnj2tx ( & localB -> WorkingSet ) ; MeritFunction . initFval = b ; MeritFunction . penaltyParam = 1.0 ; MeritFunction . threshold = 0.0001 ; MeritFunction . nPenaltyDecreases = 0 ; MeritFunction . linearizedConstrViol = 0.0 ; b = 0.0 ; for ( i = 0 ; i < 20 ; i ++ ) { b += muDoubleScalarAbs ( localB -> TrialState . cEq [ i ] ) ; } MeritFunction . initConstrViolationEq = b ; b = 0.0 ; for ( i = 0 ; i < 54 ; i ++ ) { s = localB -> TrialState . cIneq [ i ] ; if ( s > 0.0 ) { b += s ; } } MeritFunction . initConstrViolationIneq = b ; MeritFunction . phi = 0.0 ; MeritFunction . phiPrimePlus = 0.0 ; MeritFunction . phiFullStep = 0.0 ; MeritFunction . feasRelativeFactor = 0.0 ; MeritFunction . nlpPrimalFeasError = 0.0 ; MeritFunction . nlpDualFeasError = 0.0 ; MeritFunction . nlpComplError = 0.0 ; MeritFunction . firstOrderOpt = 0.0 ; e4ctbgzcfy3j ( & localB -> QRManager ) ; for ( i = 0 ; i < 121 ; i ++ ) { QPObjective . grad [ i ] = 0.0 ; } for ( i = 0 ; i < 120 ; i ++ ) { QPObjective . Hx [ i ] = 0.0 ; } QPObjective . hasLinear = true ; QPObjective . nvar = 26 ; QPObjective . beta = 0.0 ; QPObjective . rho = 0.0 ; QPObjective . objtype = 3 ; QPObjective . prev_objtype = 3 ; QPObjective . prev_nvar = 0 ; QPObjective . prev_hasLinear = false ; QPObjective . gammaScalar = 0.0 ; ckrin4u0eh ( lb , ub , & localB -> TrialState , & MeritFunction , & FcnEvaluator , & FiniteDifferences , & localB -> memspace , & localB -> WorkingSet , & localB -> QRManager , & QPObjective , smax , f , d , localB -> Hessian , & localB -> CholManager , localB ) ; * fval = localB -> TrialState . sqpFval ; * exitflag = localB -> TrialState . sqpExitFlag ; * output_iterations = localB -> TrialState . sqpIterations ; * output_funcCount = localB -> TrialState . FunctionEvaluations ; output_algorithm [ 0 ] = 's' ; output_algorithm [ 1 ] = 'q' ; output_algorithm [ 2 ] = 'p' ; * output_constrviolation = MeritFunction . nlpPrimalFeasError ; b = 0.0 ; smax = 3.3121686421112381E-170 ; for ( i = 0 ; i < 26 ; i ++ ) { x0 [ i ] = localB -> TrialState . xstarsqp [ i ] ; s = muDoubleScalarAbs ( localB -> TrialState . delta_x [ i ] ) ; if ( s > smax ) { b_s = smax / s ; b = b * b_s * b_s + 1.0 ; smax = s ; } else { b_s = s / smax ; b += b_s * b_s ; } } * output_stepsize = smax * muDoubleScalarSqrt ( b ) ; * output_lssteplength = localB -> TrialState . steplength ; * output_firstorderopt = MeritFunction . firstOrderOpt ; } } void cudgh3jl0o ( ghy3lg3t4k * const obwppemxpt , fuctzs4sww * localDW ) { if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "WhlTrqCmd" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "WhlTrqCmd" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Accel Pedal to Traction Wheel Torque Request" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "WhlTrqCmd" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> ivmrcbyxgt . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "04964e62-20d6-4a58-868c-0491786a06bf" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> ivmrcbyxgt . AQHandles , hDT , & srcInfo ) ; if ( localDW -> ivmrcbyxgt . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> ivmrcbyxgt . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> ivmrcbyxgt . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> ivmrcbyxgt . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> ivmrcbyxgt . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> ivmrcbyxgt . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> ivmrcbyxgt . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "EMTrqCmd" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "EMTrqCmd" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Energy Management" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "EMTrqCmd" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 4 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> l4ltxt5zx1 . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "3c2b8de8-9054-4b7d-a064-fd5e614ca1a7" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> l4ltxt5zx1 . AQHandles , hDT , & srcInfo ) ; if ( localDW -> l4ltxt5zx1 . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> l4ltxt5zx1 . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> l4ltxt5zx1 . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> l4ltxt5zx1 . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> l4ltxt5zx1 . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> l4ltxt5zx1 . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> l4ltxt5zx1 . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "outputStates" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "outputStates" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/From11" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "outputStates" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 2 ] = { ( int_T ) 2 , ( int_T ) 1 } ; sigDims . nDims = 2 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> iow1zb41nn . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "0087e01a-cd80-48c5-a5e3-c72495c040f2" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> iow1zb41nn . AQHandles , hDT , & srcInfo ) ; if ( localDW -> iow1zb41nn . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> iow1zb41nn . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> iow1zb41nn . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> iow1zb41nn . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> iow1zb41nn . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> iow1zb41nn . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> iow1zb41nn . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "EMTrqCmdFinal" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "EMTrqCmdFinal" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "EMTrqCmdFinal" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 2 ] = { ( int_T ) 4 , ( int_T ) 1 } ; sigDims . nDims = 2 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> depxbtcebe . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "4fe65565-e1a9-455c-bb89-f9701a28222f" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> depxbtcebe . AQHandles , hDT , & srcInfo ) ; if ( localDW -> depxbtcebe . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> depxbtcebe . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> depxbtcebe . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> depxbtcebe . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> depxbtcebe . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> depxbtcebe . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> depxbtcebe . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "inputStates" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "inputStates" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Unit Delay1" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "inputStates" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 2 ] = { ( int_T ) 11 , ( int_T ) 1 } ; sigDims . nDims = 2 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> dkrgzmmphu . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "f6f6e9b9-52a7-44ab-8e4c-f1742cdbc9ed" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> dkrgzmmphu . AQHandles , hDT , & srcInfo ) ; if ( localDW -> dkrgzmmphu . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> dkrgzmmphu . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> dkrgzmmphu . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> dkrgzmmphu . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> dkrgzmmphu . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> dkrgzmmphu . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> dkrgzmmphu . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "TVen" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "TVen" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Logical Operator1" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "TVen" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_BOOLEAN ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> fv1ztkelof . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "ef3cd4a3-0cf5-4e25-827e-e11ed46d15da" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> fv1ztkelof . AQHandles , hDT , & srcInfo ) ; if ( localDW -> fv1ztkelof . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> fv1ztkelof . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> fv1ztkelof . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> fv1ztkelof . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> fv1ztkelof . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> fv1ztkelof . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> fv1ztkelof . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "r_ref" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "r_ref" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Nonlinear_MPCFcn" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "r_ref" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 10 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> itskgiqhz2 . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "372bd911-0ef8-40b9-8255-f3687da5b1d9" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> itskgiqhz2 . AQHandles , hDT , & srcInfo ) ; if ( localDW -> itskgiqhz2 . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> itskgiqhz2 . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> itskgiqhz2 . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> itskgiqhz2 . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> itskgiqhz2 . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> itskgiqhz2 . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> itskgiqhz2 . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "exitflag" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "exitflag" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Nonlinear_MPCFcn" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "exitflag" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 3 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> mlemipyadb . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "fd482559-0d47-4df0-bc5a-b1c6a2773c3f" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> mlemipyadb . AQHandles , hDT , & srcInfo ) ; if ( localDW -> mlemipyadb . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> mlemipyadb . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> mlemipyadb . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> mlemipyadb . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> mlemipyadb . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> mlemipyadb . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> mlemipyadb . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "allCosts" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "allCosts" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Nonlinear_MPCFcn" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "allCosts" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 2 ] = { ( int_T ) 2 , ( int_T ) 1 } ; sigDims . nDims = 2 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 4 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> ezl2ntihdf . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "cc62a369-a060-45fa-9cf0-f44a7014831d" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> ezl2ntihdf . AQHandles , hDT , & srcInfo ) ; if ( localDW -> ezl2ntihdf . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> ezl2ntihdf . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> ezl2ntihdf . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> ezl2ntihdf . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> ezl2ntihdf . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> ezl2ntihdf . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> ezl2ntihdf . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "compTime" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "compTime" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Nonlinear_MPCFcn" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "compTime" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 5 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> i1mtsusvml . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "877e5da2-8d75-48a9-9386-5a3ebafa5341" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> i1mtsusvml . AQHandles , hDT , & srcInfo ) ; if ( localDW -> i1mtsusvml . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> i1mtsusvml . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> i1mtsusvml . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> i1mtsusvml . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> i1mtsusvml . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> i1mtsusvml . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> i1mtsusvml . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "stepsize" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "stepsize" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Nonlinear_MPCFcn" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "stepsize" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 6 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> cekiui3znc . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "63b164cc-2bc2-42b9-8c41-1e7f9e4c8838" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> cekiui3znc . AQHandles , hDT , & srcInfo ) ; if ( localDW -> cekiui3znc . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> cekiui3znc . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> cekiui3znc . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> cekiui3znc . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> cekiui3znc . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> cekiui3znc . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> cekiui3znc . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "iterations" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "iterations" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Nonlinear_MPCFcn" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "iterations" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 7 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> ol1dphwxf3 . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "19ea3c50-b545-479c-b063-a292bc00bed8" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> ol1dphwxf3 . AQHandles , hDT , & srcInfo ) ; if ( localDW -> ol1dphwxf3 . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> ol1dphwxf3 . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> ol1dphwxf3 . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> ol1dphwxf3 . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> ol1dphwxf3 . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> ol1dphwxf3 . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> ol1dphwxf3 . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "funcCount" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "funcCount" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Nonlinear_MPCFcn" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "funcCount" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 8 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> ms4bj3urgt . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "a2330ca8-7d04-46d5-825f-ce238c452fc3" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> ms4bj3urgt . AQHandles , hDT , & srcInfo ) ; if ( localDW -> ms4bj3urgt . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> ms4bj3urgt . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> ms4bj3urgt . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> ms4bj3urgt . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> ms4bj3urgt . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> ms4bj3urgt . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> ms4bj3urgt . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "beta_max" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "beta_max" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Nonlinear_MPCFcn" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "beta_max" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 9 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> k3hp0ajooa . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "92705977-92b9-4cc7-8682-153889d81523" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> k3hp0ajooa . AQHandles , hDT , & srcInfo ) ; if ( localDW -> k3hp0ajooa . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> k3hp0ajooa . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> k3hp0ajooa . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> k3hp0ajooa . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> k3hp0ajooa . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> k3hp0ajooa . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> k3hp0ajooa . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "xk" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "xk" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Reshape6" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "xk" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 2 ] = { ( int_T ) 2 , ( int_T ) 1 } ; sigDims . nDims = 2 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> gctb1llys1 . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "b262d3a8-c2aa-4860-9fde-98ce9a53b4e6" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> gctb1llys1 . AQHandles , hDT , & srcInfo ) ; if ( localDW -> gctb1llys1 . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> gctb1llys1 . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> gctb1llys1 . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> gctb1llys1 . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> gctb1llys1 . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> gctb1llys1 . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> gctb1llys1 . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { { if ( slIsRapidAcceleratorSimulating ( ) || ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) == SS_SIMMODE_NORMAL ) || ssRTWGenIsAccelerator ( obwppemxpt -> _mdlRefSfcnS ) ) { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "xhat_kp1" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "xhat_kp1" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "EvPowertrainController4EM/Torque Vectoring/Nonlinear_MPC/Unit Delay1" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiDims forEachMdlRefDims ; int_T forEachMdlRefDimsArray [ 32 ] ; sdiLabelU sigName = sdiGetLabelFromChars ( "xhat_kp1" ) ; sdiAsyncQueueHandle hForEachParent = ( NULL ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 2 ] = { ( int_T ) 2 , ( int_T ) 1 } ; sigDims . nDims = 2 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; if ( slIsRapidAcceleratorSimulating ( ) ) { forEachMdlRefDims . nDims = 0 ; } else { forEachMdlRefDims . nDims = slSigLogGetForEachDimsForRefModel ( obwppemxpt -> _mdlRefSfcnS , forEachMdlRefDimsArray ) ; forEachMdlRefDims . dimensions = forEachMdlRefDimsArray ; } if ( forEachMdlRefDims . nDims > 0 ) { hForEachParent = sdiCreateForEachParent ( & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , ( NULL ) , loggedName , origSigName , propName , & forEachMdlRefDims ) ; sdiUpdateForEachLeafName ( & srcInfo , hForEachParent ) ; } localDW -> dkrgzmmphuh . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , obwppemxpt -> DataMapInfo . mmi . InstanceMap . fullPath , "75f41b07-057d-40d9-bb1b-e9134084b9dc" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( localDW -> dkrgzmmphuh . AQHandles , hDT , & srcInfo ) ; if ( localDW -> dkrgzmmphuh . AQHandles ) { sdiSetSignalSampleTimeString ( localDW -> dkrgzmmphuh . AQHandles , "0.01" , 0.01 , rtmGetTFinal ( obwppemxpt ) ) ; sdiSetSignalRefRate ( localDW -> dkrgzmmphuh . AQHandles , 0.0 ) ; sdiSetRunStartTime ( localDW -> dkrgzmmphuh . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) ) ; sdiAsyncRepoSetSignalExportSettings ( localDW -> dkrgzmmphuh . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( localDW -> dkrgzmmphuh . AQHandles , loggedName , origSigName , propName ) ; if ( forEachMdlRefDims . nDims > 0 ) { sdiAttachForEachIterationToParent ( hForEachParent , localDW -> dkrgzmmphuh . AQHandles , ( NULL ) ) ; if ( srcInfo . signalName != sigName ) { sdiFreeName ( srcInfo . signalName ) ; } } } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } } void dx03fqh3vz ( real_T * d5al3q5d2n , real_T * h1t2u5fil2 , real_T * j200csbdtq , real_T * jxlsupm5zm , real_T * fbgdfzguau , fuctzs4sww * localDW ) { real_T tmp ; int32_T i ; int32_T t ; uint32_T tseed ; * d5al3q5d2n = njz0210ca5 . P_157 ; localDW -> lcjh3yhjfv [ 0 ] = njz0210ca5 . P_164 ; localDW -> o4ablo3jr0 = 0 ; localDW -> aqogycpvqd [ 0 ] = njz0210ca5 . P_167 ; localDW -> pbom5jpcjj = 0 ; localDW -> pophr5lzve [ 0 ] = njz0210ca5 . P_168 [ 0 ] ; localDW -> pophr5lzve [ 1 ] = njz0210ca5 . P_168 [ 1 ] ; localDW -> pophr5lzve [ 2 ] = njz0210ca5 . P_168 [ 2 ] ; localDW -> pophr5lzve [ 3 ] = njz0210ca5 . P_168 [ 3 ] ; memcpy ( & localDW -> fy5ps0vnmo [ 0 ] , & njz0210ca5 . P_171 [ 0 ] , 26U * sizeof ( real_T ) ) ; memcpy ( & localDW -> fyczfqu5d1 [ 0 ] , & njz0210ca5 . P_172 [ 0 ] , 11U * sizeof ( real_T ) ) ; localDW -> p1ynaxw2kn [ 0 ] = njz0210ca5 . P_176 ; localDW -> p1ynaxw2kn [ 1 ] = njz0210ca5 . P_176 ; localDW -> p1ynaxw2kn [ 2 ] = njz0210ca5 . P_176 ; localDW -> p1ynaxw2kn [ 3 ] = njz0210ca5 . P_176 ; localDW -> k3wtm0bzih [ 0 ] = njz0210ca5 . P_177 [ 0 ] ; localDW -> k3wtm0bzih [ 1 ] = njz0210ca5 . P_177 [ 1 ] ; * h1t2u5fil2 = njz0210ca5 . P_178 ; * j200csbdtq = njz0210ca5 . P_179 ; * jxlsupm5zm = njz0210ca5 . P_180 ; * fbgdfzguau = njz0210ca5 . P_181 ; tmp = muDoubleScalarFloor ( njz0210ca5 . P_37 ) ; if ( muDoubleScalarIsNaN ( tmp ) || muDoubleScalarIsInf ( tmp ) ) { tmp = 0.0 ; } else { tmp = muDoubleScalarRem ( tmp , 4.294967296E+9 ) ; } if ( tmp < 0.0 ) { tseed = ( uint32_T ) - ( int32_T ) ( uint32_T ) - tmp ; } else { tseed = ( uint32_T ) tmp ; } i = ( int32_T ) ( tseed >> 16U ) ; t = ( int32_T ) ( tseed & 32768U ) ; tseed = ( ( ( ( tseed - ( ( uint32_T ) i << 16U ) ) + ( uint32_T ) t ) << 16U ) + ( uint32_T ) t ) + ( uint32_T ) i ; if ( tseed < 1U ) { tseed = 1144108930U ; } else if ( tseed > 2147483646U ) { tseed = 2147483646U ; } localDW -> mwdg02ndpd = tseed ; localDW -> pg2hyiwwhz = rt_nrand_Upu32_Yd_f_pw_snf ( & localDW -> mwdg02ndpd ) * njz0210ca5 . P_183 + njz0210ca5 . P_182 ; tmp = muDoubleScalarFloor ( njz0210ca5 . P_38 ) ; if ( muDoubleScalarIsNaN ( tmp ) || muDoubleScalarIsInf ( tmp ) ) { tmp = 0.0 ; } else { tmp = muDoubleScalarRem ( tmp , 4.294967296E+9 ) ; } if ( tmp < 0.0 ) { tseed = ( uint32_T ) - ( int32_T ) ( uint32_T ) - tmp ; } else { tseed = ( uint32_T ) tmp ; } i = ( int32_T ) ( tseed >> 16U ) ; t = ( int32_T ) ( tseed & 32768U ) ; tseed = ( ( ( ( tseed - ( ( uint32_T ) i << 16U ) ) + ( uint32_T ) t ) << 16U ) + ( uint32_T ) t ) + ( uint32_T ) i ; if ( tseed < 1U ) { tseed = 1144108930U ; } else if ( tseed > 2147483646U ) { tseed = 2147483646U ; } localDW -> jmxm2hc1kh = tseed ; localDW -> pepscbjqk4 = rt_nrand_Upu32_Yd_f_pw_snf ( & localDW -> jmxm2hc1kh ) * njz0210ca5 . P_185 + njz0210ca5 . P_184 ; for ( i = 0 ; i < 201 ; i ++ ) { localDW -> m2eudybppp [ i ] = njz0210ca5 . P_98 ; localDW -> fsvou2544p [ i ] = njz0210ca5 . P_103 ; localDW -> hheq0b5rgn [ i ] = njz0210ca5 . P_104 ; localDW -> bkeddeqpbw [ i ] = njz0210ca5 . P_114 ; } localDW -> jxlucfehp1 = njz0210ca5 . P_137 ; localDW -> knprixuhqy = njz0210ca5 . P_138 ; localDW -> hyfypdejrs = njz0210ca5 . P_149 ; localDW -> i1rb5p2wdu = njz0210ca5 . P_152 ; } void cvnazlnugz ( real_T * d5al3q5d2n , real_T * h1t2u5fil2 , real_T * j200csbdtq , real_T * jxlsupm5zm , real_T * fbgdfzguau , fuctzs4sww * localDW ) { real_T tmp ; int32_T i ; int32_T t ; uint32_T tseed ; * d5al3q5d2n = njz0210ca5 . P_157 ; localDW -> lcjh3yhjfv [ 0 ] = njz0210ca5 . P_164 ; localDW -> o4ablo3jr0 = 0 ; localDW -> aqogycpvqd [ 0 ] = njz0210ca5 . P_167 ; localDW -> pbom5jpcjj = 0 ; localDW -> pophr5lzve [ 0 ] = njz0210ca5 . P_168 [ 0 ] ; localDW -> pophr5lzve [ 1 ] = njz0210ca5 . P_168 [ 1 ] ; localDW -> pophr5lzve [ 2 ] = njz0210ca5 . P_168 [ 2 ] ; localDW -> pophr5lzve [ 3 ] = njz0210ca5 . P_168 [ 3 ] ; memcpy ( & localDW -> fy5ps0vnmo [ 0 ] , & njz0210ca5 . P_171 [ 0 ] , 26U * sizeof ( real_T ) ) ; memcpy ( & localDW -> fyczfqu5d1 [ 0 ] , & njz0210ca5 . P_172 [ 0 ] , 11U * sizeof ( real_T ) ) ; localDW -> p1ynaxw2kn [ 0 ] = njz0210ca5 . P_176 ; localDW -> p1ynaxw2kn [ 1 ] = njz0210ca5 . P_176 ; localDW -> p1ynaxw2kn [ 2 ] = njz0210ca5 . P_176 ; localDW -> p1ynaxw2kn [ 3 ] = njz0210ca5 . P_176 ; localDW -> k3wtm0bzih [ 0 ] = njz0210ca5 . P_177 [ 0 ] ; localDW -> k3wtm0bzih [ 1 ] = njz0210ca5 . P_177 [ 1 ] ; * h1t2u5fil2 = njz0210ca5 . P_178 ; * j200csbdtq = njz0210ca5 . P_179 ; * jxlsupm5zm = njz0210ca5 . P_180 ; * fbgdfzguau = njz0210ca5 . P_181 ; tmp = muDoubleScalarFloor ( njz0210ca5 . P_37 ) ; if ( muDoubleScalarIsNaN ( tmp ) || muDoubleScalarIsInf ( tmp ) ) { tmp = 0.0 ; } else { tmp = muDoubleScalarRem ( tmp , 4.294967296E+9 ) ; } if ( tmp < 0.0 ) { tseed = ( uint32_T ) - ( int32_T ) ( uint32_T ) - tmp ; } else { tseed = ( uint32_T ) tmp ; } i = ( int32_T ) ( tseed >> 16U ) ; t = ( int32_T ) ( tseed & 32768U ) ; tseed = ( ( ( ( tseed - ( ( uint32_T ) i << 16U ) ) + ( uint32_T ) t ) << 16U ) + ( uint32_T ) t ) + ( uint32_T ) i ; if ( tseed < 1U ) { tseed = 1144108930U ; } else if ( tseed > 2147483646U ) { tseed = 2147483646U ; } localDW -> mwdg02ndpd = tseed ; localDW -> pg2hyiwwhz = rt_nrand_Upu32_Yd_f_pw_snf ( & localDW -> mwdg02ndpd ) * njz0210ca5 . P_183 + njz0210ca5 . P_182 ; tmp = muDoubleScalarFloor ( njz0210ca5 . P_38 ) ; if ( muDoubleScalarIsNaN ( tmp ) || muDoubleScalarIsInf ( tmp ) ) { tmp = 0.0 ; } else { tmp = muDoubleScalarRem ( tmp , 4.294967296E+9 ) ; } if ( tmp < 0.0 ) { tseed = ( uint32_T ) - ( int32_T ) ( uint32_T ) - tmp ; } else { tseed = ( uint32_T ) tmp ; } i = ( int32_T ) ( tseed >> 16U ) ; t = ( int32_T ) ( tseed & 32768U ) ; tseed = ( ( ( ( tseed - ( ( uint32_T ) i << 16U ) ) + ( uint32_T ) t ) << 16U ) + ( uint32_T ) t ) + ( uint32_T ) i ; if ( tseed < 1U ) { tseed = 1144108930U ; } else if ( tseed > 2147483646U ) { tseed = 2147483646U ; } localDW -> jmxm2hc1kh = tseed ; localDW -> pepscbjqk4 = rt_nrand_Upu32_Yd_f_pw_snf ( & localDW -> jmxm2hc1kh ) * njz0210ca5 . P_185 + njz0210ca5 . P_184 ; for ( i = 0 ; i < 201 ; i ++ ) { localDW -> m2eudybppp [ i ] = njz0210ca5 . P_98 ; localDW -> fsvou2544p [ i ] = njz0210ca5 . P_103 ; localDW -> hheq0b5rgn [ i ] = njz0210ca5 . P_104 ; localDW -> bkeddeqpbw [ i ] = njz0210ca5 . P_114 ; } localDW -> jxlucfehp1 = njz0210ca5 . P_137 ; localDW -> knprixuhqy = njz0210ca5 . P_138 ; localDW -> hyfypdejrs = njz0210ca5 . P_149 ; localDW -> i1rb5p2wdu = njz0210ca5 . P_152 ; } void o2dsc4aixv ( real_T * d5al3q5d2n , real_T * h1t2u5fil2 , real_T * j200csbdtq , real_T * jxlsupm5zm , real_T * fbgdfzguau , d4m2qnxaxx * localB ) { * d5al3q5d2n = njz0210ca5 . P_157 ; localB -> o2qc0z2iec = 4.0 ; * h1t2u5fil2 = njz0210ca5 . P_178 ; * j200csbdtq = njz0210ca5 . P_179 ; * jxlsupm5zm = njz0210ca5 . P_180 ; * fbgdfzguau = njz0210ca5 . P_181 ; } void EvPowertrainController4EMTID0 ( ghy3lg3t4k * const obwppemxpt , const real_T * ou4mx0rbp5 , const real_T lvdodww5cm [ 4 ] , const real_T * abdrusdwgj , const real_T kq5dbo0rgg [ 4 ] , const real_T * iehyt2vhuj , const real_T * nlrfbnbw4m , const real_T * gofaxr5yxi , const real_T * buze2bnr1i , const real_T m1uk1i0jhi [ 3 ] , const real_T e1vxnu1wnp [ 4 ] , const real_T * oakxzdmw2z , const real_T jyoqfmrpak [ 3 ] , const real_T * hqcf5g33ch , const real_T * ob3iqse2rj , real_T * d5al3q5d2n , real_T cmdd4wxsgc [ 4 ] , real_T g0tgkqdgu5 [ 4 ] , real_T * h1t2u5fil2 , real_T * j200csbdtq , real_T * jxlsupm5zm , real_T * fbgdfzguau , real_T ggfsdvp45d [ 6 ] , d4m2qnxaxx * localB , fuctzs4sww * localDW ) { int_T tid = 0 ; real_T kykyroezb3 [ 2 ] ; real_T lgrpva0mqt ; real_T hlsu2gteae ; __m128d tmp_g ; __m128d tmp_j ; cuxlzjpzbn expl_temp_p ; real_T eq1kb23pnb [ 201 ] ; real_T gnci5q4bna [ 201 ] ; real_T k3nibq2osj [ 201 ] ; real_T l510blem21 [ 201 ] ; real_T mq5rveqe55 [ 201 ] ; real_T K_p [ 26 ] ; real_T b_K_p [ 26 ] ; real_T c_K [ 20 ] ; real_T K [ 6 ] ; real_T b_K [ 6 ] ; real_T jhdwllabba [ 4 ] ; real_T fractions [ 2 ] ; real_T k4m51nlsgp [ 2 ] ; real_T tmp [ 2 ] ; real_T tmp_m [ 2 ] ; real_T tmp_p [ 2 ] ; real_T u_max [ 2 ] ; real_T a0rtvf0lak ; real_T cppppprauj ; real_T cyzhwl13yu ; real_T gjhipwfmba_tmp ; real_T gwgcc1xzjk ; real_T ha5otmiloz ; real_T kffmmp0yxb ; real_T kstt2f1lxm ; real_T kzhbx0udjv ; real_T l0n4e35gs4 ; real_T mhyfll4bj5_idx_0 ; real_T mhyfll4bj5_idx_1 ; real_T mhyfll4bj5_idx_2 ; real_T mhyfll4bj5_idx_3 ; real_T n3auok1rpo ; real_T n5rlzqhkys ; real_T * kok5t41cri_p ; int32_T i ; int32_T kidx ; int32_T tmp_e ; uint32_T bpIndices [ 2 ] ; uint32_T bpIndices_p [ 2 ] ; uint32_T tmp_i ; char_T expl_temp [ 3 ] ; boolean_T ar0yintt11 [ 201 ] ; boolean_T g41n1x0lvn [ 201 ] ; boolean_T heizkzed50 [ 201 ] ; boolean_T n5dfgdzrsl_tmp [ 201 ] ; boolean_T cj5m4xyger ; boolean_T e03mybaijr ; boolean_T exitg1 ; boolean_T n5dfgdzrsl_tmp_p ; * d5al3q5d2n = njz0210ca5 . P_157 ; kzhbx0udjv = 1.0 / rtP__PlntWhlLdRadiusFrnt2f2PassVeh_sldd_ * * abdrusdwgj * rtP__PlntEMWhlGearRatioFL2f2Drivetrain_sldd_ ; ha5otmiloz = njz0210ca5 . P_158 * look1_binlcapw ( kzhbx0udjv , rtP__PlntEM1Spd2f2ElectricMachine1_sldd_ , rtP__PlntEM1Trq2f2ElectricMachine1_sldd_ , 13U ) ; if ( ha5otmiloz * kzhbx0udjv >= njz0210ca5 . P_159 ) { kzhbx0udjv = njz0210ca5 . P_41 ; } else { kzhbx0udjv = njz0210ca5 . P_42 ; } gwgcc1xzjk = 1.0 / rtP__PlntWhlLdRadiusRear2f2PassVeh_sldd_ * * abdrusdwgj * rtP__PlntEMWhlGearRatioRL2f2Drivetrain_sldd_ ; n3auok1rpo = njz0210ca5 . P_160 * look1_binlcapw ( gwgcc1xzjk , rtP__PlntEM3Spd2f2ElectricMachine3_sldd_ , rtP__PlntEM3Trq2f2ElectricMachine3_sldd_ , 13U ) ; if ( n3auok1rpo * gwgcc1xzjk >= njz0210ca5 . P_161 ) { gwgcc1xzjk = njz0210ca5 . P_43 ; } else { gwgcc1xzjk = njz0210ca5 . P_44 ; } if ( ( rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ < 0.0 ) && ( kzhbx0udjv > muDoubleScalarFloor ( kzhbx0udjv ) ) ) { cppppprauj = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ , kzhbx0udjv ) ; } else { cppppprauj = muDoubleScalarPower ( rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ , kzhbx0udjv ) ; } if ( ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ < 0.0 ) && ( gwgcc1xzjk > muDoubleScalarFloor ( gwgcc1xzjk ) ) ) { mhyfll4bj5_idx_2 = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , gwgcc1xzjk ) ; } else { mhyfll4bj5_idx_2 = muDoubleScalarPower ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , gwgcc1xzjk ) ; } ha5otmiloz = ( rtP__PlntEMWhlGearRatioFL2f2Drivetrain_sldd_ * ha5otmiloz * cppppprauj + rtP__PlntEMWhlGearRatioRL2f2Drivetrain_sldd_ * n3auok1rpo * mhyfll4bj5_idx_2 ) * * ou4mx0rbp5 ; { if ( tid == 0 ) { if ( localDW -> ivmrcbyxgt . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> ivmrcbyxgt . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & ha5otmiloz + 0 ) ; } } } tmp_j = _mm_set1_pd ( rtP__PlntBrkPrsFctr2f2PassVeh_sldd_ ) ; tmp_g = _mm_mul_pd ( _mm_mul_pd ( _mm_set1_pd ( rtP__PlntBrkFrntBias2f2PassVeh_sldd_ ) , _mm_loadu_pd ( & lvdodww5cm [ 0 ] ) ) , tmp_j ) ; _mm_storeu_pd ( & tmp_m [ 0 ] , tmp_g ) ; mhyfll4bj5_idx_0 = tmp_m [ 0 ] ; mhyfll4bj5_idx_1 = tmp_m [ 1 ] ; tmp_j = _mm_mul_pd ( _mm_mul_pd ( _mm_set1_pd ( rtP__PlntBrkRearBias2f2PassVeh_sldd_ ) , _mm_loadu_pd ( & lvdodww5cm [ 2 ] ) ) , tmp_j ) ; _mm_storeu_pd ( & tmp_m [ 0 ] , tmp_j ) ; mhyfll4bj5_idx_2 = tmp_m [ 0 ] ; mhyfll4bj5_idx_3 = tmp_m [ 1 ] ; kzhbx0udjv = njz0210ca5 . P_162 * * gofaxr5yxi * * nlrfbnbw4m ; n3auok1rpo = njz0210ca5 . P_163 * * buze2bnr1i * * nlrfbnbw4m ; _mm_storeu_pd ( & tmp_m [ 0 ] , _mm_mul_pd ( _mm_add_pd ( _mm_set_pd ( kq5dbo0rgg [ 2 ] , kq5dbo0rgg [ 0 ] ) , _mm_set_pd ( kq5dbo0rgg [ 3 ] , kq5dbo0rgg [ 1 ] ) ) , _mm_set_pd ( njz0210ca5 . P_79 , njz0210ca5 . P_78 ) ) ) ; a0rtvf0lak = tmp_m [ 0 ] ; l0n4e35gs4 = tmp_m [ 1 ] ; gwgcc1xzjk = njz0210ca5 . P_80 * look1_binlcapw ( tmp_m [ 0 ] , rtP__PlntEM1Spd2f2ElectricMachine1_sldd_ , rtP__PlntEM1Trq2f2ElectricMachine1_sldd_ , 13U ) ; if ( gwgcc1xzjk * tmp_m [ 0 ] >= njz0210ca5 . P_81 ) { cyzhwl13yu = njz0210ca5 . P_45 ; } else { cyzhwl13yu = njz0210ca5 . P_46 ; } if ( ( rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ < 0.0 ) && ( cyzhwl13yu > muDoubleScalarFloor ( cyzhwl13yu ) ) ) { cppppprauj = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ , cyzhwl13yu ) ; } else { cppppprauj = muDoubleScalarPower ( rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ , cyzhwl13yu ) ; } k4m51nlsgp [ 0 ] = rtP__PlntEMWhlGearRatioFL2f2Drivetrain_sldd_ * gwgcc1xzjk * cppppprauj ; gwgcc1xzjk = njz0210ca5 . P_82 * look1_binlcapw ( tmp_m [ 1 ] , rtP__PlntEM3Spd2f2ElectricMachine3_sldd_ , rtP__PlntEM3Trq2f2ElectricMachine3_sldd_ , 13U ) ; if ( gwgcc1xzjk * tmp_m [ 1 ] >= njz0210ca5 . P_83 ) { cyzhwl13yu = njz0210ca5 . P_47 ; } else { cyzhwl13yu = njz0210ca5 . P_48 ; } if ( ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ < 0.0 ) && ( cyzhwl13yu > muDoubleScalarFloor ( cyzhwl13yu ) ) ) { cppppprauj = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , cyzhwl13yu ) ; } else { cppppprauj = muDoubleScalarPower ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , cyzhwl13yu ) ; } k4m51nlsgp [ 1 ] = rtP__PlntEMWhlGearRatioRL2f2Drivetrain_sldd_ * gwgcc1xzjk * cppppprauj ; gjhipwfmba_tmp = rtP__PlntBrkKinFricCffFrnt2f2PassVeh_sldd_ * 3.1415926535897931 * 0.0025000000000000005 * rtP__PlntBrkPadMeanRadiusFrnt2f2PassVeh_sldd_ * rtP__PlntBrkNumPadsFrnt2f2PassVeh_sldd_ / 4.0 ; gwgcc1xzjk = ( ( gjhipwfmba_tmp * mhyfll4bj5_idx_0 + gjhipwfmba_tmp * mhyfll4bj5_idx_1 ) + gjhipwfmba_tmp * mhyfll4bj5_idx_2 ) + gjhipwfmba_tmp * mhyfll4bj5_idx_3 ; if ( ! ( * ou4mx0rbp5 > njz0210ca5 . P_84 ) ) { kffmmp0yxb = k4m51nlsgp [ 0 ] ; kffmmp0yxb += k4m51nlsgp [ 1 ] ; ha5otmiloz = look1_binlcapw ( njz0210ca5 . P_51 * * iehyt2vhuj , rtP__CtrlVcuEvSocBpt2f2EvVCU_sldd_ , rtP__CtrlVcuEvChrgLmtBpt2f2EvVCU_sldd_ , 10U ) * look1_binlcapw ( * abdrusdwgj , rtP__CtrlVcuEvRegenBrkSpdBpt2f2EvVCU_sldd_ , rtP__CtrlVcuEvRegenBrkCutOff2f2EvVCU_sldd_ , 1U ) * muDoubleScalarMin ( gwgcc1xzjk , kffmmp0yxb ) * njz0210ca5 . P_52 ; } for ( i = 0 ; i < 200 ; i ++ ) { kffmmp0yxb = njz0210ca5 . P_87 * njz0210ca5 . P_86 [ i ] ; if ( kffmmp0yxb * l0n4e35gs4 >= njz0210ca5 . P_89 ) { cppppprauj = njz0210ca5 . P_85 ; } else { cppppprauj = njz0210ca5 . P_88 ; } if ( ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ < 0.0 ) && ( cppppprauj > muDoubleScalarFloor ( cppppprauj ) ) ) { cyzhwl13yu = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , cppppprauj ) ; } else { cyzhwl13yu = muDoubleScalarPower ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , cppppprauj ) ; } if ( * ou4mx0rbp5 > njz0210ca5 . P_90 ) { l510blem21 [ i + 1 ] = rtP__PlntEMWhlGearRatioRL2f2Drivetrain_sldd_ * kffmmp0yxb * cyzhwl13yu ; } else { l510blem21 [ i + 1 ] = rtP__PlntEMWhlGearRatioRL2f2Drivetrain_sldd_ * kffmmp0yxb * cyzhwl13yu * njz0210ca5 . P_49 ; } cyzhwl13yu = njz0210ca5 . P_93 * njz0210ca5 . P_92 [ i ] ; if ( cyzhwl13yu * a0rtvf0lak >= njz0210ca5 . P_95 ) { cppppprauj = njz0210ca5 . P_91 ; } else { cppppprauj = njz0210ca5 . P_94 ; } if ( ( rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ < 0.0 ) && ( cppppprauj > muDoubleScalarFloor ( cppppprauj ) ) ) { kffmmp0yxb = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ , cppppprauj ) ; } else { kffmmp0yxb = muDoubleScalarPower ( rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ , cppppprauj ) ; } if ( * ou4mx0rbp5 > njz0210ca5 . P_96 ) { eq1kb23pnb [ i + 1 ] = rtP__PlntEMWhlGearRatioFL2f2Drivetrain_sldd_ * cyzhwl13yu * kffmmp0yxb ; } else { eq1kb23pnb [ i + 1 ] = rtP__PlntEMWhlGearRatioFL2f2Drivetrain_sldd_ * cyzhwl13yu * kffmmp0yxb * njz0210ca5 . P_50 ; } } eq1kb23pnb [ 0 ] = ha5otmiloz ; l510blem21 [ 0 ] = ha5otmiloz ; if ( ( * nlrfbnbw4m >= - njz0210ca5 . P_40 ) && ( * nlrfbnbw4m <= njz0210ca5 . P_40 ) ) { if ( * nlrfbnbw4m >= njz0210ca5 . P_58 ) { cppppprauj = njz0210ca5 . P_156 ; } else { cppppprauj = localB -> dghaupurkc ; } kffmmp0yxb = 0.02 / ( 3.0 - muDoubleScalarPower ( * nlrfbnbw4m / 0.01 , 2.0 ) ) * cppppprauj ; } else { kffmmp0yxb = * nlrfbnbw4m ; } kffmmp0yxb = kzhbx0udjv / kffmmp0yxb ; if ( ha5otmiloz > njz0210ca5 . P_102 ) { cyzhwl13yu = ( rtP__PlntVehDstCGRearAxl2f2PassVeh_sldd_ * rtP__PlntVehMass2f2PassVeh_sldd_ * rtP__EnvGrvty2f2Environment_sldd_ - rtP__EnvGrvty2f2Environment_sldd_ * rtP__PlntVehMass2f2PassVeh_sldd_ * ( rtP__PlntVehCGHgtAxl2f2PassVeh_sldd_ + rtP__PlntWhlLdRadiusFrnt2f2PassVeh_sldd_ ) * njz0210ca5 . P_63 ) / ( rtP__PlntVehDstCGFrntAxl2f2PassVeh_sldd_ + rtP__PlntVehDstCGRearAxl2f2PassVeh_sldd_ ) * rtP__PlntWhlLdRadiusFrnt2f2PassVeh_sldd_ * njz0210ca5 . P_64 * njz0210ca5 . P_65 ; } else { cyzhwl13yu = njz0210ca5 . P_101 ; } if ( ha5otmiloz >= 0.0 ) { for ( i = 0 ; i < 201 ; i ++ ) { if ( ha5otmiloz <= l510blem21 [ i ] ) { eq1kb23pnb [ i ] = ha5otmiloz - localDW -> fsvou2544p [ i ] ; } } srUpdateBC ( localDW -> oienxzjnme ) ; } else { for ( i = 0 ; i < 201 ; i ++ ) { kstt2f1lxm = l510blem21 [ i ] ; n5rlzqhkys = eq1kb23pnb [ i ] ; if ( ha5otmiloz >= n5rlzqhkys ) { kstt2f1lxm = ha5otmiloz - localDW -> hheq0b5rgn [ i ] ; } if ( kstt2f1lxm > njz0210ca5 . P_73 ) { kstt2f1lxm = njz0210ca5 . P_73 ; } else if ( kstt2f1lxm < n5rlzqhkys ) { kstt2f1lxm = n5rlzqhkys ; } l510blem21 [ i ] = kstt2f1lxm ; } srUpdateBC ( localDW -> b5yo3nv33g ) ; } if ( ha5otmiloz > njz0210ca5 . P_105 ) { cppppprauj = njz0210ca5 . P_101 ; } else { cppppprauj = ( rtP__PlntVehDstCGRearAxl2f2PassVeh_sldd_ * rtP__PlntVehMass2f2PassVeh_sldd_ * rtP__EnvGrvty2f2Environment_sldd_ - rtP__EnvGrvty2f2Environment_sldd_ * rtP__PlntVehMass2f2PassVeh_sldd_ * ( rtP__PlntVehCGHgtAxl2f2PassVeh_sldd_ + rtP__PlntWhlLdRadiusFrnt2f2PassVeh_sldd_ ) * njz0210ca5 . P_59 ) / ( rtP__PlntVehDstCGFrntAxl2f2PassVeh_sldd_ + rtP__PlntVehDstCGRearAxl2f2PassVeh_sldd_ ) * rtP__PlntWhlLdRadiusFrnt2f2PassVeh_sldd_ * njz0210ca5 . P_60 * njz0210ca5 . P_61 * njz0210ca5 . P_62 ; } for ( i = 0 ; i < 201 ; i ++ ) { n5rlzqhkys = eq1kb23pnb [ i ] ; if ( n5rlzqhkys > cyzhwl13yu ) { eq1kb23pnb [ i ] = cyzhwl13yu ; } else if ( n5rlzqhkys < cppppprauj ) { eq1kb23pnb [ i ] = cppppprauj ; } } cyzhwl13yu = njz0210ca5 . P_106 * k4m51nlsgp [ 0 ] ; cppppprauj = k4m51nlsgp [ 0 ] ; for ( i = 0 ; i < 201 ; i ++ ) { n5rlzqhkys = eq1kb23pnb [ i ] ; e03mybaijr = ( n5rlzqhkys < cyzhwl13yu ) ; g41n1x0lvn [ i ] = e03mybaijr ; if ( n5rlzqhkys > cppppprauj ) { localB -> hifwcmswrk [ i ] = cppppprauj ; } else if ( e03mybaijr ) { localB -> hifwcmswrk [ i ] = cyzhwl13yu ; } else { localB -> hifwcmswrk [ i ] = n5rlzqhkys ; } } cyzhwl13yu = 1.0 / rtP__PlntEMWhlGearRatioFL2f2Drivetrain_sldd_ ; for ( i = 0 ; i < 201 ; i ++ ) { if ( localDW -> m2eudybppp [ i ] * a0rtvf0lak >= njz0210ca5 . P_100 ) { cppppprauj = njz0210ca5 . P_97 ; } else { cppppprauj = njz0210ca5 . P_99 ; } if ( ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ < 0.0 ) && ( cppppprauj > muDoubleScalarFloor ( cppppprauj ) ) ) { cppppprauj = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , cppppprauj ) ; } else { cppppprauj = muDoubleScalarPower ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , cppppprauj ) ; } cppppprauj = njz0210ca5 . P_107 * localB -> hifwcmswrk [ i ] * cyzhwl13yu * ( 1.0 / cppppprauj ) ; localB -> kfky3x1ct4 [ i ] = cppppprauj ; gnci5q4bna [ i ] = a0rtvf0lak * cppppprauj ; mq5rveqe55 [ i ] = muDoubleScalarAbs ( localB -> kfky3x1ct4 [ i ] ) ; } bpIndices [ 0U ] = plook_bincpa ( muDoubleScalarAbs ( tmp_m [ 0 ] ) , rtP__PlntEM1SpdEff2f2ElectricMachine1_sldd_ , 13U , & cyzhwl13yu , & localDW -> pgi1aok3cr ) ; u_max [ 0U ] = cyzhwl13yu ; for ( i = 0 ; i < 201 ; i ++ ) { bpIndices [ 1U ] = plook_bincpa ( mq5rveqe55 [ i ] , rtP__PlntEM1TrqEff2f2ElectricMachine1_sldd_ , 10U , & cyzhwl13yu , & localDW -> g3a1sbd5cj [ i ] ) ; u_max [ 1U ] = cyzhwl13yu ; mq5rveqe55 [ i ] = intrp2d_la_pw ( bpIndices , u_max , rtP__PlntEM1EffTbl2f2ElectricMachine1_sldd_ , 14U , njz0210ca5 . P_188 ) ; } for ( i = 0 ; i < 201 ; i ++ ) { a0rtvf0lak = njz0210ca5 . P_108 * mq5rveqe55 [ i ] ; kstt2f1lxm = gnci5q4bna [ i ] ; if ( kstt2f1lxm >= njz0210ca5 . P_111 ) { cppppprauj = njz0210ca5 . P_109 ; } else { cppppprauj = njz0210ca5 . P_110 ; } if ( ( a0rtvf0lak < 0.0 ) && ( cppppprauj > muDoubleScalarFloor ( cppppprauj ) ) ) { a0rtvf0lak = - muDoubleScalarPower ( - a0rtvf0lak , cppppprauj ) ; } else { a0rtvf0lak = muDoubleScalarPower ( a0rtvf0lak , cppppprauj ) ; } mq5rveqe55 [ i ] = a0rtvf0lak ; k3nibq2osj [ i ] = kstt2f1lxm * a0rtvf0lak ; } if ( ha5otmiloz > njz0210ca5 . P_118 ) { cyzhwl13yu = ( rtP__EnvGrvty2f2Environment_sldd_ * rtP__PlntVehMass2f2PassVeh_sldd_ * ( rtP__PlntVehCGHgtAxl2f2PassVeh_sldd_ + rtP__PlntWhlLdRadiusRear2f2PassVeh_sldd_ ) * njz0210ca5 . P_70 + rtP__PlntVehDstCGFrntAxl2f2PassVeh_sldd_ * rtP__PlntVehMass2f2PassVeh_sldd_ * rtP__EnvGrvty2f2Environment_sldd_ ) / ( rtP__PlntVehDstCGFrntAxl2f2PassVeh_sldd_ + rtP__PlntVehDstCGRearAxl2f2PassVeh_sldd_ ) * rtP__PlntWhlLdRadiusRear2f2PassVeh_sldd_ * njz0210ca5 . P_71 * njz0210ca5 . P_72 ; } else { cyzhwl13yu = njz0210ca5 . P_117 ; } if ( ha5otmiloz > njz0210ca5 . P_119 ) { cppppprauj = njz0210ca5 . P_117 ; } else { cppppprauj = ( rtP__EnvGrvty2f2Environment_sldd_ * rtP__PlntVehMass2f2PassVeh_sldd_ * ( rtP__PlntVehCGHgtAxl2f2PassVeh_sldd_ + rtP__PlntWhlLdRadiusRear2f2PassVeh_sldd_ ) * njz0210ca5 . P_66 + rtP__PlntVehDstCGFrntAxl2f2PassVeh_sldd_ * rtP__PlntVehMass2f2PassVeh_sldd_ * rtP__EnvGrvty2f2Environment_sldd_ ) / ( rtP__PlntVehDstCGFrntAxl2f2PassVeh_sldd_ + rtP__PlntVehDstCGRearAxl2f2PassVeh_sldd_ ) * rtP__PlntWhlLdRadiusRear2f2PassVeh_sldd_ * njz0210ca5 . P_67 * njz0210ca5 . P_68 * njz0210ca5 . P_69 ; } for ( i = 0 ; i < 201 ; i ++ ) { kstt2f1lxm = l510blem21 [ i ] ; if ( kstt2f1lxm > cyzhwl13yu ) { gnci5q4bna [ i ] = cyzhwl13yu ; } else if ( kstt2f1lxm < cppppprauj ) { gnci5q4bna [ i ] = cppppprauj ; } else { gnci5q4bna [ i ] = kstt2f1lxm ; } } cyzhwl13yu = njz0210ca5 . P_120 * k4m51nlsgp [ 1 ] ; cppppprauj = k4m51nlsgp [ 1 ] ; for ( i = 0 ; i < 201 ; i ++ ) { kstt2f1lxm = gnci5q4bna [ i ] ; e03mybaijr = ( kstt2f1lxm < cyzhwl13yu ) ; heizkzed50 [ i ] = e03mybaijr ; if ( kstt2f1lxm > cppppprauj ) { localB -> iiyddlbchw [ i ] = cppppprauj ; } else if ( e03mybaijr ) { localB -> iiyddlbchw [ i ] = cyzhwl13yu ; } else { localB -> iiyddlbchw [ i ] = kstt2f1lxm ; } } cyzhwl13yu = 1.0 / rtP__PlntEMWhlGearRatioRL2f2Drivetrain_sldd_ ; for ( i = 0 ; i < 201 ; i ++ ) { if ( localDW -> bkeddeqpbw [ i ] * l0n4e35gs4 >= njz0210ca5 . P_116 ) { cppppprauj = njz0210ca5 . P_113 ; } else { cppppprauj = njz0210ca5 . P_115 ; } if ( ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ < 0.0 ) && ( cppppprauj > muDoubleScalarFloor ( cppppprauj ) ) ) { cppppprauj = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , cppppprauj ) ; } else { cppppprauj = muDoubleScalarPower ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , cppppprauj ) ; } a0rtvf0lak = njz0210ca5 . P_121 * localB -> iiyddlbchw [ i ] * cyzhwl13yu * ( 1.0 / cppppprauj ) ; localB -> pfotcoa1by [ i ] = a0rtvf0lak ; l510blem21 [ i ] = l0n4e35gs4 * a0rtvf0lak ; mq5rveqe55 [ i ] = muDoubleScalarAbs ( localB -> pfotcoa1by [ i ] ) ; } bpIndices_p [ 0U ] = plook_bincpa ( muDoubleScalarAbs ( tmp_m [ 1 ] ) , rtP__PlntEM3SpdEff2f2ElectricMachine3_sldd_ , 13U , & cyzhwl13yu , & localDW -> buyauevq5n ) ; fractions [ 0U ] = cyzhwl13yu ; for ( i = 0 ; i < 201 ; i ++ ) { bpIndices_p [ 1U ] = plook_bincpa ( mq5rveqe55 [ i ] , rtP__PlntEM3TrqEff2f2ElectricMachine3_sldd_ , 10U , & cyzhwl13yu , & localDW -> cdnjjogkeu [ i ] ) ; fractions [ 1U ] = cyzhwl13yu ; mq5rveqe55 [ i ] = intrp2d_la_pw ( bpIndices_p , fractions , rtP__PlntEM3EffTbl2f2ElectricMachine3_sldd_ , 14U , njz0210ca5 . P_189 ) ; } if ( * nlrfbnbw4m > njz0210ca5 . P_127 ) { cyzhwl13yu = njz0210ca5 . P_127 ; } else if ( * nlrfbnbw4m < njz0210ca5 . P_128 ) { cyzhwl13yu = njz0210ca5 . P_128 ; } else { cyzhwl13yu = * nlrfbnbw4m ; } for ( i = 0 ; i < 201 ; i ++ ) { a0rtvf0lak = njz0210ca5 . P_122 * mq5rveqe55 [ i ] ; kstt2f1lxm = l510blem21 [ i ] ; if ( kstt2f1lxm >= njz0210ca5 . P_125 ) { cppppprauj = njz0210ca5 . P_123 ; } else { cppppprauj = njz0210ca5 . P_124 ; } if ( ( a0rtvf0lak < 0.0 ) && ( cppppprauj > muDoubleScalarFloor ( cppppprauj ) ) ) { a0rtvf0lak = - muDoubleScalarPower ( - a0rtvf0lak , cppppprauj ) ; } else { a0rtvf0lak = muDoubleScalarPower ( a0rtvf0lak , cppppprauj ) ; } mq5rveqe55 [ i ] = a0rtvf0lak ; a0rtvf0lak = kstt2f1lxm * a0rtvf0lak * njz0210ca5 . P_126 + njz0210ca5 . P_112 * k3nibq2osj [ i ] ; k3nibq2osj [ i ] = a0rtvf0lak ; l510blem21 [ i ] = a0rtvf0lak / cyzhwl13yu ; } if ( ( * nlrfbnbw4m >= - njz0210ca5 . P_39 ) && ( * nlrfbnbw4m <= njz0210ca5 . P_39 ) ) { if ( * nlrfbnbw4m >= njz0210ca5 . P_57 ) { cppppprauj = njz0210ca5 . P_155 ; } else { cppppprauj = localB -> a0wmwsydze ; } cyzhwl13yu = 0.02 / ( 3.0 - muDoubleScalarPower ( * nlrfbnbw4m / 0.01 , 2.0 ) ) * cppppprauj ; } else { cyzhwl13yu = * nlrfbnbw4m ; } cyzhwl13yu = 1.0 / cyzhwl13yu * n3auok1rpo ; e03mybaijr = ( ha5otmiloz >= njz0210ca5 . P_75 ) ; cppppprauj = k4m51nlsgp [ 0 ] ; for ( i = 0 ; i < 201 ; i ++ ) { kstt2f1lxm = l510blem21 [ i ] ; cj5m4xyger = ( kstt2f1lxm > kffmmp0yxb ) ; ar0yintt11 [ i ] = cj5m4xyger ; n5dfgdzrsl_tmp_p = ( kstt2f1lxm < cyzhwl13yu ) ; n5dfgdzrsl_tmp [ i ] = n5dfgdzrsl_tmp_p ; if ( cj5m4xyger ) { mq5rveqe55 [ i ] = kffmmp0yxb ; } else if ( n5dfgdzrsl_tmp_p ) { mq5rveqe55 [ i ] = cyzhwl13yu ; } else { mq5rveqe55 [ i ] = kstt2f1lxm ; } n5rlzqhkys = eq1kb23pnb [ i ] ; g41n1x0lvn [ i ] = ( ( cppppprauj < n5rlzqhkys ) || g41n1x0lvn [ i ] || ( ( n5rlzqhkys < njz0210ca5 . P_74 ) && e03mybaijr ) ) ; } e03mybaijr = ( ha5otmiloz >= njz0210ca5 . P_77 ) ; cppppprauj = k4m51nlsgp [ 1 ] ; for ( i = 0 ; i < 201 ; i ++ ) { kstt2f1lxm = gnci5q4bna [ i ] ; heizkzed50 [ i ] = ( ( cppppprauj < kstt2f1lxm ) || heizkzed50 [ i ] || ( ( kstt2f1lxm < njz0210ca5 . P_76 ) && e03mybaijr ) ) ; a0rtvf0lak = k3nibq2osj [ i ] ; ar0yintt11 [ i ] = ( ar0yintt11 [ i ] || n5dfgdzrsl_tmp [ i ] || ( a0rtvf0lak > kzhbx0udjv ) || ( a0rtvf0lak < n3auok1rpo ) ) ; } n3auok1rpo = 1.0 / ( ( rtP__PlntWhlLdRadiusFrnt2f2PassVeh_sldd_ + rtP__PlntWhlLdRadiusRear2f2PassVeh_sldd_ ) / 2.0 ) ; kzhbx0udjv = n3auok1rpo * * abdrusdwgj ; if ( kzhbx0udjv > njz0210ca5 . P_130 ) { kzhbx0udjv = njz0210ca5 . P_130 ; } else if ( kzhbx0udjv < njz0210ca5 . P_131 ) { kzhbx0udjv = njz0210ca5 . P_131 ; } for ( i = 0 ; i <= 198 ; i += 2 ) { tmp_j = _mm_loadu_pd ( & localB -> hifwcmswrk [ i ] ) ; tmp_g = _mm_loadu_pd ( & localB -> iiyddlbchw [ i ] ) ; _mm_storeu_pd ( & tmp_p [ 0 ] , _mm_mul_pd ( _mm_sub_pd ( _mm_set1_pd ( ha5otmiloz ) , _mm_add_pd ( tmp_j , tmp_g ) ) , _mm_set1_pd ( kzhbx0udjv ) ) ) ; tmp [ 0 ] = muDoubleScalarAbs ( tmp_p [ 0 ] ) ; tmp [ 1 ] = muDoubleScalarAbs ( tmp_p [ 1 ] ) ; tmp_j = _mm_loadu_pd ( & tmp [ 0 ] ) ; _mm_storeu_pd ( & eq1kb23pnb [ i ] , _mm_mul_pd ( _mm_mul_pd ( tmp_j , _mm_set1_pd ( njz0210ca5 . P_132 ) ) , _mm_set1_pd ( njz0210ca5 . P_133 ) ) ) ; } for ( i = 200 ; i < 201 ; i ++ ) { eq1kb23pnb [ i ] = muDoubleScalarAbs ( ( ha5otmiloz - ( localB -> hifwcmswrk [ i ] + localB -> iiyddlbchw [ i ] ) ) * kzhbx0udjv ) * njz0210ca5 . P_132 * njz0210ca5 . P_133 ; } if ( * abdrusdwgj > njz0210ca5 . P_136 ) { cppppprauj = * abdrusdwgj - njz0210ca5 . P_136 ; } else if ( * abdrusdwgj >= njz0210ca5 . P_135 ) { cppppprauj = 0.0 ; } else { cppppprauj = * abdrusdwgj - njz0210ca5 . P_135 ; } kzhbx0udjv = n3auok1rpo * cppppprauj ; if ( ha5otmiloz >= njz0210ca5 . P_139 ) { cppppprauj = localDW -> jxlucfehp1 ; } else { cppppprauj = localDW -> knprixuhqy ; } n3auok1rpo = kzhbx0udjv * cppppprauj ; for ( i = 0 ; i < 201 ; i ++ ) { if ( ha5otmiloz >= njz0210ca5 . P_134 ) { cppppprauj = localB -> hifwcmswrk [ i ] ; } else { cppppprauj = localB -> iiyddlbchw [ i ] ; } kstt2f1lxm = cppppprauj * kzhbx0udjv - n3auok1rpo ; kstt2f1lxm *= kstt2f1lxm ; l510blem21 [ i ] = muDoubleScalarSqrt ( kstt2f1lxm ) ; } ha5otmiloz = look1_pbinlcapw ( * ou4mx0rbp5 , njz0210ca5 . P_142 , njz0210ca5 . P_141 , & localDW -> piqmu5hx3l , 2U ) ; e03mybaijr = true ; i = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( i < 201 ) ) { if ( ( ! g41n1x0lvn [ i ] ) || ( ! heizkzed50 [ i ] ) || ( ! ar0yintt11 [ i ] ) ) { e03mybaijr = false ; exitg1 = true ; } else { i ++ ; } } if ( e03mybaijr ) { for ( i = 0 ; i < 201 ; i ++ ) { if ( g41n1x0lvn [ i ] ) { kidx = njz0210ca5 . P_190 ; } else { kidx = 0 ; } if ( heizkzed50 [ i ] ) { tmp_e = njz0210ca5 . P_191 ; } else { tmp_e = 0 ; } if ( ar0yintt11 [ i ] ) { tmp_i = njz0210ca5 . P_187 ; } else { tmp_i = 0U ; } gnci5q4bna [ i ] = ( ( ( real_T ) ( ( ( ( uint32_T ) kidx << 7 ) + ( ( uint32_T ) tmp_e << 7 ) ) + tmp_i ) * 0.00390625 + * nlrfbnbw4m * mq5rveqe55 [ i ] * njz0210ca5 . P_129 ) + eq1kb23pnb [ i ] ) + njz0210ca5 . P_140 * l510blem21 [ i ] * ha5otmiloz ; } minimum_OHNoIZs5 ( gnci5q4bna , & kzhbx0udjv , & i ) ; ha5otmiloz = i ; } else { for ( i = 0 ; i < 201 ; i ++ ) { if ( g41n1x0lvn [ i ] ) { kidx = njz0210ca5 . P_190 ; } else { kidx = 0 ; } if ( heizkzed50 [ i ] ) { tmp_e = njz0210ca5 . P_191 ; } else { tmp_e = 0 ; } if ( ar0yintt11 [ i ] ) { tmp_i = njz0210ca5 . P_187 ; } else { tmp_i = 0U ; } gnci5q4bna [ i ] = ( ( ( real_T ) ( ( ( ( uint32_T ) kidx << 7 ) + ( ( uint32_T ) tmp_e << 7 ) ) + tmp_i ) * 0.00390625 + * nlrfbnbw4m * mq5rveqe55 [ i ] * njz0210ca5 . P_129 ) + eq1kb23pnb [ i ] ) + njz0210ca5 . P_140 * l510blem21 [ i ] * ha5otmiloz ; } minimum_OHNoIZs5 ( gnci5q4bna , & kzhbx0udjv , & i ) ; ha5otmiloz = i ; } i = ( int32_T ) ha5otmiloz - 1 ; localB -> a4s2nojs0h = localB -> hifwcmswrk [ i ] ; localB -> aalmyye01r = localB -> iiyddlbchw [ i ] ; kzhbx0udjv = localB -> a4s2nojs0h + localB -> aalmyye01r ; if ( kzhbx0udjv > njz0210ca5 . P_143 ) { kzhbx0udjv = njz0210ca5 . P_143 ; } else if ( kzhbx0udjv < njz0210ca5 . P_144 ) { kzhbx0udjv = njz0210ca5 . P_144 ; } kzhbx0udjv += gwgcc1xzjk ; if ( kzhbx0udjv > njz0210ca5 . P_145 ) { kzhbx0udjv = njz0210ca5 . P_145 ; } else if ( kzhbx0udjv < njz0210ca5 . P_146 ) { kzhbx0udjv = njz0210ca5 . P_146 ; } ha5otmiloz = kzhbx0udjv / ( gjhipwfmba_tmp * 4.0 ) * ( 1.0 / rtP__PlntBrkPrsFctr2f2PassVeh_sldd_ ) ; if ( ha5otmiloz > njz0210ca5 . P_147 ) { ha5otmiloz = njz0210ca5 . P_147 ; } else if ( ha5otmiloz < njz0210ca5 . P_148 ) { ha5otmiloz = njz0210ca5 . P_148 ; } g0tgkqdgu5 [ 0 ] = ha5otmiloz ; g0tgkqdgu5 [ 1 ] = ha5otmiloz ; g0tgkqdgu5 [ 2 ] = ha5otmiloz ; g0tgkqdgu5 [ 3 ] = ha5otmiloz ; if ( localDW -> hyfypdejrs * tmp_m [ 0 ] >= njz0210ca5 . P_150 ) { a0rtvf0lak = njz0210ca5 . P_53 ; } else { a0rtvf0lak = njz0210ca5 . P_54 ; } if ( ( rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ < 0.0 ) && ( a0rtvf0lak > muDoubleScalarFloor ( a0rtvf0lak ) ) ) { cppppprauj = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ , a0rtvf0lak ) ; } else { cppppprauj = muDoubleScalarPower ( rtP__PlntEMWhlGearEffFL2f2Drivetrain_sldd_ , a0rtvf0lak ) ; } localB -> c1fcf4xd3b = 1.0 / rtP__PlntEMWhlGearRatioFL2f2Drivetrain_sldd_ * ( njz0210ca5 . P_151 * localB -> a4s2nojs0h ) * ( 1.0 / cppppprauj ) ; jhdwllabba [ 0 ] = localB -> c1fcf4xd3b ; jhdwllabba [ 1 ] = localB -> c1fcf4xd3b ; if ( localDW -> i1rb5p2wdu * tmp_m [ 1 ] >= njz0210ca5 . P_153 ) { a0rtvf0lak = njz0210ca5 . P_55 ; } else { a0rtvf0lak = njz0210ca5 . P_56 ; } if ( ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ < 0.0 ) && ( a0rtvf0lak > muDoubleScalarFloor ( a0rtvf0lak ) ) ) { cppppprauj = - muDoubleScalarPower ( - rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , a0rtvf0lak ) ; } else { cppppprauj = muDoubleScalarPower ( rtP__PlntEMWhlGearEffRL2f2Drivetrain_sldd_ , a0rtvf0lak ) ; } localB -> jwymxcmvfu = 1.0 / rtP__PlntEMWhlGearRatioRL2f2Drivetrain_sldd_ * ( njz0210ca5 . P_154 * localB -> aalmyye01r ) * ( 1.0 / cppppprauj ) ; jhdwllabba [ 2 ] = localB -> jwymxcmvfu ; jhdwllabba [ 3 ] = localB -> jwymxcmvfu ; { if ( tid == 0 ) { if ( localDW -> l4ltxt5zx1 . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> l4ltxt5zx1 . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & jhdwllabba [ 0 ] + 0 ) ; } } } a0rtvf0lak = localDW -> lcjh3yhjfv [ localDW -> o4ablo3jr0 ] ; if ( njz0210ca5 . P_192 == 1 ) { kykyroezb3 [ 0 ] = a0rtvf0lak - * hqcf5g33ch ; } else { kykyroezb3 [ 0 ] = - * hqcf5g33ch ; } kykyroezb3 [ 1 ] = - m1uk1i0jhi [ 2 ] ; { if ( tid == 0 ) { if ( localDW -> iow1zb41nn . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> iow1zb41nn . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & kykyroezb3 [ 0 ] + 0 ) ; } } } gjhipwfmba_tmp = e1vxnu1wnp [ 0 ] + e1vxnu1wnp [ 1 ] ; a0rtvf0lak = gjhipwfmba_tmp * njz0210ca5 . P_165 ; e03mybaijr = ( ( * abdrusdwgj > njz0210ca5 . P_36 ) && ( muDoubleScalarAbs ( * oakxzdmw2z ) > njz0210ca5 . P_35 ) && ( ( ( ( mhyfll4bj5_idx_0 + mhyfll4bj5_idx_1 ) + mhyfll4bj5_idx_2 ) + mhyfll4bj5_idx_3 ) * njz0210ca5 . P_166 < njz0210ca5 . P_34 ) ) ; kzhbx0udjv = localDW -> aqogycpvqd [ localDW -> pbom5jpcjj ] ; if ( njz0210ca5 . P_193 == 1 ) { k4m51nlsgp [ 0 ] = kzhbx0udjv - * hqcf5g33ch ; } else { k4m51nlsgp [ 0 ] = - * hqcf5g33ch ; } if ( njz0210ca5 . P_194 == 1 ) { k4m51nlsgp [ 1 ] = - m1uk1i0jhi [ 2 ] ; } else { k4m51nlsgp [ 1 ] = - * ob3iqse2rj ; } mhyfll4bj5_idx_0 = kq5dbo0rgg [ 0 ] ; mhyfll4bj5_idx_0 += kq5dbo0rgg [ 1 ] ; ha5otmiloz = muDoubleScalarAbs ( look1_binlcapw ( muDoubleScalarAbs ( njz0210ca5 . P_169 * mhyfll4bj5_idx_0 ) , rtP__PlntEM1Spd2f2ElectricMachine1_sldd_ , rtP__PlntEM1Trq2f2ElectricMachine1_sldd_ , 13U ) ) ; mhyfll4bj5_idx_1 = kq5dbo0rgg [ 2 ] ; mhyfll4bj5_idx_1 += kq5dbo0rgg [ 3 ] ; kzhbx0udjv = muDoubleScalarAbs ( look1_binlcapw ( muDoubleScalarAbs ( njz0210ca5 . P_170 * mhyfll4bj5_idx_1 ) , rtP__PlntEM3Spd2f2ElectricMachine3_sldd_ , rtP__PlntEM3Trq2f2ElectricMachine3_sldd_ , 13U ) ) ; tmp_j = _mm_set_pd ( jhdwllabba [ 2 ] , jhdwllabba [ 0 ] ) ; _mm_storeu_pd ( & tmp_m [ 0 ] , _mm_add_pd ( tmp_j , tmp_j ) ) ; u_max [ 0 ] = 2.0 * ha5otmiloz ; u_max [ 1 ] = 2.0 * kzhbx0udjv ; kidx = - 1 ; gwgcc1xzjk = u_max [ 0 ] ; n3auok1rpo = u_max [ 1 ] ; for ( i = 0 ; i < 3 ; i ++ ) { K [ kidx + 1 ] = gwgcc1xzjk ; K [ kidx + 2 ] = n3auok1rpo ; kidx += 2 ; } u_max [ 0 ] = - u_max [ 0 ] ; u_max [ 1 ] = - u_max [ 1 ] ; kidx = - 1 ; gwgcc1xzjk = u_max [ 0 ] ; n3auok1rpo = u_max [ 1 ] ; for ( i = 0 ; i < 3 ; i ++ ) { b_K [ kidx + 1 ] = gwgcc1xzjk ; b_K [ kidx + 2 ] = n3auok1rpo ; kidx += 2 ; } mhyfll4bj5_idx_1 = muDoubleScalarAbs ( ( 1.7 / ( * abdrusdwgj * * abdrusdwgj ) + 0.026419802867383515 ) * 7.063200000000001 ) ; mhyfll4bj5_idx_0 = * abdrusdwgj * a0rtvf0lak / 2.79 ; n3auok1rpo = muDoubleScalarAbs ( 6.0037200000000013 / * abdrusdwgj ) ; if ( muDoubleScalarAbs ( mhyfll4bj5_idx_0 ) > n3auok1rpo ) { mhyfll4bj5_idx_0 = n3auok1rpo * muDoubleScalarSign ( a0rtvf0lak ) ; } if ( ( real_T ) e03mybaijr > 0.5 ) { localB -> kk5g3qa1ab [ 0 ] = localDW -> fy5ps0vnmo [ 2 ] ; localB -> kk5g3qa1ab [ 1 ] = localDW -> fy5ps0vnmo [ 3 ] ; localB -> kk5g3qa1ab [ 2 ] = localDW -> fy5ps0vnmo [ 4 ] ; localB -> kk5g3qa1ab [ 3 ] = localDW -> fy5ps0vnmo [ 5 ] ; localB -> kk5g3qa1ab [ 4 ] = localDW -> fy5ps0vnmo [ 4 ] ; localB -> kk5g3qa1ab [ 5 ] = localDW -> fy5ps0vnmo [ 5 ] ; memcpy ( & localB -> kk5g3qa1ab [ 6 ] , & localDW -> fy5ps0vnmo [ 8 ] , 18U * sizeof ( real_T ) ) ; localB -> kk5g3qa1ab [ 24 ] = localDW -> fy5ps0vnmo [ 24 ] ; localB -> kk5g3qa1ab [ 25 ] = localDW -> fy5ps0vnmo [ 25 ] ; expl_temp_p . EMRearTrq = tmp_m [ 1 ] ; expl_temp_p . EMFrntTrq = tmp_m [ 0 ] ; expl_temp_p . Acc [ 0 ] = jyoqfmrpak [ 0 ] ; expl_temp_p . Acc [ 1 ] = jyoqfmrpak [ 1 ] ; expl_temp_p . Acc [ 2 ] = jyoqfmrpak [ 2 ] ; expl_temp_p . EMTrqMaxRear = kzhbx0udjv ; expl_temp_p . EMTrqMaxFrnt = ha5otmiloz ; expl_temp_p . delta_Frnt = a0rtvf0lak ; expl_temp_p . Vx = * abdrusdwgj ; expl_temp_p . PrevEMTrqCmdFinals [ 0 ] = localDW -> pophr5lzve [ 0 ] ; expl_temp_p . PrevEMTrqCmdFinals [ 1 ] = localDW -> pophr5lzve [ 1 ] ; expl_temp_p . PrevEMTrqCmdFinals [ 2 ] = localDW -> pophr5lzve [ 2 ] ; expl_temp_p . PrevEMTrqCmdFinals [ 3 ] = localDW -> pophr5lzve [ 3 ] ; expl_temp_p . xk [ 0 ] = k4m51nlsgp [ 0 ] ; expl_temp_p . xk [ 1 ] = k4m51nlsgp [ 1 ] ; for ( i = 0 ; i < 6 ; i ++ ) { b_K_p [ i ] = b_K [ i ] ; } for ( i = 0 ; i < 20 ; i ++ ) { b_K_p [ i + 6 ] = ( rtMinusInf ) ; } for ( i = 0 ; i < 6 ; i ++ ) { K_p [ i ] = K [ i ] ; } for ( i = 0 ; i < 20 ; i ++ ) { K_p [ i + 6 ] = ( rtInf ) ; } e0ysvsme4f ( k4m51nlsgp , localDW -> pophr5lzve , tmp_m [ 0 ] , tmp_m [ 1 ] , mhyfll4bj5_idx_0 , localB -> kk5g3qa1ab , b_K_p , K_p , & expl_temp_p , & kffmmp0yxb , & ha5otmiloz , & n3auok1rpo , & gwgcc1xzjk , expl_temp , & cyzhwl13yu , & cppppprauj , & kzhbx0udjv , & mhyfll4bj5_idx_2 , localB ) ; kffmmp0yxb = 0.0 ; tmp_j = _mm_set_pd ( 1.0 , - 1.0 ) ; tmp_g = _mm_set1_pd ( 0.5 ) ; _mm_storeu_pd ( & cmdd4wxsgc [ 0 ] , _mm_mul_pd ( _mm_add_pd ( _mm_set1_pd ( tmp_m [ 0 ] ) , _mm_mul_pd ( _mm_set1_pd ( localB -> kk5g3qa1ab [ 0 ] ) , tmp_j ) ) , tmp_g ) ) ; _mm_storeu_pd ( & cmdd4wxsgc [ 2 ] , _mm_mul_pd ( _mm_add_pd ( _mm_set1_pd ( tmp_m [ 1 ] ) , _mm_mul_pd ( _mm_set1_pd ( localB -> kk5g3qa1ab [ 1 ] ) , tmp_j ) ) , tmp_g ) ) ; fs3qapxw1l ( k4m51nlsgp , & localB -> kk5g3qa1ab [ 0 ] , tmp_m [ 0 ] , * abdrusdwgj , a0rtvf0lak , jyoqfmrpak , localB -> mvqmwjobhl ) ; tmp_j = _mm_set1_pd ( 0.01 ) ; tmp_g = _mm_add_pd ( _mm_mul_pd ( tmp_j , _mm_loadu_pd ( & localB -> mvqmwjobhl [ 0 ] ) ) , _mm_loadu_pd ( & k4m51nlsgp [ 0 ] ) ) ; _mm_storeu_pd ( & u_max [ 0 ] , tmp_g ) ; fs3qapxw1l ( u_max , & localB -> kk5g3qa1ab [ 0 ] , tmp_m [ 0 ] , * abdrusdwgj , a0rtvf0lak , jyoqfmrpak , tmp_p ) ; tmp_j = _mm_add_pd ( _mm_div_pd ( _mm_mul_pd ( _mm_add_pd ( _mm_loadu_pd ( & localB -> mvqmwjobhl [ 0 ] ) , _mm_loadu_pd ( & tmp_p [ 0 ] ) ) , tmp_j ) , _mm_set1_pd ( 2.0 ) ) , _mm_loadu_pd ( & k4m51nlsgp [ 0 ] ) ) ; _mm_storeu_pd ( & localB -> mvqmwjobhl [ 0 ] , tmp_j ) ; kqfgedufzz ( localB -> kk5g3qa1ab , k4m51nlsgp , localDW -> pophr5lzve , tmp_m [ 0 ] , tmp_m [ 1 ] , mhyfll4bj5_idx_0 , u_max ) ; } else { cmdd4wxsgc [ 0 ] = jhdwllabba [ 0 ] ; cmdd4wxsgc [ 1 ] = jhdwllabba [ 1 ] ; cmdd4wxsgc [ 2 ] = jhdwllabba [ 2 ] ; cmdd4wxsgc [ 3 ] = jhdwllabba [ 3 ] ; kidx = - 1 ; for ( i = 0 ; i < 3 ; i ++ ) { K [ kidx + 1 ] = 0.0 ; K [ kidx + 2 ] = 0.0 ; kidx += 2 ; } kidx = - 1 ; cppppprauj = k4m51nlsgp [ 0 ] ; kzhbx0udjv = k4m51nlsgp [ 1 ] ; for ( i = 0 ; i < 10 ; i ++ ) { c_K [ kidx + 1 ] = cppppprauj ; c_K [ kidx + 2 ] = kzhbx0udjv ; kidx += 2 ; } for ( i = 0 ; i < 6 ; i ++ ) { localB -> kk5g3qa1ab [ i ] = K [ i ] ; } memcpy ( & localB -> kk5g3qa1ab [ 6 ] , & c_K [ 0 ] , 20U * sizeof ( real_T ) ) ; localB -> mvqmwjobhl [ 0 ] = k4m51nlsgp [ 0 ] ; u_max [ 0 ] = 0.0 ; localB -> mvqmwjobhl [ 1 ] = k4m51nlsgp [ 1 ] ; u_max [ 1 ] = 0.0 ; ha5otmiloz = 0.0 ; kffmmp0yxb = 0.0 ; kzhbx0udjv = 0.0 ; n3auok1rpo = 0.0 ; gwgcc1xzjk = 0.0 ; } { if ( tid == 0 ) { if ( localDW -> depxbtcebe . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> depxbtcebe . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & cmdd4wxsgc [ 0 ] + 0 ) ; } } } kok5t41cri_p = & localDW -> fyczfqu5d1 [ 0 ] ; { if ( tid == 0 ) { if ( localDW -> dkrgzmmphu . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> dkrgzmmphu . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & kok5t41cri_p [ 0 ] + 0 ) ; } } } lgrpva0mqt = gjhipwfmba_tmp * njz0210ca5 . P_173 ; cppppprauj = njz0210ca5 . P_174 * elbvogf2ze ; mhyfll4bj5_idx_2 = njz0210ca5 . P_175 * elbvogf2ze ; mhyfll4bj5_idx_3 = cmdd4wxsgc [ 0 ] ; a0rtvf0lak = cmdd4wxsgc [ 0 ] - localDW -> p1ynaxw2kn [ 0 ] ; if ( a0rtvf0lak > cppppprauj ) { mhyfll4bj5_idx_3 = localDW -> p1ynaxw2kn [ 0 ] + cppppprauj ; } else if ( a0rtvf0lak < mhyfll4bj5_idx_2 ) { mhyfll4bj5_idx_3 = localDW -> p1ynaxw2kn [ 0 ] + mhyfll4bj5_idx_2 ; } cmdd4wxsgc [ 0 ] = mhyfll4bj5_idx_3 ; localDW -> p1ynaxw2kn [ 0 ] = mhyfll4bj5_idx_3 ; mhyfll4bj5_idx_3 = cmdd4wxsgc [ 1 ] ; a0rtvf0lak = cmdd4wxsgc [ 1 ] - localDW -> p1ynaxw2kn [ 1 ] ; if ( a0rtvf0lak > cppppprauj ) { mhyfll4bj5_idx_3 = localDW -> p1ynaxw2kn [ 1 ] + cppppprauj ; } else if ( a0rtvf0lak < mhyfll4bj5_idx_2 ) { mhyfll4bj5_idx_3 = localDW -> p1ynaxw2kn [ 1 ] + mhyfll4bj5_idx_2 ; } cmdd4wxsgc [ 1 ] = mhyfll4bj5_idx_3 ; localDW -> p1ynaxw2kn [ 1 ] = mhyfll4bj5_idx_3 ; mhyfll4bj5_idx_3 = cmdd4wxsgc [ 2 ] ; a0rtvf0lak = cmdd4wxsgc [ 2 ] - localDW -> p1ynaxw2kn [ 2 ] ; if ( a0rtvf0lak > cppppprauj ) { mhyfll4bj5_idx_3 = localDW -> p1ynaxw2kn [ 2 ] + cppppprauj ; } else if ( a0rtvf0lak < mhyfll4bj5_idx_2 ) { mhyfll4bj5_idx_3 = localDW -> p1ynaxw2kn [ 2 ] + mhyfll4bj5_idx_2 ; } cmdd4wxsgc [ 2 ] = mhyfll4bj5_idx_3 ; localDW -> p1ynaxw2kn [ 2 ] = mhyfll4bj5_idx_3 ; mhyfll4bj5_idx_3 = cmdd4wxsgc [ 3 ] ; a0rtvf0lak = cmdd4wxsgc [ 3 ] - localDW -> p1ynaxw2kn [ 3 ] ; if ( a0rtvf0lak > cppppprauj ) { mhyfll4bj5_idx_3 = localDW -> p1ynaxw2kn [ 3 ] + cppppprauj ; } else if ( a0rtvf0lak < mhyfll4bj5_idx_2 ) { mhyfll4bj5_idx_3 = localDW -> p1ynaxw2kn [ 3 ] + mhyfll4bj5_idx_2 ; } cmdd4wxsgc [ 3 ] = mhyfll4bj5_idx_3 ; localDW -> p1ynaxw2kn [ 3 ] = mhyfll4bj5_idx_3 ; hlsu2gteae = - jyoqfmrpak [ 1 ] ; localB -> nmimg104an [ 0 ] = kykyroezb3 [ 0 ] ; localB -> nmimg104an [ 1 ] = kykyroezb3 [ 1 ] ; localB -> nmimg104an [ 2 ] = * abdrusdwgj ; localB -> nmimg104an [ 3 ] = lgrpva0mqt ; localB -> nmimg104an [ 4 ] = jyoqfmrpak [ 0 ] ; localB -> nmimg104an [ 5 ] = hlsu2gteae ; localB -> nmimg104an [ 6 ] = njz0210ca5 . P_186 ; localB -> nmimg104an [ 7 ] = cmdd4wxsgc [ 0 ] ; localB -> nmimg104an [ 8 ] = cmdd4wxsgc [ 1 ] ; localB -> nmimg104an [ 9 ] = cmdd4wxsgc [ 2 ] ; localB -> nmimg104an [ 10 ] = cmdd4wxsgc [ 3 ] ; mhyfll4bj5_idx_2 = ( ( ( g0tgkqdgu5 [ 0 ] + g0tgkqdgu5 [ 1 ] ) + g0tgkqdgu5 [ 2 ] ) + g0tgkqdgu5 [ 3 ] ) / localB -> o2qc0z2iec * rtP__CtrlBcuTrlrBrkGain2f2PassVeh_sldd_ ; ggfsdvp45d [ 0 ] = mhyfll4bj5_idx_2 ; ggfsdvp45d [ 1 ] = mhyfll4bj5_idx_2 ; ggfsdvp45d [ 2 ] = mhyfll4bj5_idx_2 ; ggfsdvp45d [ 3 ] = mhyfll4bj5_idx_2 ; ggfsdvp45d [ 4 ] = mhyfll4bj5_idx_2 ; ggfsdvp45d [ 5 ] = mhyfll4bj5_idx_2 ; { if ( tid == 0 ) { if ( localDW -> fv1ztkelof . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> fv1ztkelof . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & e03mybaijr + 0 ) ; } } } { if ( tid == 0 ) { if ( localDW -> itskgiqhz2 . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> itskgiqhz2 . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & mhyfll4bj5_idx_0 + 0 ) ; } } } { if ( tid == 0 ) { if ( localDW -> mlemipyadb . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> mlemipyadb . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & ha5otmiloz + 0 ) ; } } } { if ( tid == 0 ) { if ( localDW -> ezl2ntihdf . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> ezl2ntihdf . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & u_max [ 0 ] + 0 ) ; } } } { if ( tid == 0 ) { if ( localDW -> i1mtsusvml . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> i1mtsusvml . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & kffmmp0yxb + 0 ) ; } } } { if ( tid == 0 ) { if ( localDW -> cekiui3znc . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> cekiui3znc . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & kzhbx0udjv + 0 ) ; } } } { if ( tid == 0 ) { if ( localDW -> ol1dphwxf3 . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> ol1dphwxf3 . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & n3auok1rpo + 0 ) ; } } } { if ( tid == 0 ) { if ( localDW -> ms4bj3urgt . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> ms4bj3urgt . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & gwgcc1xzjk + 0 ) ; } } } { if ( tid == 0 ) { if ( localDW -> k3hp0ajooa . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> k3hp0ajooa . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & mhyfll4bj5_idx_1 + 0 ) ; } } } { if ( tid == 0 ) { if ( localDW -> gctb1llys1 . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> gctb1llys1 . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & k4m51nlsgp [ 0 ] + 0 ) ; } } } k4m51nlsgp [ 0 ] = localDW -> k3wtm0bzih [ 0 ] ; k4m51nlsgp [ 1 ] = localDW -> k3wtm0bzih [ 1 ] ; { if ( tid == 0 ) { if ( localDW -> dkrgzmmphuh . AQHandles && ssGetLogOutput ( obwppemxpt -> _mdlRefSfcnS ) ) { sdiWriteSignal ( localDW -> dkrgzmmphuh . AQHandles , rtmGetTaskTime ( obwppemxpt , 0 ) , ( char * ) & k4m51nlsgp [ 0 ] + 0 ) ; } } } * h1t2u5fil2 = njz0210ca5 . P_178 ; * j200csbdtq = njz0210ca5 . P_179 ; * jxlsupm5zm = njz0210ca5 . P_180 ; * fbgdfzguau = njz0210ca5 . P_181 ; ( void ) ( tid ) ; } void EvPowertrainController4EMTID1 ( fuctzs4sww * localDW ) { int_T tid = 1 ; real_T cbclsu4uir ; cbclsu4uir = muDoubleScalarSqrt ( njz0210ca5 . P_32 ) / 0.31622776601683794 * localDW -> pg2hyiwwhz ; localDW -> lcjh3yhjfv [ localDW -> o4ablo3jr0 == 0 ] = cbclsu4uir ; localDW -> o4ablo3jr0 = ( int8_T ) ( localDW -> o4ablo3jr0 == 0 ) ; cbclsu4uir = muDoubleScalarSqrt ( njz0210ca5 . P_33 ) / 0.31622776601683794 * localDW -> pepscbjqk4 ; localDW -> aqogycpvqd [ localDW -> pbom5jpcjj == 0 ] = cbclsu4uir ; localDW -> pbom5jpcjj = ( int8_T ) ( localDW -> pbom5jpcjj == 0 ) ; ( void ) ( tid ) ; } void EvPowertrainController4EMTID2 ( d4m2qnxaxx * localB ) { int_T tid = 2 ; localB -> a0wmwsydze = - njz0210ca5 . P_155 ; localB -> dghaupurkc = - njz0210ca5 . P_156 ; ( void ) ( tid ) ; } void eomqpqr0rkTID0 ( real_T cmdd4wxsgc [ 4 ] , d4m2qnxaxx * localB , fuctzs4sww * localDW ) { memcpy ( & localDW -> m2eudybppp [ 0 ] , & localB -> kfky3x1ct4 [ 0 ] , 201U * sizeof ( real_T ) ) ; memcpy ( & localDW -> fsvou2544p [ 0 ] , & localB -> iiyddlbchw [ 0 ] , 201U * sizeof ( real_T ) ) ; memcpy ( & localDW -> hheq0b5rgn [ 0 ] , & localB -> hifwcmswrk [ 0 ] , 201U * sizeof ( real_T ) ) ; memcpy ( & localDW -> bkeddeqpbw [ 0 ] , & localB -> pfotcoa1by [ 0 ] , 201U * sizeof ( real_T ) ) ; localDW -> jxlucfehp1 = localB -> a4s2nojs0h ; localDW -> knprixuhqy = localB -> aalmyye01r ; localDW -> hyfypdejrs = localB -> c1fcf4xd3b ; localDW -> i1rb5p2wdu = localB -> jwymxcmvfu ; localDW -> pophr5lzve [ 0 ] = cmdd4wxsgc [ 0 ] ; localDW -> pophr5lzve [ 1 ] = cmdd4wxsgc [ 1 ] ; localDW -> pophr5lzve [ 2 ] = cmdd4wxsgc [ 2 ] ; localDW -> pophr5lzve [ 3 ] = cmdd4wxsgc [ 3 ] ; memcpy ( & localDW -> fy5ps0vnmo [ 0 ] , & localB -> kk5g3qa1ab [ 0 ] , 26U * sizeof ( real_T ) ) ; memcpy ( & localDW -> fyczfqu5d1 [ 0 ] , & localB -> nmimg104an [ 0 ] , 11U * sizeof ( real_T ) ) ; localDW -> k3wtm0bzih [ 0 ] = localB -> mvqmwjobhl [ 0 ] ; localDW -> k3wtm0bzih [ 1 ] = localB -> mvqmwjobhl [ 1 ] ; } void eomqpqr0rkTID1 ( fuctzs4sww * localDW ) { localDW -> pg2hyiwwhz = rt_nrand_Upu32_Yd_f_pw_snf ( & localDW -> mwdg02ndpd ) * njz0210ca5 . P_183 + njz0210ca5 . P_182 ; localDW -> pepscbjqk4 = rt_nrand_Upu32_Yd_f_pw_snf ( & localDW -> jmxm2hc1kh ) * njz0210ca5 . P_185 + njz0210ca5 . P_184 ; } void pmaz4haa3k ( ghy3lg3t4k * const obwppemxpt , fuctzs4sww * localDW ) { if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> ivmrcbyxgt . AQHandles ) { sdiTerminateStreaming ( & localDW -> ivmrcbyxgt . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> l4ltxt5zx1 . AQHandles ) { sdiTerminateStreaming ( & localDW -> l4ltxt5zx1 . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> iow1zb41nn . AQHandles ) { sdiTerminateStreaming ( & localDW -> iow1zb41nn . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> depxbtcebe . AQHandles ) { sdiTerminateStreaming ( & localDW -> depxbtcebe . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> dkrgzmmphu . AQHandles ) { sdiTerminateStreaming ( & localDW -> dkrgzmmphu . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> fv1ztkelof . AQHandles ) { sdiTerminateStreaming ( & localDW -> fv1ztkelof . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> itskgiqhz2 . AQHandles ) { sdiTerminateStreaming ( & localDW -> itskgiqhz2 . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> mlemipyadb . AQHandles ) { sdiTerminateStreaming ( & localDW -> mlemipyadb . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> ezl2ntihdf . AQHandles ) { sdiTerminateStreaming ( & localDW -> ezl2ntihdf . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> i1mtsusvml . AQHandles ) { sdiTerminateStreaming ( & localDW -> i1mtsusvml . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> cekiui3znc . AQHandles ) { sdiTerminateStreaming ( & localDW -> cekiui3znc . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> ol1dphwxf3 . AQHandles ) { sdiTerminateStreaming ( & localDW -> ol1dphwxf3 . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> ms4bj3urgt . AQHandles ) { sdiTerminateStreaming ( & localDW -> ms4bj3urgt . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> k3hp0ajooa . AQHandles ) { sdiTerminateStreaming ( & localDW -> k3hp0ajooa . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> gctb1llys1 . AQHandles ) { sdiTerminateStreaming ( & localDW -> gctb1llys1 . AQHandles ) ; } } if ( ( ssGetSimMode ( obwppemxpt -> _mdlRefSfcnS ) != SS_SIMMODE_EXTERNAL ) && ( ( obwppemxpt -> _mdlRefSfcnS ) -> mdlInfo -> rtwgenMode != SS_RTWGEN_MODELREFERENCE_RTW_TARGET ) ) { if ( localDW -> dkrgzmmphuh . AQHandles ) { sdiTerminateStreaming ( & localDW -> dkrgzmmphuh . AQHandles ) ; } } } void c3safteidr ( ghy3lg3t4k * const obwppemxpt ) { if ( ! slIsRapidAcceleratorSimulating ( ) ) { slmrRunPluginEvent ( obwppemxpt -> _mdlRefSfcnS , "EvPowertrainController4EM" , "SIMSTATUS_TERMINATING_MODELREF_ACCEL_EVENT" ) ; } } void jtu2yp4mzt ( SimStruct * _mdlRefSfcnS , int_T mdlref_TID0 , int_T mdlref_TID1 , int_T mdlref_TID2 , ghy3lg3t4k * const obwppemxpt , d4m2qnxaxx * localB , fuctzs4sww * localDW , void * sysRanPtr , int contextTid , rtwCAPI_ModelMappingInfo * rt_ParentMMI , const char_T * rt_ChildPath , int_T rt_ChildMMIIdx , int_T rt_CSTATEIdx ) { ( void ) memset ( ( void * ) obwppemxpt , 0 , sizeof ( ghy3lg3t4k ) ) ; obwppemxpt -> Timing . mdlref_GlobalTID [ 0 ] = mdlref_TID0 ; obwppemxpt -> Timing . mdlref_GlobalTID [ 1 ] = mdlref_TID1 ; obwppemxpt -> Timing . mdlref_GlobalTID [ 2 ] = mdlref_TID2 ; obwppemxpt -> _mdlRefSfcnS = ( _mdlRefSfcnS ) ; if ( ! slIsRapidAcceleratorSimulating ( ) ) { slmrRunPluginEvent ( obwppemxpt -> _mdlRefSfcnS , "EvPowertrainController4EM" , "START_OF_SIM_MODEL_MODELREF_ACCEL_EVENT" ) ; } { int32_T i ; for ( i = 0 ; i < 11 ; i ++ ) { localB -> nmimg104an [ i ] = 0.0 ; } for ( i = 0 ; i < 26 ; i ++ ) { localB -> kk5g3qa1ab [ i ] = 0.0 ; } for ( i = 0 ; i < 201 ; i ++ ) { localB -> hifwcmswrk [ i ] = 0.0 ; } for ( i = 0 ; i < 201 ; i ++ ) { localB -> kfky3x1ct4 [ i ] = 0.0 ; } for ( i = 0 ; i < 201 ; i ++ ) { localB -> iiyddlbchw [ i ] = 0.0 ; } for ( i = 0 ; i < 201 ; i ++ ) { localB -> pfotcoa1by [ i ] = 0.0 ; } localB -> o2qc0z2iec = 0.0 ; localB -> mvqmwjobhl [ 0 ] = 0.0 ; localB -> mvqmwjobhl [ 1 ] = 0.0 ; localB -> a4s2nojs0h = 0.0 ; localB -> aalmyye01r = 0.0 ; localB -> c1fcf4xd3b = 0.0 ; localB -> jwymxcmvfu = 0.0 ; localB -> a0wmwsydze = 0.0 ; localB -> dghaupurkc = 0.0 ; } ( void ) memset ( ( void * ) localDW , 0 , sizeof ( fuctzs4sww ) ) ; localDW -> pophr5lzve [ 0 ] = 0.0 ; localDW -> pophr5lzve [ 1 ] = 0.0 ; localDW -> pophr5lzve [ 2 ] = 0.0 ; localDW -> pophr5lzve [ 3 ] = 0.0 ; { int32_T i ; for ( i = 0 ; i < 26 ; i ++ ) { localDW -> fy5ps0vnmo [ i ] = 0.0 ; } } { int32_T i ; for ( i = 0 ; i < 11 ; i ++ ) { localDW -> fyczfqu5d1 [ i ] = 0.0 ; } } localDW -> k3wtm0bzih [ 0 ] = 0.0 ; localDW -> k3wtm0bzih [ 1 ] = 0.0 ; { int32_T i ; for ( i = 0 ; i < 201 ; i ++ ) { localDW -> m2eudybppp [ i ] = 0.0 ; } } { int32_T i ; for ( i = 0 ; i < 201 ; i ++ ) { localDW -> fsvou2544p [ i ] = 0.0 ; } } { int32_T i ; for ( i = 0 ; i < 201 ; i ++ ) { localDW -> hheq0b5rgn [ i ] = 0.0 ; } } { int32_T i ; for ( i = 0 ; i < 201 ; i ++ ) { localDW -> bkeddeqpbw [ i ] = 0.0 ; } } localDW -> jxlucfehp1 = 0.0 ; localDW -> knprixuhqy = 0.0 ; localDW -> hyfypdejrs = 0.0 ; localDW -> i1rb5p2wdu = 0.0 ; localDW -> lcjh3yhjfv [ 0 ] = 0.0 ; localDW -> lcjh3yhjfv [ 1 ] = 0.0 ; localDW -> aqogycpvqd [ 0 ] = 0.0 ; localDW -> aqogycpvqd [ 1 ] = 0.0 ; localDW -> p1ynaxw2kn [ 0 ] = 0.0 ; localDW -> p1ynaxw2kn [ 1 ] = 0.0 ; localDW -> p1ynaxw2kn [ 2 ] = 0.0 ; localDW -> p1ynaxw2kn [ 3 ] = 0.0 ; localDW -> pg2hyiwwhz = 0.0 ; localDW -> pepscbjqk4 = 0.0 ; EvPowertrainController4EM_InitializeDataMapInfo ( obwppemxpt , localDW , sysRanPtr , contextTid ) ; if ( ( rt_ParentMMI != ( NULL ) ) && ( rt_ChildPath != ( NULL ) ) ) { rtwCAPI_SetChildMMI ( * rt_ParentMMI , rt_ChildMMIIdx , & ( obwppemxpt -> DataMapInfo . mmi ) ) ; rtwCAPI_SetPath ( obwppemxpt -> DataMapInfo . mmi , rt_ChildPath ) ; rtwCAPI_MMISetContStateStartIndex ( obwppemxpt -> DataMapInfo . mmi , rt_CSTATEIdx ) ; } } void mr_EvPowertrainController4EM_MdlInfoRegFcn ( SimStruct * mdlRefSfcnS , char_T * modelName , int_T * retVal ) { * retVal = 0 ; { boolean_T regSubmodelsMdlinfo = false ; ssGetRegSubmodelsMdlinfo ( mdlRefSfcnS , & regSubmodelsMdlinfo ) ; if ( regSubmodelsMdlinfo ) { } } * retVal = 0 ; ssRegModelRefMdlInfo ( mdlRefSfcnS , modelName , rtMdlInfo_EvPowertrainController4EM , 70 ) ; * retVal = 1 ; } static void mr_EvPowertrainController4EM_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_EvPowertrainController4EM_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_EvPowertrainController4EM_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_EvPowertrainController4EM_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_EvPowertrainController4EM_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_EvPowertrainController4EM_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_EvPowertrainController4EM_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_EvPowertrainController4EM_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_EvPowertrainController4EM_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_EvPowertrainController4EM_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_EvPowertrainController4EM_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_EvPowertrainController4EM_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_EvPowertrainController4EM_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_EvPowertrainController4EM_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_EvPowertrainController4EM_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_EvPowertrainController4EM_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_EvPowertrainController4EM_GetDWork ( const etgxjyp0hjh * mdlrefDW ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtb" , "rtdw" , "NULL->rtzce" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( mdlrefDW -> rtb ) , sizeof ( mdlrefDW -> rtb ) ) ; { static const char_T * rtdwDataFieldNames [ 30 ] = { "mdlrefDW->rtdw.pophr5lzve" , "mdlrefDW->rtdw.fy5ps0vnmo" , "mdlrefDW->rtdw.fyczfqu5d1" , "mdlrefDW->rtdw.k3wtm0bzih" , "mdlrefDW->rtdw.m2eudybppp" , "mdlrefDW->rtdw.fsvou2544p" , "mdlrefDW->rtdw.hheq0b5rgn" , "mdlrefDW->rtdw.bkeddeqpbw" , "mdlrefDW->rtdw.jxlucfehp1" , "mdlrefDW->rtdw.knprixuhqy" , "mdlrefDW->rtdw.hyfypdejrs" , "mdlrefDW->rtdw.i1rb5p2wdu" , "mdlrefDW->rtdw.lcjh3yhjfv" , "mdlrefDW->rtdw.aqogycpvqd" , "mdlrefDW->rtdw.p1ynaxw2kn" , "mdlrefDW->rtdw.pg2hyiwwhz" , "mdlrefDW->rtdw.pepscbjqk4" , "mdlrefDW->rtdw.mwdg02ndpd" , "mdlrefDW->rtdw.jmxm2hc1kh" , "mdlrefDW->rtdw.n0bkstmppv" , "mdlrefDW->rtdw.pgi1aok3cr" , "mdlrefDW->rtdw.g3a1sbd5cj" , "mdlrefDW->rtdw.gedptl3pzo" , "mdlrefDW->rtdw.buyauevq5n" , "mdlrefDW->rtdw.cdnjjogkeu" , "mdlrefDW->rtdw.piqmu5hx3l" , "mdlrefDW->rtdw.o4ablo3jr0" , "mdlrefDW->rtdw.pbom5jpcjj" , "mdlrefDW->rtdw.b5yo3nv33g" , "mdlrefDW->rtdw.oienxzjnme" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 30 , rtdwDataFieldNames ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( mdlrefDW -> rtdw . pophr5lzve ) , sizeof ( mdlrefDW -> rtdw . pophr5lzve ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( mdlrefDW -> rtdw . fy5ps0vnmo ) , sizeof ( mdlrefDW -> rtdw . fy5ps0vnmo ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( mdlrefDW -> rtdw . fyczfqu5d1 ) , sizeof ( mdlrefDW -> rtdw . fyczfqu5d1 ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( mdlrefDW -> rtdw . k3wtm0bzih ) , sizeof ( mdlrefDW -> rtdw . k3wtm0bzih ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( mdlrefDW -> rtdw . m2eudybppp ) , sizeof ( mdlrefDW -> rtdw . m2eudybppp ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 5 , ( const void * ) & ( mdlrefDW -> rtdw . fsvou2544p ) , sizeof ( mdlrefDW -> rtdw . fsvou2544p ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 6 , ( const void * ) & ( mdlrefDW -> rtdw . hheq0b5rgn ) , sizeof ( mdlrefDW -> rtdw . hheq0b5rgn ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 7 , ( const void * ) & ( mdlrefDW -> rtdw . bkeddeqpbw ) , sizeof ( mdlrefDW -> rtdw . bkeddeqpbw ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 8 , ( const void * ) & ( mdlrefDW -> rtdw . jxlucfehp1 ) , sizeof ( mdlrefDW -> rtdw . jxlucfehp1 ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 9 , ( const void * ) & ( mdlrefDW -> rtdw . knprixuhqy ) , sizeof ( mdlrefDW -> rtdw . knprixuhqy ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 10 , ( const void * ) & ( mdlrefDW -> rtdw . hyfypdejrs ) , sizeof ( mdlrefDW -> rtdw . hyfypdejrs ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 11 , ( const void * ) & ( mdlrefDW -> rtdw . i1rb5p2wdu ) , sizeof ( mdlrefDW -> rtdw . i1rb5p2wdu ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 12 , ( const void * ) & ( mdlrefDW -> rtdw . lcjh3yhjfv ) , sizeof ( mdlrefDW -> rtdw . lcjh3yhjfv ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 13 , ( const void * ) & ( mdlrefDW -> rtdw . aqogycpvqd ) , sizeof ( mdlrefDW -> rtdw . aqogycpvqd ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 14 , ( const void * ) & ( mdlrefDW -> rtdw . p1ynaxw2kn ) , sizeof ( mdlrefDW -> rtdw . p1ynaxw2kn ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 15 , ( const void * ) & ( mdlrefDW -> rtdw . pg2hyiwwhz ) , sizeof ( mdlrefDW -> rtdw . pg2hyiwwhz ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 16 , ( const void * ) & ( mdlrefDW -> rtdw . pepscbjqk4 ) , sizeof ( mdlrefDW -> rtdw . pepscbjqk4 ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 17 , ( const void * ) & ( mdlrefDW -> rtdw . mwdg02ndpd ) , sizeof ( mdlrefDW -> rtdw . mwdg02ndpd ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 18 , ( const void * ) & ( mdlrefDW -> rtdw . jmxm2hc1kh ) , sizeof ( mdlrefDW -> rtdw . jmxm2hc1kh ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 19 , ( const void * ) & ( mdlrefDW -> rtdw . n0bkstmppv ) , sizeof ( mdlrefDW -> rtdw . n0bkstmppv ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 20 , ( const void * ) & ( mdlrefDW -> rtdw . pgi1aok3cr ) , sizeof ( mdlrefDW -> rtdw . pgi1aok3cr ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 21 , ( const void * ) & ( mdlrefDW -> rtdw . g3a1sbd5cj ) , sizeof ( mdlrefDW -> rtdw . g3a1sbd5cj ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 22 , ( const void * ) & ( mdlrefDW -> rtdw . gedptl3pzo ) , sizeof ( mdlrefDW -> rtdw . gedptl3pzo ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 23 , ( const void * ) & ( mdlrefDW -> rtdw . buyauevq5n ) , sizeof ( mdlrefDW -> rtdw . buyauevq5n ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 24 , ( const void * ) & ( mdlrefDW -> rtdw . cdnjjogkeu ) , sizeof ( mdlrefDW -> rtdw . cdnjjogkeu ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 25 , ( const void * ) & ( mdlrefDW -> rtdw . piqmu5hx3l ) , sizeof ( mdlrefDW -> rtdw . piqmu5hx3l ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 26 , ( const void * ) & ( mdlrefDW -> rtdw . o4ablo3jr0 ) , sizeof ( mdlrefDW -> rtdw . o4ablo3jr0 ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 27 , ( const void * ) & ( mdlrefDW -> rtdw . pbom5jpcjj ) , sizeof ( mdlrefDW -> rtdw . pbom5jpcjj ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 28 , ( const void * ) & ( mdlrefDW -> rtdw . b5yo3nv33g ) , sizeof ( mdlrefDW -> rtdw . b5yo3nv33g ) ) ; mr_EvPowertrainController4EM_cacheDataAsMxArray ( rtdwData , 0 , 29 , ( const void * ) & ( mdlrefDW -> rtdw . oienxzjnme ) , sizeof ( mdlrefDW -> rtdw . oienxzjnme ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } ( void ) mdlrefDW ; return ssDW ; } void mr_EvPowertrainController4EM_SetDWork ( etgxjyp0hjh * mdlrefDW , const mxArray * ssDW ) { ( void ) ssDW ; ( void ) mdlrefDW ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtb ) , ssDW , 0 , 0 , sizeof ( mdlrefDW -> rtb ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . pophr5lzve ) , rtdwData , 0 , 0 , sizeof ( mdlrefDW -> rtdw . pophr5lzve ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . fy5ps0vnmo ) , rtdwData , 0 , 1 , sizeof ( mdlrefDW -> rtdw . fy5ps0vnmo ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . fyczfqu5d1 ) , rtdwData , 0 , 2 , sizeof ( mdlrefDW -> rtdw . fyczfqu5d1 ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . k3wtm0bzih ) , rtdwData , 0 , 3 , sizeof ( mdlrefDW -> rtdw . k3wtm0bzih ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . m2eudybppp ) , rtdwData , 0 , 4 , sizeof ( mdlrefDW -> rtdw . m2eudybppp ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . fsvou2544p ) , rtdwData , 0 , 5 , sizeof ( mdlrefDW -> rtdw . fsvou2544p ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . hheq0b5rgn ) , rtdwData , 0 , 6 , sizeof ( mdlrefDW -> rtdw . hheq0b5rgn ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . bkeddeqpbw ) , rtdwData , 0 , 7 , sizeof ( mdlrefDW -> rtdw . bkeddeqpbw ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . jxlucfehp1 ) , rtdwData , 0 , 8 , sizeof ( mdlrefDW -> rtdw . jxlucfehp1 ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . knprixuhqy ) , rtdwData , 0 , 9 , sizeof ( mdlrefDW -> rtdw . knprixuhqy ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . hyfypdejrs ) , rtdwData , 0 , 10 , sizeof ( mdlrefDW -> rtdw . hyfypdejrs ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . i1rb5p2wdu ) , rtdwData , 0 , 11 , sizeof ( mdlrefDW -> rtdw . i1rb5p2wdu ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . lcjh3yhjfv ) , rtdwData , 0 , 12 , sizeof ( mdlrefDW -> rtdw . lcjh3yhjfv ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . aqogycpvqd ) , rtdwData , 0 , 13 , sizeof ( mdlrefDW -> rtdw . aqogycpvqd ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . p1ynaxw2kn ) , rtdwData , 0 , 14 , sizeof ( mdlrefDW -> rtdw . p1ynaxw2kn ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . pg2hyiwwhz ) , rtdwData , 0 , 15 , sizeof ( mdlrefDW -> rtdw . pg2hyiwwhz ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . pepscbjqk4 ) , rtdwData , 0 , 16 , sizeof ( mdlrefDW -> rtdw . pepscbjqk4 ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . mwdg02ndpd ) , rtdwData , 0 , 17 , sizeof ( mdlrefDW -> rtdw . mwdg02ndpd ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . jmxm2hc1kh ) , rtdwData , 0 , 18 , sizeof ( mdlrefDW -> rtdw . jmxm2hc1kh ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . n0bkstmppv ) , rtdwData , 0 , 19 , sizeof ( mdlrefDW -> rtdw . n0bkstmppv ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . pgi1aok3cr ) , rtdwData , 0 , 20 , sizeof ( mdlrefDW -> rtdw . pgi1aok3cr ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . g3a1sbd5cj ) , rtdwData , 0 , 21 , sizeof ( mdlrefDW -> rtdw . g3a1sbd5cj ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . gedptl3pzo ) , rtdwData , 0 , 22 , sizeof ( mdlrefDW -> rtdw . gedptl3pzo ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . buyauevq5n ) , rtdwData , 0 , 23 , sizeof ( mdlrefDW -> rtdw . buyauevq5n ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . cdnjjogkeu ) , rtdwData , 0 , 24 , sizeof ( mdlrefDW -> rtdw . cdnjjogkeu ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . piqmu5hx3l ) , rtdwData , 0 , 25 , sizeof ( mdlrefDW -> rtdw . piqmu5hx3l ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . o4ablo3jr0 ) , rtdwData , 0 , 26 , sizeof ( mdlrefDW -> rtdw . o4ablo3jr0 ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . pbom5jpcjj ) , rtdwData , 0 , 27 , sizeof ( mdlrefDW -> rtdw . pbom5jpcjj ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . b5yo3nv33g ) , rtdwData , 0 , 28 , sizeof ( mdlrefDW -> rtdw . b5yo3nv33g ) ) ; mr_EvPowertrainController4EM_restoreDataFromMxArray ( ( void * ) & ( mdlrefDW -> rtdw . oienxzjnme ) , rtdwData , 0 , 29 , sizeof ( mdlrefDW -> rtdw . oienxzjnme ) ) ; } } void mr_EvPowertrainController4EM_RegisterSimStateChecksum ( SimStruct * S ) { const uint32_T chksum [ 4 ] = { 2258061877U , 880545477U , 3536618207U , 1210073722U , } ; slmrModelRefRegisterSimStateChecksum ( S , "EvPowertrainController4EM" , & chksum [ 0 ] ) ; } mxArray * mr_EvPowertrainController4EM_GetSimStateDisallowedBlocks ( ) { return ( NULL ) ; }
#if defined(_MSC_VER)
#pragma warning(disable: 4505) //unreferenced local function has been removed
#endif
